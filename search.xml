<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript 函数进阶</title>
    <url>/archives/js0802.html</url>
    <content><![CDATA[<!-- build time:Sun Aug 02 2020 22:21:56 GMT+0800 (GMT+08:00) --><h1 id="函数进阶">函数进阶</h1><p>本文将进一步讨论函数中的若干个重要属性：</p><ul><li>this</li><li>arguments</li><li>bind</li></ul><a id="more"></a><p>this 表示的是被调用的函数的上下文对象，而 arguments 参数表示函数调用过程中所有的参数。</p><p>函数在传递参数过程中，会隐式的传递两个参数 argument 和 this 。</p><h2 id="argument-参数">argument 参数</h2><p>argument 不管函数有没有定义形式参数，都会默认的接收来自函数调用的参数，是一个<strong>类数组结构</strong>（而不是数组），其长度是传入的实参个数。</p><p>代码例子如下:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"the length of arguments "</span> + <span class="built_in">arguments</span>.length);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the length of arguments 3</span></span><br><span class="line"><span class="comment">3 1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>arguments 实际上是对形式参数的一个别名的引用。</p><p>在非严格模式下，修改 arguments[0] 和修改第一个参数是等效的。</p><p>在严格模式下，修改 argument[0] 和修改第一个元素不等效。</p><h2 id="this-参数">this 参数</h2><p>this 称为函数的上下文。</p><p>this 的引用取决于 调用的位置与调用的方式。</p><p>调用函数的方式中主要有 4 种：</p><ul><li>作为一个函数直接调用</li><li>作为一个方法调用，即使用对象关联一个方法，并且通过对象调用方法</li><li>作为一个构造函数 new，实例化一个新的函数对象</li><li>通过函数 apply 或者 call 方法</li></ul><p>对应的代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">name</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">name</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a(<span class="string">'Hattori'</span>);</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> who;</span><br><span class="line">&#125;)(<span class="string">'Hattori'</span>); <span class="comment">//直接调用（默认绑定）</span></span><br><span class="line">obj.a(<span class="string">'Hattori'</span>); <span class="comment">//作为对象的方法调用（隐式绑定）</span></span><br><span class="line">obj = <span class="keyword">new</span> b(<span class="string">'Hattori'</span>); <span class="comment">//作为new创建新函数对象调用（new调用）</span></span><br><span class="line"><span class="comment">//作为 apply 和 call 调用（显式绑定）</span></span><br><span class="line">a.call(obj, <span class="string">'Hattori'</span>);</span><br><span class="line">a.apply(obj, [<span class="string">'Hattori'</span>]);</span><br></pre></td></tr></table></figure><h3 id="作为直接函数调用默认绑定">作为直接函数调用（默认绑定）</h3><p>直接使用<code>()</code>调用函数，并且被执行的函数表达式不是一个对象的属性时，即为一个（直接）函数调用。此时默认绑定取决于是否是严格模式。</p><ul><li>如果定义的函数处于严格模式下，那么 this 绑定到 undefined</li><li>如果定义的函数<strong>不处于严格模式下，那么 this 绑定到全局对象 window</strong></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.assert(a() == <span class="built_in">window</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(b() == <span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">  c(); <span class="comment">//c被直接调用 因此 c 的 this 被绑定到 window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"c"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">//默认绑定到全局对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="string">"oyx"</span></span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  输出</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">oyx</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p></p><h3 id="作为对象方法调用隐式绑定">作为对象方法调用（隐式绑定）</h3><p>当函数被赋值给一个对象的属性，并且使用这个对象的属性进行调用时，即为作为对象方法调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="string">"a"</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo"</span>, <span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br><span class="line"><span class="comment">// foo a</span></span><br></pre></td></tr></table></figure><p>在这个方法中，obj 对象具有属性 foo ，并且是对函数表达式 foo 的引用，最后在全局通过<code>对象.对象的方法</code>的方式对其进行调用。因此称为作为函数方法被调用。</p><p><strong>作为函数方法被调用的形式下，其 this 绑定到的是包含这个函数的对象。</strong></p><p>上面的代码例子中，foo 函数的 this 即绑定到了包含它的对象 obj 上。因此，函数 foo 输出 this.a 时，得到的是 a。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">whatsMyContext</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为whatsMyContext作为直接函数调用，使用默认绑定，函数的this绑定到了this</span></span><br><span class="line"><span class="built_in">console</span>.assert(whatsMyContext() === <span class="built_in">window</span>, <span class="string">"function call on window"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getMyThis = whatsMyContext;</span><br><span class="line"><span class="comment">//现在的上下文是 window</span></span><br><span class="line"><span class="built_in">console</span>.assert(getMyThis() === <span class="built_in">window</span>, <span class="string">"Another function call in window"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ninja1 = &#123;</span><br><span class="line">  getMyThis: whatsMyContext</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//现在的上下文是 ninja1</span></span><br><span class="line"><span class="built_in">console</span>.assert(ninja1.getMyThis() === ninja1, <span class="string">"Working with 1st ninja"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ninja2 = &#123;</span><br><span class="line">  getMyThis: whatsMyContext</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//现在的上下文是 ninja2</span></span><br><span class="line"><span class="built_in">console</span>.assert(ninja2.getMyThis() === ninja2, <span class="string">"Working with 2nd ninja"</span>);</span><br></pre></td></tr></table></figure><p>其中单独抽离出作为变量 ninja1 和 ninja2 来说，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">whatsMyContext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ninja1 = &#123;</span><br><span class="line">  getMyThis: whatsMyContext</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ninja2 = &#123;</span><br><span class="line">  getMyThis: whatsMyContext</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.assert(ninja1.getMyThis() === ninja1, <span class="string">"working with 1nd ninja1"</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(ninja2.getMyThis() === ninja2, <span class="string">"working with 2nd ninja2"</span>);</span><br></pre></td></tr></table></figure><h4 id="作为对象方法调用的意义">作为对象方法调用的意义</h4><p>作为对象方法调用（隐式绑定）是一种很重要的绑定，它意味着函数可以通过 this 访问到对象中的所有属性，是一种关联的方法。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">_name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = _name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"oyx"</span>,</span><br><span class="line">  getName: getName,</span><br><span class="line">  setName: setName,</span><br><span class="line">  print: print</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.print();<span class="comment">//oyx</span></span><br></pre></td></tr></table></figure><h3 id="作为构造函数调用new-绑定">作为构造函数调用（new 绑定）</h3><p>构造函数调用的主要方式是通过关键字 new。</p><p>通过 new 构造的函数对象，其 this 引用的函数对象是 new 返回的新创建的函数对象本身（例子中分别是 ninja1 和 ninja2 ）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ninja</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.shulk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ninja1 = <span class="keyword">new</span> Ninja();</span><br><span class="line"><span class="keyword">var</span> ninja2 = <span class="keyword">new</span> Ninja();</span><br><span class="line"><span class="built_in">console</span>.ninja1 = <span class="keyword">new</span> Ninja();</span><br><span class="line"><span class="built_in">console</span>.ninja2 = <span class="keyword">new</span> Ninja();</span><br><span class="line"><span class="built_in">console</span>.assert(ninja1.shulk() === ninja1, <span class="string">"The 1st ninja is skulking"</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(ninja2.shulk() === ninja2, <span class="string">"The 2nd ninja is skulking"</span>);</span><br></pre></td></tr></table></figure><h4 id="使用构造函数绑定-this-实现面向对象">使用构造函数绑定 this 实现面向对象</h4><p>其一般的 new 对象的操作是</p><ol type="1"><li>创建一个新的空对象</li><li>该对象的 this 传递给构造函数（例子中是 Ninja），从而成为构造函数的上下文</li><li>新构造的对象作为 new 运算符的返回值</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ninja</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.shulk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> === ninja1; <span class="comment">//利用了作用域提升</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ninja1 = <span class="keyword">new</span> Ninja();</span><br><span class="line"><span class="keyword">var</span> ninja2 = <span class="keyword">new</span> Ninja();</span><br><span class="line"><span class="built_in">console</span>.assert(ninja1.shulk() === ninja1, <span class="string">"The 1st ninja is shulk"</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(ninja2.shulk() === ninja2, <span class="string">"The 1st ninja is shulk"</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(ninja1.foo(), <span class="string">"ninja1 this 指向 ninja1"</span>);</span><br></pre></td></tr></table></figure><p>例子中两个函数对象 ninja1 和 ninja2 的 this 分别绑定到了自己的构造函数 Ninja 所生成的实例，也就是函数实例对象本身。</p><p>如上所示，ninja1 和 ninja2 的 this 都分别指向了自己即 ninja1 和ninja2.</p><h4 id="构造函数的返回值">构造函数的返回值</h4><h5 id="构造函数返回字面量原始值">构造函数返回字面量（原始值）</h5><p>构造函数的目的是初始化新创建的对象，并且新构造的对象会作为构造函数的调用结果（通过 new 运算符）返回。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回原始值的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ninja</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.skulk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//具有返回值的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.assert(Ninja() === <span class="number">1</span>, <span class="string">"当构造函数有返回值时，得到的是返回值"</span>);</span><br><span class="line"><span class="keyword">var</span> ninja = <span class="keyword">new</span> Ninja(); <span class="comment">//该函数通过 new 关键词以构造函数的形式被调用</span></span><br><span class="line"><span class="built_in">console</span>.assert(<span class="keyword">typeof</span> ninja === <span class="string">"object"</span>, <span class="string">"返回的是object 返回值1 被忽略了"</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(<span class="keyword">typeof</span> ninja.skulk === <span class="string">"function"</span>, <span class="string">"ninja object has a skulk method"</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(ninja.foo() === ninja, <span class="string">"ninja object 依然指向自己"</span>);</span><br></pre></td></tr></table></figure><p>当构造函数拥有返回值时。</p><ul><li>如果直接调用的是构造函数，则返回的是构造函数返回的返回值</li><li>如果是使用 new 来创建构造函数的对象，那么返回值是一个具体的对象，其过程和直接使用没有返回值的构造函数一样（返回值被忽略了），得到的依然是对象其 this 依然指向自己</li></ul><h5 id="构造函数返回对象值">构造函数返回对象值</h5><p>当构造函数返回的是一个对象时，得到的是该对象而不是 new 新创建的对象，此时构造函数是失效的，但是注意其函数的引用还是成功的绑定到了对象上。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">WhatReturns = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> puppet = &#123;</span><br><span class="line">  rules: <span class="literal">false</span>,</span><br><span class="line">  WhatReturns: WhatReturns</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Emperor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.rules = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> puppet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emperor = <span class="keyword">new</span> Emperor();</span><br><span class="line"><span class="built_in">console</span>.assert(emperor === puppet, <span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(emperor.rules === <span class="literal">false</span>, <span class="string">"b"</span>);</span><br><span class="line"><span class="comment">//引用还是成功的绑定了</span></span><br><span class="line"><span class="built_in">console</span>.log(emperor.WhatReturns() == emperor); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="构造函数注意事项">构造函数注意事项</h3><p>构造函数一般的命名方式是以大写字母开头的，表示当前的函数是一个构造器。</p><h3 id="作为-apply-和-call-调用显式绑定">作为 apply 和 call 调用（显式绑定）</h3><p>观察以下代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">Button</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.clicked = <span class="literal">false</span>;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.click = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.clicked = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.assert(button.clicked, <span class="string">"The button has been clicked"</span>);</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> button = <span class="keyword">new</span> Button();</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);</span></span><br><span class="line"><span class="actionscript">    elem.addEventListener(<span class="string">"click"</span>, button.click);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//Assertion failed: The button has been clicked</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时函数调用失败，发生判断错误 <code>button.clicked</code> 没有能够正常地被修改，这本质原因就是 <code>this</code> 和对象 <code>button</code> 绑定失败。</p><p>实际上， <code>button</code> 函数的上下文绑定到了 HTML 中的按钮，即 <code>&lt;button&gt;</code> 元素。因此上下文成为了 <code>&lt;button&gt;</code> 而不是 <code>button</code> 对象。</p><p>解决的方案之一，就是强制 <code>this</code> 绑定到 <code>button</code> 对象自己。方法是使用 <code>apply</code> 和 <code>call</code> 方法设置上下文。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">juggle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    result += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.result = result; <span class="comment">//拷贝一个引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ninja1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> ninja2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">juggle.apply(ninja1, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line">juggle.call(ninja2, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.assert(ninja1.result === <span class="number">10</span>, <span class="string">"juggled via apply"</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(ninja2.result === <span class="number">26</span>, <span class="string">"juggled via call"</span>);</span><br></pre></td></tr></table></figure><p>此时对象分别强制指向了第一个参数 ninja1 和 ninja2。</p><p>使用 <code>apply</code> 和 <code>call</code> 方法可以强制显式地设置函数的上下文。</p><ul><li><code>call</code> 适合一些无关的类型的值</li><li><code>apply</code> 适合数组对象使用</li></ul><h4 id="强制指定回调函数上下文">强制指定回调函数上下文</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显式绑定 + forEach 可以让代码更加函数式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">list, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    callback.call(list[i], i); <span class="comment">//强制绑定</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> weapons = [&#123;</span><br><span class="line">    type: <span class="string">'a'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">'b'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">'c'</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="comment">//使用回调函数</span></span><br><span class="line">forEach(weapons, <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.assert(<span class="keyword">this</span> === weapons[index], <span class="string">"got the val "</span> + weapons[index].type);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="解决上下文与预期不符合问题">解决上下文与预期不符合问题</h2><h3 id="使用箭头函数绕过函数上下文">使用箭头函数绕过函数上下文</h3><p>箭头函数没有单独的 this 值，<strong>箭头函数的 this 与声明所在的上下文相同</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button id=<span class="string">"test"</span>&gt;click me!&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script&gt;</span></span><br><span class="line"><span class="regexp">    function Button() &#123;</span></span><br><span class="line"><span class="regexp">      this.clicked = false;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/这里是箭头函数</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/因为 click 是对象的方法，并且是箭头函数，所以 this 获得的是对象的引用</span></span><br><span class="line"><span class="regexp">      this.click = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        this.clicked = true; /</span><span class="regexp">/等效于 button.clicked</span></span><br><span class="line"><span class="regexp">        console.assert(button.clicked, "the button has been clicked");</span></span><br><span class="line"><span class="regexp">      &#125;;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    var button = new Button();</span></span><br><span class="line"><span class="regexp">    var elem = document.getElementById("test");</span></span><br><span class="line"><span class="regexp">    elem.addEventListener("click", button.click);</span></span><br><span class="line"><span class="regexp">  &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><p>调用箭头函数时，不会隐式传入 this 参数，而<strong>是从定义的函数继承上下文</strong>。</p><p>在本例子中，箭头函数在构造函数的内部，this 指向新创建的对象本身，因此无论何时调用 click 函数，this 都将指向新创建的 button 对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button id=<span class="string">"test"</span>&gt;click me!&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script&gt;</span></span><br><span class="line"><span class="regexp">    console.assert(this === window, "this===window");</span></span><br><span class="line"><span class="regexp">    var button = &#123;</span></span><br><span class="line"><span class="regexp">      clicked: false,</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/this 临时绑定到 window 而不是 button </span></span><br><span class="line"><span class="regexp">      click: () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        this.clicked = true;</span></span><br><span class="line"><span class="regexp">        console.assert(button.clicked, "The button has been clicked");</span></span><br><span class="line"><span class="regexp">        console.assert(this === window, "In arrow function this === window");</span></span><br><span class="line"><span class="regexp">        console.assert(window.clicked, "clicked is sorted in window");</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><p>回顾下上面提到的,调用箭头函数时，不会隐式传入 <code>this</code> 参数，而<strong>是从定义的函数继承上下文</strong>。</p><p>因为 <code>button</code> 是一个字面量,因此 <code>button</code> 其 <code>this</code> 绑定在全局作用域 <code>window</code>.(默认绑定)</p><h3 id="使用bind">使用bind</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button id=<span class="string">"test"</span>&gt;click me!&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var button = &#123;</span></span><br><span class="line"><span class="regexp">      clicked: false,</span></span><br><span class="line"><span class="regexp">      click: function () &#123;</span></span><br><span class="line"><span class="regexp">        this.clicked = true;</span></span><br><span class="line"><span class="regexp">        console.assert(button.clicked, "The button has been clicked");</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">    var elem = document.getElementById("test");</span></span><br><span class="line"><span class="regexp">    elem.addEventListener("click", button.click.bind(button));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    var boundFuntion = button.click.bind(button);</span></span><br><span class="line"><span class="regexp">    console.assert(boundFuntion != button.click, "这个是一个新的函数")</span></span><br><span class="line"><span class="regexp">  &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><p>在上面的例子中,使用的是 <code>bind</code> 方法创建新函数,无论使用哪一种方法调用, <code>bind</code> 方法创建的新函数和原始函数的函数体都相同,新函数被绑定到指定的对象上.(例子这里是 <code>button</code>)</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScript</tag>
        <tag>「你不知道的 JavaScript」</tag>
      </tags>
  </entry>
  <entry>
    <title>this 绑定初步</title>
    <url>/archives/js0801.html</url>
    <content><![CDATA[<!-- build time:Sat Aug 01 2020 09:49:43 GMT+0800 (GMT+08:00) --><h1 id="this-绑定初步">this 绑定初步</h1><p>因为 this 是动态绑定的，this 与其调用的位置（调用的方式）有关，而和它声明的方式无关。this 的调用位置处会创建一个<strong>上下文</strong>，这个上下文的某个属性即为 this。</p><p>因此，能够结合调用栈分析并且快速找到对应 this 能够绑定的位置是十分关键的。</p><a id="more"></a><p>根据《你不知道的 JavaScript》一书中的介绍，this 的绑定规则如下：</p><h2 id="默认绑定">默认绑定</h2><p>当一个函数在全局被调用时，其 this 绑定到全局的 window</p><p>例如下面代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>此时的 this 指向的是 window对象，即全局对象。</p><p>其原因是 foo 是在全局被调用，按照一般规则，其调用栈是 全局对象 -&gt; foo。因此 this 绑定到了全局对象上。</p><h2 id="隐式绑定">隐式绑定</h2><p>隐式绑定适用于调用位置有上下文的情况。即该对象/函数被包含在某个对象中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo <span class="comment">//被 obj 对象包含，此时触发隐式绑定</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>隐式绑定条件：</p><ul><li>通过在对象内部包含一个指向一个函数的属性</li><li>并且通过这个属性间接引用函数</li></ul><p>foo 被 obj 包含并且调用是通过 obj 的属性来引用函数 foo 的，因此 foo 的上下文即为 obj ，此时 this 即绑定为 obj。</p><h3 id="隐式绑定丢失问题">隐式绑定丢失问题</h3><p>对比上面的代码，例子如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo <span class="comment">//被 obj 对象包含，此时触发隐式绑定</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">//函数的别名</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"全局的 a"</span>;</span><br><span class="line">bar(); <span class="comment">//全局的 a</span></span><br></pre></td></tr></table></figure><p>这里虽然符合上述的条件</p><ul><li>通过在对象内部包含一个指向一个函数的属性</li></ul><p>但是并不是通过这个属性间接引用函数，而是通过这个<strong>属性的别名</strong>引用的函数。因此此时会丢失 this ，使得函数 bar 的 this 和全局对象绑定。</p><h2 id="显式绑定">显式绑定</h2><p>通过使用 <code>apply</code> 和 <code>call</code> 可以将函数绑定到指定的对象，这个过程是显式绑定。</p><p>例如下面代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//call 与 apply 的第一个参数是绑定到 this 上</span></span><br><span class="line">foo.call(obj); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h3 id="常用的显式绑定硬绑定">常用的显式绑定——硬绑定</h3><p>在实践中，为解决绑定丢失问题，显示绑定中的硬绑定是常用方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo.call(obj); <span class="comment">//强制将 this 绑定到 obj</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">//2</span></span><br><span class="line">setTimeout(bar, <span class="number">1</span>); <span class="comment">//2</span></span><br><span class="line"><span class="comment">//硬绑定后不能再修改它的 this</span></span><br><span class="line">bar.call(<span class="built_in">window</span>); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h2 id="new-绑定">new 绑定</h2><p>使用 new 时会构造函数调用。步骤是</p><ol type="1"><li>创建一个全新对象</li><li>新对象执行 [[Prototype]] 连接</li><li>新对象绑定到函数调用的 this</li><li>如果函数没有返回其他对象，那么 new 表达式会自动返回这个新对象</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.a); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h2 id="优先级规则">优先级规则</h2><ol type="1"><li>函数是否再 new 中调用？（new 绑定）如果是，this 绑定的就是新创建的对象</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo();</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>函数是否通过 call、apply 或者硬绑定？（显式绑定）如果是,this 绑定的是指定的对象</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = foo.call(obj2);</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>函数是否再某个<strong>上下文对象</strong>中被调用？（隐式调用）如果是，this 绑定的是那个上下文对象。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = obj1.call();</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>如果都不是，那么使用的是默认绑定，如果是严格模式下 <code>&quot;use strict&quot;;</code> 默认绑定到 <code>undefined</code> ，否则绑定到全局对象。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = foo();</span><br></pre></td></tr></table></figure><h2 id="调试中查看上下文">调试中查看上下文</h2><p>如何在浏览器中调式查看上下文对象。</p><p>答案是在函数内部使用语句 <code>debugger;</code>，断点处的调用栈 (call stack) 中倒数第二个即为其 <strong>上下文对象</strong>。</p><p>例如以下代码：</p><p><img src="https://gitee.com/adameta/img/raw/master/1596246336_20200801094523571_22902.png"></p><p>例子中的函数是一个 new 绑定，因此 new 绑定会使得函数的 this 绑定到新创建的对象 foo 上，this 也自然地指向了 foo。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScript</tag>
        <tag>「你不知道的 JavaScript」</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 虚拟机固定IP</title>
    <url>/archives/LinuxStaticIP.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h1 id="linux-虚拟机固定ip">Linux 虚拟机固定IP</h1><p>最近做课设遇到一个问题，每次打开虚拟机IP地址都会改变，节点之间的通讯就会很麻烦，需要改IP。为了方便实验，试图把IP都设置为固定的。写下这篇文章主要是为了记录过程，供自己以后使用。</p><a id="more"></a><h2 id="确保虚拟机处于桥接模式">确保虚拟机处于桥接模式</h2><p>首先需要到 Linux 虚拟机中查看自己的 IP</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/adameta/img/raw/master/1592588025_20200620005956907_27579.png"></p><p>其中 eth0 是网卡，而 lo 是环回地址。这里网卡 IP 是 192.168.3.37 。</p><p>一般来说 eth0 都是桥接模式的网卡。</p><p>打开 编辑 -&gt; 编辑网络环境，点击更改设置如下：</p><p><img src="https://gitee.com/adameta/img/raw/master/1592588026_20200620010459413_20508.png"></p><p>打开刚才在 IP 中看到的 eth0 网卡，把桥接到设置为自己的常用网卡（比如我的是 无线网卡）<strong>而不是自动的</strong>。</p><p><img src="https://gitee.com/adameta/img/raw/master/1592588027_20200620010711837_31432.png"></p><h2 id="到主机上查看网络信息">到主机上查看网络信息</h2><p>回到 Windows 主机，查看主机的子网掩码、IP和网关，输入命令:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/adameta/img/raw/master/1592588027_20200620011013316_20073.png"></p><p>IPv4地址：192.168.3.3</p><p>子网掩码：255.255.255.0</p><p>默认网关：192.168.3.1</p><h2 id="修改-linux-网络配置">修改 Linux 网络配置</h2><p>键入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/network/interfaces</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/adameta/img/raw/master/1592588027_20200620011334123_23562.png"></p><p>编辑为如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> static address</span></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.3.37</span><br><span class="line">gateway 192.168.3.1</span><br><span class="line">netmask 255.255.255.0</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/adameta/img/raw/master/1592588028_20200620011803478_20309.png"></p><h2 id="设置dns">设置DNS</h2><p>设置DNS。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/resolvconf/resolv.conf.d/head</span><br></pre></td></tr></table></figure><p>键入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>最后重启即可。</p><h2 id="测试康康">测试康康</h2><p><img src="https://gitee.com/adameta/img/raw/master/1592588028_20200620012807067_8729.png"></p><p>ping 下 baidu 看看 DNS 吼不吼：</p><p><img src="https://gitee.com/adameta/img/raw/master/1592588028_20200620012901618_24656.png"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>随手记</tag>
        <tag>Linux</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript this和箭头函数</title>
    <url>/archives/js0415.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:46 GMT+0800 (GMT+08:00) --><h1 id="this-词法">this 词法</h1><p>ES6 中把 this 和词法作用域联系了起来。</p><p>ES6 添加了一个特殊的语法形式用于函数声明，叫做<em>箭头函数</em>。</p><a id="more"></a><p>例如下面的形式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>下面代码中，<strong>cool() 函数丢失了 this 之间的绑定</strong>，也就是说 setTimeout 中执行的 coolFn 函数中 this.id 是使用了全局作用域中的 id 。</p><p>最常用的是 <code>var self = this;</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	id: <span class="string">"awesome"</span>,</span><br><span class="line">	cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> id = <span class="string">"not awesome"</span>;</span><br><span class="line">obj.cool();<span class="comment">// awesome</span></span><br><span class="line">setTimeout(obj.cool, <span class="number">100</span>);<span class="comment">// not awesome</span></span><br></pre></td></tr></table></figure><p>解决的方法有好多，最为常用的是使用 <code>var self = this;</code> 。</p><p>使用如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	count: <span class="number">0</span>,</span><br><span class="line">	cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">//处于变量 obj 作用域中</span></span><br><span class="line">		<span class="keyword">if</span> (self.count &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">				self.count++;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">"awesome?"</span>);</span><br><span class="line">			&#125;, <span class="number">100</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.cool();<span class="comment">//awesome?</span></span><br></pre></td></tr></table></figure><p>使用 <code>var self = this;</code> 使得 self 和 this 一起绑定到了当前的作用域中。并且把 setTimeout 写到了 coolFn 函数中。</p><p>过程中使用的是词法作用域。 <strong>self 是一个可以通过词法作用域和闭包进行引用的标识符</strong>。</p><p>不关心 this 绑定的过程中发生了什么。</p><p>ES6 中引入箭头函数之后就可以改写为以下代码：</p><figure class="highlight plain"><figcaption><span>obj</span></figcaption><table><tr><td class="code"><pre><span class="line">	count: 0,</span><br><span class="line">	cool: function coolFn() &#123;</span><br><span class="line">		if (this.count &lt; 1) &#123;</span><br><span class="line">			setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">				this.count++;</span><br><span class="line">				console.log(&quot;awesonme?&quot;);</span><br><span class="line">			&#125;, 100)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.cool();&#x2F;&#x2F;awesome?</span><br></pre></td></tr></table></figure><p>简单的说，<em>箭头函数</em>在涉及 this 绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通 this 绑定的规则，取而代之的是用当前的词法作用域覆盖了 this 原来的值。因此在外部的函数调用时，对 this 的引用会对函数内部的值进行覆盖。</p><p>除了使用箭头函数的实践方式，还有一种就是使用 bind()</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	count: <span class="number">0</span>,</span><br><span class="line">	cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">				<span class="keyword">this</span>.count++;<span class="comment">//bind(..) 所以是安全的</span></span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">"awesome"</span>);</span><br><span class="line">			&#125;.bind(<span class="keyword">this</span>), <span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.cool();<span class="comment">//awesome</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScript</tag>
        <tag>「你不知道的 JavaScript」</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 闭包</title>
    <url>/archives/js0410.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h2 id="闭包">闭包</h2><h3 id="问题实质">问题实质</h3><p>闭包的定义：当函数可以记住并且访问所在的词法作用域时，就产生了闭包。即使函数是在当前词法作用域之外执行。</p><a id="more"></a><p>考虑以下代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 函数 bar 具有一个涵盖了 foo() 作用域的闭包</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar; <span class="comment">//把 bar 函数对象的引用作为返回值返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bar 函数在它自己作用域以外的区域执行！</span></span><br><span class="line"><span class="comment"> * 这就是闭包的神奇之处</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">baz(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>函数 bar() 具有一个覆盖了 foo() 作用域的<strong>闭包</strong>。</p><p>在这段代码中，我们将 foo() 作用域内部的函数 bar() 作为一个函数引用返回值传出。</p><p>baz 赋值为函数 foo() 的引用，之后调用了这个函数。</p><p>foo() 作用域内部的 bar() 函数被调用，而调用的地方正是其作用域之外。</p><p>Tips: 我们说的是 bar() 因为在 foo() 中被声明，因此它拥有涵盖 foo() 内部作用域的闭包。使得 foo() 一直能够存活（而不会被自动回收机制回收），以供 bar() 本身使用。</p><p><em>bar() 一直持有该作用域的引用，而这个引用就叫做闭包。</em></p><p>因此，在之后变量 baz 被调用，不出意外地它访问定义时的词法作用域，因此可以访问到了 a。因此，使用闭包，你可以使得函数可以继续访问定义时候的词法作用域！</p><p>另外一个使用到了闭包的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;<span class="comment">//baz 持有了 foo 的作用域的引用，即为持有了 foo 的闭包</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(baz); <span class="comment">//调用了 bar 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123; <span class="comment">// bar 函数调用了 fn() 函数</span></span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>考虑带有传递函数的例子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  fn = baz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fn(); <span class="comment">//闭包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><blockquote><p>无论通过如何的手段将内部函数传递到所在词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数，都会使用闭包。</p></blockquote><h3 id="进一步探究">进一步探究</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(message);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">wait(<span class="string">"Hello,closure!"</span>);</span><br></pre></td></tr></table></figure><p>将一个内部函数，名为 timer 传递给 setTimeout(...)。timer 具有涵盖 wait(...) 作用域的闭包。因此保留有对变量 message 的引用。</p><p>wait(...) 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然会保持有 wait() 作用域的闭包。</p><p>在引擎的内部，内置的工具函数 setTimeout(...) 持有对一个参数的引用，这个参数也许叫 fn 或者 func，或者其他的名字。</p><p>引擎调用了这个函数，在例子中就是内部的 timer 函数，而词法作用域在整个过程中是保持完整的。</p><p>实际上，只要使用了回调函数，就是在使用了闭包，因为在回调函数传入函数参数的时候，实际上使用的是函数参数所在的作用域的引用。</p><p>上面一直在提的 IIFE 模式就是一个闭包。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h4 id="循环和闭包">循环和闭包</h4><p>考虑下面代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">实际输出</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>尽管每一个循环中的五个函数是在各自的迭代中分别定义的，但是它们都<strong>被封闭在一个共享的全局作用域中</strong>，所以实际上只有一个 i 。</p><p>实际的执行过程是：执行了 5 次 setTimeout 调用，每一次都是传入了 timer 被调用的时间参数，于是第 1 、 2 、3 ... 秒都正确的预期的调用函数。</p><p>但是对于回调函数 timer 在被真正执行的时候，它去寻找的是位于<strong>全局作用域</strong>的 i。</p><p>此时，for 已经被执行完了， i 被自加到了 6，因此，回调函数 timer() 执行时所使用的 i 是通过作用域查询机制得到的全局作用域的 i 。</p><p>解决方案1：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">实际输出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>解决方案2：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">实际输出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>上面两种方案的思路都是一样的，让每一次迭代中的 i 所在的作用域都不一致，第一个是每一次迭代都创造了一个 IIFE 的作用域，第二个是利用 let 将 for 块和他们绑定在一起，每次迭代都会让 let 在循环之间传递。</p><p>关于最后一句 let 的解释进行扩充:<strong>每一次迭代都会声明</strong>（和一般理解的 for 不一样），随后的每个迭代器都会使用上一个迭代器结束时的值来初始化。</p><h4 id="模块">模块</h4><p>闭包最大的用处就是<strong>模块</strong>。</p><p>考虑下面代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line">  <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(something);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(another.join(<span class="string">"!"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如代码中所示，其中没有明显的闭包，只有两个私有的数据变量 something 和 another，以及 dosomething() 和 doAnother() 两个内部函数。</p><p>它们的词法作用域（也就是闭包）也就是 foo() 内部的作用域。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123; <span class="comment">//模块</span></span><br><span class="line">  <span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line">  <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(something);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(another.join(<span class="string">" ! "</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    doSomething: doSomething,</span><br><span class="line">    doAnother: doAnother</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = CoolModule();</span><br><span class="line"></span><br><span class="line">foo.doSomething();</span><br><span class="line">foo.doAnother();</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">cool</span></span><br><span class="line"><span class="comment">1 ! 2 ! 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个模式在 JavaScript 中叫做<strong>模块</strong>。最常见的实现模块模式的方法通常被叫做<strong>模块暴露</strong>。</p><p>这里是做了什么操作呐？</p><p>首先是调用了一个函数模块实例 CoolModule() ，如果不执行外部函数，内部作用域和闭包都无法被创建。</p><p>然后，CoolModule() 返回一个用对象字面量语法 { key: value, ... } 来表示的对象。</p><p>这个返回的对象包含有对<strong>内部函数</strong>而不是内部数据变量的<strong>引用</strong>。（也就是说它返回的是一个闭包）</p><p>这样保持了内部数据变量是隐藏并且私有的状态，可以把这个对象的返回值类型看作本质上是模块的公共 API。</p><p>这个对象类型的返回值最终被赋值给外部的变量 foo，然后就可以通过使用它来访问 API 中的属性和方法。</p><p>因为 doSomething 和 doAnother 函数具有涵盖模块实例内部作用域的闭包。</p><p>模块通过返回一个具有属性引用的对象的方式来将函数传递到词法作用域的外部。</p><p>总结来看，模块模式需要两个必要条件：</p><ul><li>必须具有外部封闭函数，并且该函数至少被调用一次（每次调用都会创造一个新的模块实例）</li><li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li></ul><hr><p>上述的 CoolModule() 的独立的模块创建器，可以被调用任意多次，每一次调用都会创建出一个新的模块实例。</p><p>当只需要一个实例时，我们使用 IIFE 来创建一个<strong>单例模式</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用了 IIFE 进行创建的单例模式</span></span><br><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line">  <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(something);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(another.join(<span class="string">" ! "</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    doSomething: doSomething,</span><br><span class="line">    doAnother: doAnother</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">foo.doSomething();</span><br><span class="line">foo.doAnother();</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">cool</span></span><br><span class="line"><span class="comment">1 ! 2 ! 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><p>模块是一个函数，因此可以用于接受参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    identify: identify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo1 = CoolModule(<span class="string">"foo 1"</span>);</span><br><span class="line"><span class="keyword">var</span> foo2 = CoolModule(<span class="string">"foo 2"</span>);</span><br><span class="line">foo1.identify(); <span class="comment">//"foo 1"</span></span><br><span class="line">foo2.identify(); <span class="comment">//"foo 2"</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//修改公共 API</span></span><br><span class="line">    publicAPI.identify = identify2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">identify1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">identify2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id.toUpperCase());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> publicAPI = &#123;</span><br><span class="line">    change: change,    <span class="comment">//修改 API 的函数</span></span><br><span class="line">    identify: identify1 <span class="comment">//对 API 的引用</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> publicAPI;</span><br><span class="line">&#125;)(<span class="string">"foo module"</span>);</span><br><span class="line"></span><br><span class="line">foo.identify(); <span class="comment">//foo module</span></span><br><span class="line">foo.change();</span><br><span class="line">foo.identify(); <span class="comment">//FOO MODULE</span></span><br></pre></td></tr></table></figure><h4 id="现代模块机制">现代模块机制</h4><p>大部分模块都依赖于加载器/管理器本质上都是将这种模块定义封装进一个友好的 API。</p><p>现代的做法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deps.length; i++) &#123;</span><br><span class="line">      deps[i] = modules[deps[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    modules[name] = impl.apply(impl, deps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> modules[name];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    define: define,</span><br><span class="line">    <span class="keyword">get</span>: <span class="keyword">get</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这段代码的核心是 <code>modules[name] = impl.apply(impl, deps);</code>。</p><p>为了模块的定义引入了包装函数（可以传入任何依赖），并将返回值，也就是模块的 API ，存储在一个根据名字来管理的模块列表中。</p><p>//todo: 该部分未能理解，待完善补充。</p><h3 id="闭包小结">闭包小结</h3><p>闭包的思想是</p><p>位于作用域之内的函数是一个值，可以任意进行传递。</p><p><em>当函数可以记住并访问所在的词法作用域，即使函数是在当前的词法作用域之外执行，这时就产生了闭包。</em></p><p>使用闭包，可以做很多事情，最典型的就是实现<strong>模块</strong>模式。</p><p>模块具有的两个主要的特征：</p><ul><li>为创建内部作用域而调用了一个包装（模块）函数</li><li>包装（模块）函数的返回值至少包括一个对内部函数的引用，这样就会创造涵盖了整个包装函数内部作用域的闭包。</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScript</tag>
        <tag>「你不知道的 JavaScript」</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 提升</title>
    <url>/archives/js0408.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:46 GMT+0800 (GMT+08:00) --><h2 id="提升">提升</h2><p>关于作用域，不管是函数作用域还是块作用域，可以总结为：任何声明在某个作用域内的变量，都将属于这个作用域。</p><p>但是还有些细节没有完全讨论，即声明出现的位置产生的联系。</p><a id="more"></a><h3 id="先有鸡还是先有蛋问题">先有鸡还是先有蛋问题</h3><p>直觉会认为 JavaScript 代码在执行时是由上面到下面一行一行执行的。但是这不是完全正确的，有一种情况会导致这种错误。</p><p>比如下面的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>一般人会认为输出的应该是 undefined ，实际上是输出 2 ，因为 <code>var a</code> 声明在 <code>a = 2</code> 之后，可能会认为 var a; 又被重新赋值了，从而导致了 undefined 。</p><p>考虑另一段代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>鉴于上一个代码片段所表现出来的某种非自上而下的特点，可能会认为这个也是输出 2 ，但是也有人会认为在输出时，没有声明了 a ，应该输出 ReferenceError 异常。</p><p>可惜两种都不正确。输出的是 undefined。</p><p>接下来，将讨论声明和赋值的顺序问题。</p><h3 id="从编译器角度理解">从编译器角度理解</h3><p>在之前的文章中，我们介绍了引擎的工作原理，解释了 JavaScript 在代码运行之前的编译过程：找到变量的合适声明，并且把变量和当前的作用域结合绑定。</p><p>因此，思路是这样的：包括变量和函数（记得嘛？函数也是个 rhs 右值）在内的所有声明都会在任何代码执行之前被首先处理。</p><p>所以当你看到 <code>var a = 2;</code> 时，可能会认为这个是一个声明。但是其实这个会被 JavaScript 处理为两个声明：</p><ul><li>var a ;</li><li>a=2;</li></ul><p>第一个定义声明是在编译阶段进行的，第二个赋值声明会在<strong>留在原地</strong>等待执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//---------------</span></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="comment">//---------------</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>那么考虑上面的两个例子，实际是这样等效的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//2</span></span><br><span class="line"><span class="comment">//----等效于----</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//---等效于---</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//undefinded</span></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>因为这个过程中，变量 a 好像从声明它的地方移动到了最上面，这个过程就被称为<strong>提升</strong>。</p><p>即，到底是先有鸡（声明）还是先有蛋（赋值）。</p><p>Tips: <strong>只有声明本身会被提升</strong>，而赋值和其他运行逻辑会被留在<strong>原地</strong>。如果提升改变了代码的执行顺序，会造成一些莫名其妙的错误。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//undefined 而不是 ReferenceError</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---等效于---</span></span><br><span class="line"><span class="keyword">var</span> foo;<span class="comment">//发生了提升！</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;<span class="comment">//发生了提升！</span></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//undefined 而不是 ReferenceError</span></span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();<span class="comment">//这里是含有 foo 的声明</span></span><br></pre></td></tr></table></figure><p>在这里的例子中， <code>foo</code> 的函数声明被提升，因此第一行的调用可以正常的执行。</p><p>而各自的作用域中也会发生提升。</p><p>因此，在 <code>foo</code> 的函数声明作用域中，a 的声明被提升到了函数的第一行。</p><p><em>提别注意</em>：尽管函数声明会被提升（上面例子中的 foo 函数声明），但是<strong>函数表达式不会被提升</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo(); <span class="comment">//不是 ReferenceError，而是 TypeError</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// dosomething</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，函数被首先调用，即发生了一个函数的声明的提升（foo 此时没有被赋值，如果它此时是一个函数表达式就会被赋值），随后 <code>foo()</code> 的调用（前面提过，当函数右值带有了 <code>()</code> 就是说明进行了调用），<code>foo()</code> 由于对 <code>undefined</code> 值进行了调用（应该去调用一个函数右值）导致了非法的操作。</p><p>再次说明，这个例子中，bar 不会被提升，而是在赋值动作发生时才会有声明。</p><p>于是发生的是 TypeError，不是 ReferenceError。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo(); <span class="comment">//不是 ReferenceError，而是 TypeError</span></span><br><span class="line">bar(); <span class="comment">//ReferenceError</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// dosomething</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//---等效于---</span></span><br><span class="line"><span class="keyword">var</span> foo; <span class="comment">//发生了提升！</span></span><br><span class="line">foo(); <span class="comment">//不是 ReferenceError，而是 TypeError</span></span><br><span class="line">bar(); <span class="comment">//ReferenceError！因为 bar 是函数表达式不会发生提升</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// dosomething</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="函数优先">函数优先</h3><p>关于提升，还有一个重要的细节。</p><p>函数的提升<strong>优先</strong>于变量的提升。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo(); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输出的是 1 而不是 2。</p><p>这段代码会被<strong>引擎</strong>理解为这个样子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo; <span class="comment">//函数的提升</span></span><br><span class="line"><span class="comment">// var foo; //变量的声明 -&gt; 重复的声明！忽略</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，尽管 <code>var foo</code>出现在了 <code>function foo(){...}</code> 之前，但是它是重复的声明，因此被忽略啦。</p><p>这里例子说明了函数的提升是优于变量的声明的。</p><p>还有其他细节嘛?</p><p>是的还有：</p><p>虽然重复的 var 声明会被忽略，但是出现在后面的函数声明还是可以覆盖前面的。</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo(); <span class="comment">//3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);<span class="comment">//发生覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>foo</code> 首先会被提升，随后即时运行阶段，输出 3 的 <code>foo</code> 会对其进行覆盖。</p><p>Tips: 在同一个作用域中进行重复定义会引起莫名其妙的错误！不要这样做。</p><p>最后，再引入一个容易出错的例子。</p><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo(); <span class="comment">//TypeError: foo is not a function</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---等效于---</span></span><br><span class="line"><span class="keyword">var</span> foo; <span class="comment">//被提升到了这里</span></span><br><span class="line">foo(); <span class="comment">//TypeError: foo is not a function</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，<code>foo</code> 的声明是位于普通的块中，我们知道普通的块并不具有绑定变量作用域的作用。</p><p>因此，<code>foo</code> 的声明实际上是被提升到了全局作用域的最上面。</p><p>之后 <code>foo()</code> 的调用导致了 <code>TypeError</code> 错误。</p><h3 id="提升小结">提升小结</h3><p>不要试图把 <code>var a = 2;</code> 看作一个声明，实际上 JavaScript 引擎认为它是两个部分，分别为 <code>var a</code> 赋值和 <code>a = 2</code> 声明。</p><p>第一个阶段是发生在编译期间，第二个是即时执行期间。</p><p>由于上面所描述的特性。</p><p>Tips: 在当前作用域中，无论声明出现在声明地方，都会在代码本身被执行处理之前<em>首先</em>进行处理。这个过程即好像是把所有的声明（变量和函数的声明）都被移动到了当前作用域的最顶端。这个过程即为<strong>提升</strong>。</p><p>声明本身会被提升，但是包括<strong>函数表达式</strong>的赋值在内<strong>赋值操作</strong>并<em>不会</em>被提升。</p><p>同时，注意警惕，不要在同一个作用域中重复声明，否则会导致普通的变量声明和函数声明混合在一起，导致很多莫名其妙的问题。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScript</tag>
        <tag>「你不知道的 JavaScript」</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 函数作用域和块作用域</title>
    <url>/archives/js0406.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h2 id="函数作用域和块作用域">函数作用域和块作用域</h2><h3 id="函数中的作用域">函数中的作用域</h3><p>在上文中已经讨论过了函数产生的作用域问题。</p><a id="more"></a><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar();<span class="comment">//失败的调用</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b,c);<span class="comment">//都是失败的，因为a,b,c都在 foo 的作用域中</span></span><br></pre></td></tr></table></figure><p>在上述代码中，产生了一个函数作用域 <code>foo</code></p><p>所谓函数作用域就是: 属于这个函数的所有变量都可以在整个函数的范围内使用和复用。</p><h3 id="隐藏内部实现">隐藏内部实现</h3><p>一个显而易见的<strong>隐藏</strong>手段就是使用函数对一段代码进行封装。</p><p>换句话说，当使用一个函数把变量和函数进行封装时，就相当于把他们限制和隐藏在了一个块中，块外的代码不能随意的访问这段代码。</p><p>这种作用域的隐藏方法被称为 <strong>最小特权原则</strong>（也叫最小暴露原则或者最小暴露原则）</p><p>如果一些函数 X 仅仅是某个函数 A 的私有函数，那么就应该设置 X 作为 A 的作用域中。</p><h3 id="避免冲突">避免冲突</h3><p>另一个隐藏的好处是可以避免同名标识符之间的命名冲突。</p><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    i = <span class="number">3</span>; <span class="comment">//修改了for中的i</span></span><br><span class="line">    <span class="built_in">console</span>.log(a + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    bar(i * <span class="number">2</span>);<span class="comment">//因为bar中对i的修改，这个for循环会永远进行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>因为 bar 中对 i 进行了修改，因此 for 循环将会永远进行。</p><p>有两种合理的解决方案：</p><ul><li>采用不同的函数命名，例如修改 bar 中的 i 为 j 。</li><li>采用函数屏蔽的方法，即在 bar 作用域中声明一个新的变量 var i，这样就完成了对外的屏蔽效果。</li></ul><p>而在一般情况下，命名是不免会有冲突的，因此我们常常使用的第二种方法，即在使用的变量单独声明到当前作用域，以此达到屏蔽的效果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">3</span>; <span class="comment">//修改了for中的i</span></span><br><span class="line">    <span class="built_in">console</span>.log(a + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    bar(i * <span class="number">2</span>);<span class="comment">//因为bar中对i的修改，这个for循环会永远进行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">17</span></span><br><span class="line"><span class="comment">19</span></span><br><span class="line"><span class="comment">21</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="全局命名空间">全局命名空间</h4><p>一个避免冲突的方法是使用全局命名空间。</p><p>变量冲突的一个典型例子存在于全局作用域，当一个程序加载了多个第三方库时，如果没有合理妥善地将内部私有的函数或者变量隐藏起来，就容易引发冲突。</p><p>通常来讲，这些库会在全局作用域中声明一个名字足够独特的变量，通常是一个对象，然后将这个对象用作库的<strong>命名空间</strong>，所有暴露给外界的功能都会称为这个对象的<strong>属性</strong>。（而不是将自己的标识符暴露在顶级词法作用域中）。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyReallyCoolLibrary = &#123;</span><br><span class="line">  awesome : <span class="string">"stuff"</span>,</span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi,here"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  doAnotherthing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ops"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyReallyCoolLibrary.doSomething();</span><br><span class="line">MyReallyCoolLibrary.doAnotherthing();</span><br></pre></td></tr></table></figure><p>这个例子中，命名空间 <code>MyReallyCoolLibrary</code> 仅仅暴露给外界三个变量：<code>awesome</code> <code>doSomething</code> <code>doAnotherthing</code>。</p><h4 id="模块管理">模块管理</h4><p>另一个避免冲突的方法和现代的<strong>模块</strong>机制相近。就是从众多模块管理器中挑选一个来使用。</p><p>使用这些工具，任何库都不需要将标识符加入到全局作用域中，而是通过依赖管理器的机制将库中的标识符显式地导入到另外一个特定的作用域中。</p><p>我们将会在后面章节介绍这种<strong>模块机制</strong>。</p><h3 id="函数作用域">函数作用域</h3><p>上述中使用函数简单地把一个代码块封装隐藏的方式也有一些问题，首先考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">//&lt;--- 添加这一行</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;; <span class="comment">//&lt;--- 添加这一行</span></span><br><span class="line">foo(); <span class="comment">//&lt;--- 添加这一行</span></span><br><span class="line"><span class="comment">//添加上述的三行，即可把代码块进行封装</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>存在以下问题：</p><ul><li>foo 函数会污染全局命名空间，有可能导致全局的命名冲突</li><li>声明后仍然需要手动调用，例如上述中是 <code>foo();</code></li></ul><p>为了解决上述问题， <code>javascript</code> 提供了一些解决的机制，使得调用自动化，并且无法污染函数所在的作用域。</p><p>考虑下面代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">//&lt;--- 添加这一行</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)(); <span class="comment">//&lt;--- 添加这一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决了作用域污染和手动调用的问题</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>对于这个例子中,我们使用 <code>()</code> 把函数包含起,即为函数是被当作一个<strong>函数表达式</strong>处理而不是一个普通的函数声明来处理。</p><p>随后再使用了 <code>()</code> 来宣布对函数表达式的调用。</p><blockquote><p>Tips: 区分函数声明和函数表达式的方法是看 <code>function</code> 关键词出现再声明中的位置。如果 <code>function</code> 是声明中的第一个次就是一个函数声明，否则就是一个函数表达式。</p></blockquote><p>函数声明和函数表达式的<strong>区别</strong>：</p><p>比较下前面两个代码片段，第一个片段的 <code>foo</code> <strong>被绑定在所在的作用域中</strong>，可以通过 <code>foo()</code> 直接调用它，第二个片段中 <code>foo</code> <strong>被绑定在函数表达式自身的函数中</strong>而不是作用域中。</p><p>也就是说 <code>(function foo() {...})();</code> 作为函数表达式意味着 <code>foo</code> 只能在 <code>...</code> 所代表的位置中被访问，外部的作用域则不能。并且， <code>foo</code> 变量名被隐藏在自身意味着不会非必要地勿扰外部的作用域。</p><h3 id="匿名和具名">匿名和具名</h3><p>对于函数表达式中的<strong>回调参数</strong>用法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//&lt;-----这个是一个匿名函数表达式</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>这叫做<strong>匿名表达式</strong>，因为 <code>function()</code> 没有名字标识符。函数表达式可以是匿名的。而函数声明则可以不可以省略函数名。</p><p>总结来说匿名函数表达式的写法好处有:</p><ul><li>不污染所在作用域</li><li>写法快捷方便</li><li>风格优雅<del>(某些人不这样认为)</del></li></ul><p>缺点：</p><ul><li>匿名函数不会在栈追踪中显示出有意义的函数名，使得调试变得困难</li><li>如果没有函数名，当函数需要引用自身时只能使用已经过期的 <code>arguments.callee</code> 引用。比如在递归过程中，另一个函数需要引用自己，是在事件触发后事件监听器需要解释自身。</li><li>匿名函数省略了对于代码可读性/可理解性很重要的函数名，使得匿名函数的可读性变差</li></ul><p>对于上述第三个缺点，可以使用<strong>行内函数表达式</strong>解决：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timeoutHandler</span>(<span class="params"></span>)</span>&#123;<span class="comment">//&lt;-----这个是行内函数表达式</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="立即执行函数表达式">立即执行函数表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>由于函数被封装包含在一个 <code>()</code> 内，因此它是一个函数表达式，并有名字，所以是一个行内函数表达式。</p><p>第一个 <code>()</code> 是说明这个是一个函数表达式，第二个 <code>()</code> 是说明这个是立即执行的。这种函数在社区被称为 <code>IIFE</code> ( Immediately Invoked Function Expression )，代表<strong>立即执行表达式</strong>。</p><p>函数名对 <code>IIFE</code> 当然不是必须的，<code>IIFE</code> 最常用的用法是使用一个匿名函数表达式，虽然使用具名函数的 <code>IIFE</code> 不常见，但是它和匿名函数表达式有一样的效果，是一种极佳的实践方式。</p><p>传统的 <code>IIFE</code> 写法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//3</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>另一种改进的 <code>IIFE</code> 写法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//3</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>注意对比，两种写法的不同之处，第二种把第二个 <code>()</code> 放在了第一个 <code>()</code> 之中，而第一种写法则是单独放在外面。</p><p><code>IIFE</code>的高级用法：把它们当作函数调用并且传递参数进去。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//3</span></span><br><span class="line">  <span class="built_in">console</span>.log(global.a); <span class="comment">//2</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>这里是把 <code>window</code> 对象的引用传递进了函数，并且把它命名为 <code>global</code>。</p><p>这个模式的另外一个重要的应用场景是解决 <code>undefined</code> 标识符的默认值被错误覆盖导致的异常。（并不常见）</p><p>将第一个参数命名为 <code>undefined</code> ，但是在对应的位置不传入任何值，这样就能保证代码块中的 <code>undefined</code> 是真的 <code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="literal">true</span>; <span class="comment">//被错误修改的 undefined &lt;----- 这种做法非常不好！</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">undefined</span>) </span>&#123; <span class="comment">//正确的 undefined </span></span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123; <span class="comment">//这里的 undefined 是真的 undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Undefined is safe in function!"</span>); <span class="comment">//Undefined is safe in function!</span></span><br><span class="line">    <span class="comment">//----&gt; 正确的 undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//----&gt; 被污染的 undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>扩展连接：<code>undefined</code> 的介绍<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener external nofollow noreferrer">undefined</a></p></blockquote><p>最后一种 <code>IIFE</code> 的用法是倒置代码的执行顺序。</p><h2 id="函数作用域和块作用域-1">函数作用域和块作用域</h2><h3 id="函数中的作用域-1">函数中的作用域</h3><p>在上文中已经讨论过了函数产生的作用域问题。</p><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar();<span class="comment">//失败的调用</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b,c);<span class="comment">//都是失败的，因为a,b,c都在 foo 的作用域中</span></span><br></pre></td></tr></table></figure><p>在上述代码中，产生了一个函数作用域 <code>foo</code></p><p>所谓函数作用域就是: 属于这个函数的所有变量都可以在整个函数的范围内使用和复用。</p><h3 id="隐藏内部实现-1">隐藏内部实现</h3><p>一个显而易见的<strong>隐藏</strong>手段就是使用函数对一段代码进行封装。</p><p>换句话说，当使用一个函数把变量和函数进行封装时，就相当于把他们限制和隐藏在了一个块中，块外的代码不能随意的访问这段代码。</p><p>这种作用域的隐藏方法被称为 <strong>最小特权原则</strong>（也叫最小暴露原则或者最小暴露原则）</p><p>如果一些函数 X 仅仅是某个函数 A 的私有函数，那么就应该设置 X 作为 A 的作用域中。</p><h3 id="避免冲突-1">避免冲突</h3><p>另一个隐藏的好处是可以避免同名标识符之间的命名冲突。</p><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    i = <span class="number">3</span>; <span class="comment">//修改了for中的i</span></span><br><span class="line">    <span class="built_in">console</span>.log(a + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    bar(i * <span class="number">2</span>);<span class="comment">//因为bar中对i的修改，这个for循环会永远进行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>因为 bar 中对 i 进行了修改，因此 for 循环将会永远进行。</p><p>有两种合理的解决方案：</p><ul><li>采用不同的函数命名，例如修改 bar 中的 i 为 j 。</li><li>采用函数屏蔽的方法，即在 bar 作用域中声明一个新的变量 var i，这样就完成了对外的屏蔽效果。</li></ul><p>而在一般情况下，命名是不免会有冲突的，因此我们常常使用的第二种方法，即在使用的变量单独声明到当前作用域，以此达到屏蔽的效果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">3</span>; <span class="comment">//修改了for中的i</span></span><br><span class="line">    <span class="built_in">console</span>.log(a + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    bar(i * <span class="number">2</span>);<span class="comment">//因为bar中对i的修改，这个for循环会永远进行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">17</span></span><br><span class="line"><span class="comment">19</span></span><br><span class="line"><span class="comment">21</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="全局命名空间-1">全局命名空间</h4><p>一个避免冲突的方法是使用全局命名空间。</p><p>变量冲突的一个典型例子存在于全局作用域，当一个程序加载了多个第三方库时，如果没有合理妥善地将内部私有的函数或者变量隐藏起来，就容易引发冲突。</p><p>通常来讲，这些库会在全局作用域中声明一个名字足够独特的变量，通常是一个对象，然后将这个对象用作库的<strong>命名空间</strong>，所有暴露给外界的功能都会称为这个对象的<strong>属性</strong>。（而不是将自己的标识符暴露在顶级词法作用域中）。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyReallyCoolLibrary = &#123;</span><br><span class="line">  awesome : <span class="string">"stuff"</span>,</span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi,here"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  doAnotherthing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ops"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyReallyCoolLibrary.doSomething();</span><br><span class="line">MyReallyCoolLibrary.doAnotherthing();</span><br></pre></td></tr></table></figure><p>这个例子中，命名空间 <code>MyReallyCoolLibrary</code> 仅仅暴露给外界三个变量：<code>awesome</code> <code>doSomething</code> <code>doAnotherthing</code>。</p><h4 id="模块管理-1">模块管理</h4><p>另一个避免冲突的方法和现代的<strong>模块</strong>机制相近。就是从众多模块管理器中挑选一个来使用。</p><p>使用这些工具，任何库都不需要将标识符加入到全局作用域中，而是通过依赖管理器的机制将库中的标识符显式地导入到另外一个特定的作用域中。</p><p>我们将会在后面章节介绍这种<strong>模块机制</strong>。</p><h3 id="函数作用域-1">函数作用域</h3><p>上述中使用函数简单地把一个代码块封装隐藏的方式也有一些问题，首先考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">//&lt;--- 添加这一行</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;; <span class="comment">//&lt;--- 添加这一行</span></span><br><span class="line">foo(); <span class="comment">//&lt;--- 添加这一行</span></span><br><span class="line"><span class="comment">//添加上述的三行，即可把代码块进行封装</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>存在以下问题：</p><ul><li>foo 函数会污染全局命名空间，有可能导致全局的命名冲突</li><li>声明后仍然需要手动调用，例如上述中是 <code>foo();</code></li></ul><p>为了解决上述问题， <code>javascript</code> 提供了一些解决的机制，使得调用自动化，并且无法污染函数所在的作用域。</p><p>考虑下面代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">//&lt;--- 添加这一行</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)(); <span class="comment">//&lt;--- 添加这一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决了作用域污染和手动调用的问题</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>对于这个例子中,我们使用 <code>()</code> 把函数包含起,即为函数是被当作一个<strong>函数表达式</strong>处理而不是一个普通的函数声明来处理。</p><p>随后再使用了 <code>()</code> 来宣布对函数表达式的调用。</p><blockquote><p>Tips: 区分函数声明和函数表达式的方法是看 <code>function</code> 关键词出现再声明中的位置。如果 <code>function</code> 是声明中的第一个次就是一个函数声明，否则就是一个函数表达式。</p></blockquote><p>函数声明和函数表达式的<strong>区别</strong>：</p><p>比较下前面两个代码片段，第一个片段的 <code>foo</code> <strong>被绑定在所在的作用域中</strong>，可以通过 <code>foo()</code> 直接调用它，第二个片段中 <code>foo</code> <strong>被绑定在函数表达式自身的函数中</strong>而不是作用域中。</p><p>也就是说 <code>(function foo() {...})();</code> 作为函数表达式意味着 <code>foo</code> 只能在 <code>...</code> 所代表的位置中被访问，外部的作用域则不能。并且， <code>foo</code> 变量名被隐藏在自身意味着不会非必要地勿扰外部的作用域。</p><h3 id="匿名和具名-1">匿名和具名</h3><p>对于函数表达式中的<strong>回调参数</strong>用法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//&lt;-----这个是一个匿名函数表达式</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>这叫做<strong>匿名表达式</strong>，因为 <code>function()</code> 没有名字标识符。函数表达式可以是匿名的。而函数声明则不可以省略函数名。</p><p>总结来说匿名函数表达式的写法好处有:</p><ul><li>不污染所在作用域</li><li>写法快捷方便</li><li>风格优雅<del>(某些人不这样认为)</del></li></ul><p>缺点：</p><ul><li>匿名函数不会在栈追踪中显示出有意义的函数名，使得调试变得困难</li><li>如果没有函数名，当函数需要引用自身时只能使用已经过期的 <code>arguments.callee</code> 引用。比如在递归过程中，另一个函数需要引用自己，是在事件触发后事件监听器需要解释自身。</li><li>匿名函数省略了对于代码可读性/可理解性很重要的函数名，使得匿名函数的可读性变差</li></ul><p>对于上述第三个缺点，可以使用<strong>行内函数表达式</strong>解决：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timeoutHandler</span>(<span class="params"></span>)</span>&#123;<span class="comment">//&lt;-----这个是行内函数表达式</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="立即执行函数表达式-1">立即执行函数表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>由于函数被封装包含在一个 <code>()</code> 内，因此它是一个函数表达式，并有名字，所以是一个行内函数表达式。</p><p>第一个 <code>()</code> 是说明这个是一个函数表达式，第二个 <code>()</code> 是说明这个是立即执行的。这种函数在社区被称为 <code>IIFE</code> ( Immediately Invoked Function Expression )，代表<strong>立即执行表达式</strong>。</p><p>函数名对 <code>IIFE</code> 当然不是必须的，<code>IIFE</code> 最常用的用法是使用一个匿名函数表达式，虽然使用具名函数的 <code>IIFE</code> 不常见，但是它和匿名函数表达式有一样的效果，是一种极佳的实践方式。</p><p>传统的 <code>IIFE</code> 写法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//3</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>另一种改进的 <code>IIFE</code> 写法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//3</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>注意对比，两种写法的不同之处，第二种把第二个 <code>()</code> 放在了第一个 <code>()</code> 之中，而第一种写法则是单独放在外面。</p><p><code>IIFE</code>的高级用法：把它们当作函数调用并且传递参数进去。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//3</span></span><br><span class="line">  <span class="built_in">console</span>.log(global.a); <span class="comment">//2</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>这里是把 <code>window</code> 对象的引用传递进了函数，并且把它命名为 <code>global</code>。</p><p>这个模式的另外一个重要的应用场景是解决 <code>undefined</code> 标识符的默认值被错误覆盖导致的异常。（并不常见）</p><p>将第一个参数命名为 <code>undefined</code> ，但是在对应的位置不传入任何值，这样就能保证代码块中的 <code>undefined</code> 是真的 <code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="literal">true</span>; <span class="comment">//被错误修改的 undefined &lt;----- 这种做法非常不好！</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">undefined</span>) </span>&#123; <span class="comment">//正确的 undefined </span></span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123; <span class="comment">//这里的 undefined 是真的 undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Undefined is safe in function!"</span>); <span class="comment">//Undefined is safe in function!</span></span><br><span class="line">    <span class="comment">//----&gt; 正确的 undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//----&gt; 被污染的 undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>扩展连接：<code>undefined</code> 的介绍<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener external nofollow noreferrer">undefined</a></p></blockquote><p>最后一种 <code>IIFE</code> 的用法是倒置代码的执行顺序。</p><p>将要把运行的函数放在第二位，在 <code>IIFE</code> 执行之后当参数传进去，这种模式在 <strong>UMD</strong> (Universal Module Definition) 项目中被广泛使用。</p><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">def</span>) </span>&#123;<span class="comment">//IIFE 传递参数给 def</span></span><br><span class="line">    def(<span class="built_in">window</span>);</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">global</span>) </span>&#123;<span class="comment">//第一步传递def参数到IIFE</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//3</span></span><br><span class="line">  <span class="built_in">console</span>.log(global.a); <span class="comment">//2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>函数表达式 <code>def</code> 定义在片段的第二部分，然后当作参数( 这个参数也是叫做 <code>def</code> )被传进 <code>IIFE</code> 函数定义的第一个部分。</p><p>最后，参数 <code>def</code> 被调用，传的参数为 <code>window</code>。</p><p>可能不太好理解。没关系，看看下面的博客：</p><p><a href="https://scq000.github.io/2019/04/03/前端模块化的前世今生/" target="_blank" rel="noopener external nofollow noreferrer">前端模块化的前世今生</a></p><p><a href="https://zhuanlan.zhihu.com/p/74440468" target="_blank" rel="noopener external nofollow noreferrer">JavaScript系列之立即执行函数IIFE</a></p><p><a href="https://www.jianshu.com/p/47a2e778ef17" target="_blank" rel="noopener external nofollow noreferrer">IIFE与UMD</a></p><h3 id="块作用域">块作用域</h3><p>对于块作用域，其他语言中已经有描述，不再过多赘述，举几个例子。</p><p>例子1：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">//var i 直接声明，即忽略了外部的 i</span></span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//但是同时污染了外部的作用域</span></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">something</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> bar = foo * <span class="number">2</span>; <span class="comment">//使用的实际上还是全局的作用域</span></span><br><span class="line">  bar = something(bar);</span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p></p><p>因此，到这里，你可能觉得 JavaScript 没有对块块作用域的支持，至少上面两个例子没有显示出明显的支持。</p><p>除非你深究</p><h4 id="with">with</h4><p>在之前的博客中，我们提到过了 <code>with</code> 它是块作用域的一种形式，用 <code>with</code> 从对象中创建出的作用域<strong>仅仅在 with 声明中而非外部作用域中有效</strong>。</p><h4 id="trycatch">try/catch</h4><p>JavaScript 的 ES3 规范中规定 <code>try/catch</code> 的 <code>catch</code> 分句会创建一个块作用域，其中声明的变量仅仅在 <code>catch</code> <strong>内部有效</strong>。</p><p>例如以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="literal">undefined</span>(); <span class="comment">//执行一个非法的函数以此引起异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"here"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">//正常的执行 TypeError: undefined is not a function</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为 err 仅仅存在于 catch 语句中</span></span><br><span class="line"><span class="built_in">console</span>.console(err); <span class="comment">//错误的执行 ReferenceError: err is not defined</span></span><br></pre></td></tr></table></figure><blockquote><p>尽管这个行为已经被标准化，并且大部分的标准 JavaScript 环境所支持。但是当同一个作用域中的两个或者多个 <code>catch</code> 分句用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。</p></blockquote><h3 id="let">let</h3><p>ES6 提供了一种新的变量声明关键字 <code>let</code>，提供了除了 <code>var</code> 以外的另外一种变量声明方法。</p><p><code>let</code> 关键字可以将变量绑定到所在的任意作用域中，通常是 <code>{}</code> 的内部。</p><p>也就是说，<strong>let 为其声明的变量隐式地劫持了所在的块作用域</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function something(bar) &#123;</span><br><span class="line">  return bar;</span><br><span class="line">&#125;</span><br><span class="line">var foo &#x3D; true;</span><br><span class="line">if (foo) &#123;</span><br><span class="line">  let bar &#x3D; foo * 2;</span><br><span class="line">  bar &#x3D; something(bar);</span><br><span class="line">  console.log(bar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(bar); &#x2F;&#x2F;ReferenceError: bar is not defined</span><br></pre></td></tr></table></figure><p>在这个例子中， <code>let</code> 把变量附加到了一个已经存在的块作用域上的行为是隐式的。</p><p>下面这个例子中，使用了一个显式的绑定声明。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function something(bar) &#123;</span><br><span class="line">  return bar;</span><br><span class="line">&#125;</span><br><span class="line">var foo &#x3D; true;</span><br><span class="line">if (foo) &#123;</span><br><span class="line">  &#123; &#x2F;&#x2F;显式的绑定</span><br><span class="line">    let bar &#x3D; foo * 2;</span><br><span class="line">    bar &#x3D; something(bar);</span><br><span class="line">    console.log(bar);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(bar); &#x2F;&#x2F;ReferenceError: bar is not defined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(bar); &#x2F;&#x2F;ReferenceError: bar is not defined</span><br></pre></td></tr></table></figure><p>这样使得 let 被绑定到了 if 块中的 <code>{}</code> 中。</p><p>这样，在重构的时候，可以随意移动显式的块中的代码，而不用考虑 if 块中的代码和这个块的关系。</p><p>提升：指的是声明会被视为存在于其出现的作用域的整个范围内。但是使用 <code>let</code> 进行的声明不会在块作用域中提升。</p><p>声明的代码在被运行之前，声明并不存在。</p><p>因此考虑下面的代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">//ReferenceError: Cannot access 'bar' before initialization</span></span><br><span class="line">  <span class="keyword">let</span> bar = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">//undefined</span></span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显看来这两种变量的表现是不一致的。</p><h4 id="垃圾回收">垃圾回收</h4><p>另外一个块作用域非常有用的原因和<strong>闭包</strong>以及回收内存垃圾的回收机制有关。</p><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something interesting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------</span></span><br><span class="line"><span class="comment">//这段代码中的数据结构可能不会被回收</span></span><br><span class="line"><span class="keyword">var</span> someReallyBigData = &#123;&#125;;</span><br><span class="line">process(someReallyBigData);</span><br><span class="line"><span class="comment">//------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"my_button"</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"btn click!"</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不错的实践</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something interesting</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------</span></span><br><span class="line"><span class="comment">//这段代码的定义会在完事之后自动销毁</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> someReallyBigData = &#123;&#125;;<span class="comment">//注意，这里使用的是let，仅仅存在于这个作用域中</span></span><br><span class="line">    process(someReallyBigData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"my_button"</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"btn click!"</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>使用下面的代码，就可以打消 <code>someReallyBigData</code> 变量可能没有被回收的忧虑啦。</p><h4 id="let-循环">let 循环</h4><p>一个 let 可以发挥优势的经典场景就是 for 循环。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">//ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><p>这个应用场景中， let i 实际上是把变量 i 绑定到了 for 循环中去。</p><p>let 声明附属于一个新的作用域而不是当前的函数作用域。</p><p>当代码中存在对于函数作用域中 var 声明的隐式依赖时，就会有很多隐藏的陷阱。</p><p>例如下面这个例子：</p><p>原来的代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>,</span><br><span class="line">  baz = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> (baz &gt; bar) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(baz);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和这段代码是等效的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>,</span><br><span class="line">  baz = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (baz &gt; bar) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(baz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是代码如果换做以下情况：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>,</span><br><span class="line">  baz = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> (baz &gt; bar) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(baz);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在重构后就会发生错误：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>,</span><br><span class="line">  baz = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (baz &gt; bar) &#123; <span class="comment">//错误 let bar 把 bar 绑定到了 let 的块中</span></span><br><span class="line">  <span class="built_in">console</span>.log(baz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，var 和 let 之间的区别有：</p><p>//todo: 待补充 let 和 var 区别</p><table><thead><tr class="header"><th>let</th><th>var</th></tr></thead><tbody><tr class="odd"><td>可以绑定到块作用域</td><td>不可以绑定到块作用域</td></tr></tbody></table><h3 id="const">const</h3><p>除了 let 以外， ES6 引入了 const，同样可以用来创建块作用域变量，但是它的值是固定的常量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; true;</span><br><span class="line"></span><br><span class="line">if (foo) &#123;</span><br><span class="line">  var a &#x3D; 2;</span><br><span class="line">  const b &#x3D; 3;</span><br><span class="line"></span><br><span class="line">  a &#x3D; 3;</span><br><span class="line">  b &#x3D; 4; &#x2F;&#x2F;error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a); &#x2F;&#x2F;a</span><br><span class="line">console.log(b); &#x2F;&#x2F;ReferenceError</span><br></pre></td></tr></table></figure><p>也就是说 const 是固定变量值版本的 let。</p><h3 id="函数作用域和块作用域小结">函数作用域和块作用域小结</h3><p>函数是 JavaScript 中最常用的作用域单元。</p><p>本质上，声明在一个函数内部的变量会被当前的函数作用域隐藏起来。</p><p>但是函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，而且也可以属于某个代码块。</p><p>从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。</p><p>在 ES6 中引入了 let 关键字，用来在任意代码中声明变量。 <code>if(...) { let a = 2;}</code> 会声明一个劫持了 if 的 <code>{...}</code> 块的变量，并且把变量添加到了这个块中。</p><p>因此这里有两种作用域可选，<strong>函数作用域</strong>和<strong>使用 let 劫持实现的块作用域</strong>。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScript</tag>
        <tag>「你不知道的 JavaScript」</tag>
      </tags>
  </entry>
  <entry>
    <title>随手记 shell 脚本其一</title>
    <url>/archives/shell0403.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h1 id="随手记-shell-脚本其一">随手记 shell 脚本其一</h1><p>本文是随手记 shell 脚本第一节。</p><a id="more"></a><h2 id="小测试描述">小测试描述</h2><p>编写shell程序，把指定目录及其子目录下的所有扩展名为 .aaa 的文件名修改为 .bbb</p><p>例如</p><p>/home/sgf目录下有如下文件</p><p>/home/sgf/test1.aaa</p><p>/home/sgf/test2.aaa</p><p><code>…</code></p><p>/home/sgf目录下有如下子目录和文件</p><p>/home/sgf/dir1/myfile1.aaa</p><p>/home/sgf/dir2/myfile2.aaa</p><p><code>…</code></p><p>如果你编写的shell为my.sh</p><p>执行情况如下</p><p><code>$my.sh /home/sgf/</code></p><p>如果目录不存在，给出错误提示</p><p>如果没有给出参数，给出错误提示</p><p>目录存在，则把上述例子里的所有 <code>*.aaa</code> 文件修改为 <code>*.bbb</code></p><h2 id="处理">处理</h2><p>首先分析，该脚本功能需要实现参数检查，即若文件路径是合法的则进行操作否则报错。其次需要指定文件目录后缀的修改，因此需要参数编程。最后，脚本能够处理子目录下的同类要求，因此脚本需要递归到子目录中。</p><p>考虑到上述三点，可以确定需要用到 shell 编程的特性有<strong>指定和检查参数</strong>、能够<strong>递归子目录</strong>和<strong>参数修改</strong>。我们先编写 3 个上述的 demo ，然后组合起来，这样思路比较清楚。</p><h3 id="参数检查">参数检查</h3><p>这里用到了两个知识点：</p><ul><li><code>$#</code> 表示参数个数</li><li><code>test [-d|-f] $变量</code> 用于当前变量是文件还是目录</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># demo 功能:读入参数对当前参数进行处理，带有错误参数输入处理提示</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ] <span class="comment"># 当前没有参数，报错</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ops,是不是忘记输入 Parameters 啦?"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -d  <span class="variable">$1</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span>  <span class="string">"<span class="variable">$1</span> 是目录,开始处理"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span>   <span class="string">"<span class="variable">$1</span> 不是一个目录,发生错误"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/adameta/img/raw/master/1585927927_20200403231834613_11904.png"></p><h3 id="递归子目录">递归子目录</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 文件名 demo2.sh</span></span><br><span class="line"><span class="comment"># demo 功能：实现递归地遍历当前目录下的文件（即遍历目录下文件和子目录下文件）</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">read_dir</span></span>()&#123;</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> `ls <span class="variable">$1</span>`</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ -d <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> ]   </span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            read_dir <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> </span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#测试目录 test</span></span><br><span class="line">read_dir <span class="variable">$1</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/adameta/img/raw/master/1585927928_20200403231855302_11578.png"></p><h3 id="进行后缀修改">进行后缀修改</h3><p>最后一步需要把当前文件的后缀从 aaa 修改为 bbb。</p><p>这里参考博客写的实例： <a href="http://zuyunfei.com/2016/03/23/Shell-Truncate-File-Extension/" target="_blank" rel="noopener external nofollow noreferrer" class="uri">http://zuyunfei.com/2016/03/23/Shell-Truncate-File-Extension/</a></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">fullfile=/the/path/foo.txt</span><br><span class="line">fullname=$(basename <span class="variable">$fullfile</span>)</span><br><span class="line">dir=$(dirname <span class="variable">$fullfile</span>)</span><br><span class="line">filename=$(<span class="built_in">echo</span> <span class="variable">$fullname</span> | cut -d . -f1)</span><br><span class="line">extension=$(<span class="built_in">echo</span> <span class="variable">$fullname</span> | cut -d . -f2)</span><br></pre></td></tr></table></figure><p>修改为我们需要的：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 文件名 demo3.sh</span></span><br><span class="line"><span class="comment"># demo 功能：当前文件的后缀从 aaa 修改为 bbb</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">change_name</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> file=<span class="variable">$1</span></span><br><span class="line">    fullname=$(basename <span class="variable">$file</span>)</span><br><span class="line">    dir=$(dirname <span class="variable">$file</span>)</span><br><span class="line">    filename=$(<span class="built_in">echo</span> <span class="variable">$fullname</span> | cut -d . -f1)</span><br><span class="line">    extension=$(<span class="built_in">echo</span> <span class="variable">$fullname</span> | cut -d . -f2)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"文件目录是<span class="variable">$dir</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"文件全名是<span class="variable">$fullname</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"文件前缀名是<span class="variable">$filename</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"文件后缀名是<span class="variable">$extension</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$dir</span> , <span class="variable">$fullname</span> , <span class="variable">$filename</span> , <span class="variable">$extension</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$extension</span> = <span class="string">"aaa"</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">local</span> src=<span class="variable">$dir</span><span class="string">"/"</span><span class="variable">$fullname</span></span><br><span class="line">        <span class="built_in">local</span> dst=<span class="variable">$dir</span><span class="string">"/"</span><span class="variable">$filename</span><span class="string">".bbb"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$src</span> ===&gt;&gt; <span class="variable">$dst</span>"</span></span><br><span class="line">        mv <span class="variable">$src</span> <span class="variable">$dst</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#测试目录 test</span></span><br><span class="line">change_name <span class="variable">$1</span></span><br></pre></td></tr></table></figure><p>在 shell 中允许用户使用 <code>$(basename $file)</code> <code>$(dirname $file)</code> 把变量分离为目录部分和文件部分。</p><p>之后用管道和 cut 把文件名字部分切开。</p><p>分别获得的是第一部分 -f1 和第二部分 -f2。</p><p>关于cut命令的解释：<a href="https://shapeshed.com/unix-cut/" target="_blank" rel="noopener external nofollow noreferrer" class="uri">https://shapeshed.com/unix-cut/</a></p><p>实现结果如下：</p><p><img src="https://gitee.com/adameta/img/raw/master/1585927928_20200403232225330_23455.png"></p><h3 id="最终实现">最终实现</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 文件名 oyxChangeFileName.sh</span></span><br><span class="line"><span class="comment"># 用于递归地将文件后缀修改（包括子目录）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">change_name</span></span>()&#123;</span><br><span class="line">    <span class="comment"># echo $1</span></span><br><span class="line">    <span class="built_in">local</span> file=<span class="variable">$1</span></span><br><span class="line">    fullname=$(basename <span class="variable">$file</span>)</span><br><span class="line">    dir=$(dirname <span class="variable">$file</span>)</span><br><span class="line">    filename=$(<span class="built_in">echo</span> <span class="variable">$fullname</span> | cut -d . -f1)</span><br><span class="line">    extension=$(<span class="built_in">echo</span> <span class="variable">$fullname</span> | cut -d . -f2)</span><br><span class="line">    <span class="comment"># echo "文件目录是$dir"</span></span><br><span class="line">    <span class="comment"># echo "文件全名是$fullname"</span></span><br><span class="line">    <span class="comment"># echo "文件前缀名是$filename"</span></span><br><span class="line">    <span class="comment"># echo "文件后缀名是$extension"</span></span><br><span class="line">    <span class="comment"># echo $dir , $fullname , $filename , $extension</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$extension</span> = <span class="string">"aaa"</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">local</span> src=<span class="variable">$dir</span><span class="string">"/"</span><span class="variable">$fullname</span></span><br><span class="line">        <span class="built_in">local</span> dst=<span class="variable">$dir</span><span class="string">"/"</span><span class="variable">$filename</span><span class="string">".bbb"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$src</span> ===&gt;&gt; <span class="variable">$dst</span>"</span></span><br><span class="line">        mv <span class="variable">$src</span> <span class="variable">$dst</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">read_dir</span></span>()&#123;</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> `ls <span class="variable">$1</span>`</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ -d <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            read_dir <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> <span class="comment">#是目录递归到目录</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment"># echo $1"/"$file #是文件，进行处理</span></span><br><span class="line">            change_name <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ] <span class="comment"># 当前没有参数，报错</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"ops,是不是忘记输入参数啦?"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">test</span> -d  <span class="variable">$1</span> <span class="comment"># 当前$1是目录开始处理</span></span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            <span class="comment"># echo "$1 是目录,开始处理"</span></span><br><span class="line">            read_dir <span class="variable">$1</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"Done!"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span> 不是一个目录,请重新输入~"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line">main <span class="variable">$1</span></span><br></pre></td></tr></table></figure><h3 id="测试">测试</h3><p>首先配置测试的环境，创建一个实验目录名字为 linuxLab，并且在该目录下创建文件file1.aaa和file2.aaa以及目录 dir1、dir2，如下图：</p><p><img src="https://gitee.com/adameta/img/raw/master/1585927928_20200403232334849_3668.png"></p><p>对脚本 oyxChangeFileName 文件测试：</p><p><strong>测试1：</strong></p><p>不输入参数</p><p><img src="https://gitee.com/adameta/img/raw/master/1585927929_20200403232427458_8514.png"></p><p><strong>测试2：</strong></p><p>输入的参数是文件而不是目录</p><p><img src="https://gitee.com/adameta/img/raw/master/1585927929_20200403232447513_20034.png"></p><p><strong>测试3：</strong></p><p>输入一个正确的目录（绝对路径）</p><p><img src="https://gitee.com/adameta/img/raw/master/1585927929_20200403232530075_8472.png"></p><p><img src="https://gitee.com/adameta/img/raw/master/1585927929_20200403232538785_14725.png"></p><h2 id="小结">小结</h2><p>动手实现 shell 脚本充满乐趣！</p><p>但是看到<a href="https://www.jb51.net/article/96945.htm" target="_blank" rel="noopener external nofollow noreferrer">其他实现</a>的代码之后，自己的脚本真的是<strong>又啰嗦又低效</strong>。</p><p><img src="https://gitee.com/adameta/img/raw/master/1585927930_20200403232718304_8730.png"></p><p>综上所述，写 shell 脚本还是需要多加练习，这样才能写出简洁高效的代码。（悲</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>随手记</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>线性DP优化-方格取数</title>
    <url>/archives/acw1027.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:46 GMT+0800 (GMT+08:00) --><h1 id="线性dp优化方格取数">线性DP优化「方格取数」</h1><p>题目传送门 <a href="https://www.acwing.com/problem/content/1029/" target="_blank" rel="noopener external nofollow noreferrer">「1027. 方格取数」</a></p><p>题目大意：</p><p>给定一个矩阵，矩阵填写着正数，从左上角 (1,1) 走到右下角 (n,n) 所需的代价定义为经过的数字的和。</p><p>问从 (1,1) 走到 (n,n) <strong>两次</strong>所需的代价和?</p><a id="more"></a><h2 id="朴素线性dp做法">朴素线性DP做法</h2><p>若只跑一次则状态有两个 <code>[i][j]</code> 表示当前的位置。</p><p>若考虑两次求值，则有四个状态，分别为 <code>[i1][j1][i2][j2]</code>。</p><p>那么考虑如下状态转移：</p><p><img src="https://gitee.com/adameta/img/raw/master/1585848459_20200403000907363_2426.png"></p><p>注意到本题中说明第一次到达之后会抹除掉当前的数值，因此，如果当前的节点 <span class="math inline">\(i_1=i_2\)</span> 并且 <span class="math inline">\(j_1=j_2\)</span> ，即说明当前的节点有重合。</p><p>此时仅需要加一次数值即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> row, col, val;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; row &gt;&gt; col &gt;&gt; val, row || col || val) a[row][col] = val;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">1</span>; i1 &lt;= n; i1++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">1</span>; i2 &lt;= n; i2++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j1 = <span class="number">1</span>; j1 &lt;= n; j1++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">1</span>; j2 &lt;= n; j2++) &#123;</span><br><span class="line">          <span class="keyword">int</span> t = a[i1][j1];</span><br><span class="line">          <span class="keyword">if</span> (i1 != i2 &amp;&amp; j1 != j2) t += a[i2][j2];</span><br><span class="line">          f[i1][j1][i2][j2] = max(f[i1][j1][i2][j2], f[i1 - <span class="number">1</span>][j1][i2 - <span class="number">1</span>][j2]+t);</span><br><span class="line">          f[i1][j1][i2][j2] = max(f[i1][j1][i2][j2], f[i1 - <span class="number">1</span>][j1][i2][j2 - <span class="number">1</span>]+t);</span><br><span class="line">          f[i1][j1][i2][j2] = max(f[i1][j1][i2][j2], f[i1][j1 - <span class="number">1</span>][i2 - <span class="number">1</span>][j2]+t);</span><br><span class="line">          f[i1][j1][i2][j2] = max(f[i1][j1][i2][j2], f[i1][j1 - <span class="number">1</span>][i2][j2 - <span class="number">1</span>]+t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;f[n][n][n][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间优化">时间优化</h2><p>如何处理同一个格子不能重复备选？</p><p>排除 i1+j1 == i2+j2 的情况,只有这种情况下才可能路线重合</p><p>根据上文，若当前的第一次移动和第二次移动有重合。</p><p><strong>重合时必有</strong>：</p><p><span class="math display">\[ i_1=i_2 \]</span> <span class="math display">\[ j_1=j_2 \]</span> <span class="math display">\[ i_1+j_1=i_2+j_2 \]</span></p><p>因此，设 <span class="math inline">\(k=i_1+j_1=i_2+j_2\)</span> 。 此时枚举 <span class="math inline">\(i_1\)</span> <span class="math inline">\(i_2\)</span> 和 <span class="math inline">\(k\)</span> 即可。</p><p>我们期望找到重合在 <code>[n][n]</code> 上的两条线路的值最大。（<strong>此时必定有</strong> <span class="math inline">\(i_1+j_1=i_2+j_2\)</span> ）</p><p>因此，综上所述，选择从小到达枚举 <span class="math inline">\(k\)</span> <span class="math inline">\(i_1\)</span> <span class="math inline">\(i_2\)</span>。</p><p>状态表示如下：</p><p><img src="https://gitee.com/adameta/img/raw/master/1585848460_20200403012729638_20437.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn * <span class="number">2</span>][maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> row, col, val;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; row &gt;&gt; col &gt;&gt; val, row || col || val) a[row][col] = val;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= n + n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">1</span>; i1 &lt;= n; i1++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">1</span>; i2 &lt;= n; i2++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j1 = k - i1, j2 = k - i2;</span><br><span class="line">        <span class="keyword">if</span> (j1 &gt;= <span class="number">1</span> &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= <span class="number">1</span> &amp;&amp; j2 &lt;= n) &#123;</span><br><span class="line">          <span class="keyword">int</span> t = a[i1][j1];</span><br><span class="line">          <span class="keyword">if</span> (i1 != i2) t += a[i2][j2];  <span class="comment">//没有重合 即加 a[i1][j1] 和</span></span><br><span class="line">          a[i2][j2]</span><br><span class="line">          <span class="comment">//两条路的 4 种情况</span></span><br><span class="line">          f[k][i1][i2] = max(f[k][i1][i2], f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2 - <span class="number">1</span>] + t);</span><br><span class="line">          f[k][i1][i2] = max(f[k][i1][i2], f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2] + t);</span><br><span class="line">          f[k][i1][i2] = max(f[k][i1][i2], f[k - <span class="number">1</span>][i1][i2 - <span class="number">1</span>] + t);</span><br><span class="line">          f[k][i1][i2] = max(f[k][i1][i2], f[k - <span class="number">1</span>][i1][i2] + t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[n + n][n][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
        <category>线性DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 词法作用域</title>
    <url>/archives/js0327.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:46 GMT+0800 (GMT+08:00) --><h2 id="词法作用域">词法作用域</h2><h3 id="词法阶段">词法阶段</h3><p>作用域有两种工作类型，一种是<strong>动态作用域</strong>（大多为脚本语言），一种是<strong>静态作用域</strong>。</p><p>在编译过程的词法阶段，是识别和解析单词的过程。</p><p>在词法阶段所产生的作用域叫做词法作用域。</p><a id="more"></a><p>而词法作用域是和<strong>块</strong>有关。</p><p>考虑以下代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( a, b, c );</span><br><span class="line">    &#125;</span><br><span class="line">    bar( b * <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure><p>有 3 个块作用域，分别是全局作用域，foo() 作用域和 bar() 作用域。</p><p>并且他们是<strong>逐级严格包含</strong>的。</p><p>而在查找的过程中，是采用从<strong>当前的执行代码所在块</strong>开始，逐级向外查找，直到找到匹配的标识符时停止，这就是<strong>遮蔽效应</strong>。</p><p>而当某个对象处于外层，但是内层也存在同名的变量时，想要访问外层变量该怎么做呢？</p><p>答案是使用<strong>全局对象 dot 变量名</strong>的方式。</p><p>例如当前作用域有一个变量为 a ，全局也有一个变量 a ，想要访问全局的 a 时，考虑使用 <code>window.a</code>。（ window 是全局对象 ）</p><p>这样的技术就可以任意访问任何作用域的变量了。</p><p>重点：无论函数在<strong>哪里</strong>被调用以及<strong>如何</strong>调用，函数的词法作用域都<strong>只由</strong>函数被声明时所处的位置决定。</p><h3 id="欺骗词法">欺骗词法</h3><p>在 JavaScript 中有两种主要的方法可以来欺骗词法作用域。</p><blockquote><p>欺骗词法作用域会导致性能下降</p></blockquote><h4 id="eval">eval</h4><p>JavaScript 中的 <code>eval(...)</code> 函数可以接受一个字符串作为参数，并且将其中的内容视为好像在书写时就存在于这个位置的代码。也就是在可以运行字符串其中的代码。</p><p>根据这个原理理解 <code>eval(...)</code> ，这样就可以在词法期间来修改环境。</p><p>在执行 eval 代码时，引擎并不知道前面的代码被动态地插入进去，并且对词法作用域进行了修改。引擎只会照常地向外查找变量。</p><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str , a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>( str );<span class="comment">//发生欺骗 相当于 var b = 3;</span></span><br><span class="line">    <span class="built_in">console</span>.log( a, b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo( <span class="string">"var b = 3;"</span>, <span class="number">1</span> );<span class="comment">//1, 3</span></span><br></pre></td></tr></table></figure><p>在这个例子中，b 的值是采用 str 字符串中的代码。</p><p>因为 <code>eval</code> 会像执行其他代码一样执行字符串参数。</p><p>所以，在上述例子中，相当于在执行语句 <code>var b = 3;</code>。在发生 b 的变量查询时就会查找到 foo 作用域内的 b 而不是全局作用域的 b 。</p><p>即发生了「欺骗」。</p><p>这样动态的执行静态的代码（例子中的赋值为 3 是静态的）并不是好的实践，比直接写静态的代码效率低</p><blockquote><p>严格模式下，eval有自己的词法作用域，也就意味着无法影响其中声明所在的语法作用域</p></blockquote><p>在实际场景中，少使用动态生成代码，否则会大大影响性能。</p><h4 id="with">with</h4><p>with 通常被视作引用同意对象的多个属性快捷方式，而不需要重复引用该对象。</p><p>考虑下面代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化变量</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">obj.b = <span class="number">3</span>;</span><br><span class="line">obj.c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// with 写法</span></span><br><span class="line"><span class="keyword">with</span>(obj) &#123;</span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line">    c = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>但是 <code>with</code> 有点奇怪的特性。</p><p><code>with</code> 会创建一个新的语法作用域，并将其变量的语法作用域设置为 <strong>with 外</strong>。这样会引发一些词法作用域修改问题。</p><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span>(obj) &#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// with 内变量 a 的作用域,a 和 with所处的作用域相同</span></span><br><span class="line">  <span class="comment">// 由于对象 o2 没有 a属性</span></span><br><span class="line">  <span class="comment">// 并且 a 和 obj 都是处于 foo 函数区域中</span></span><br><span class="line">  <span class="comment">// 因此导致 a 的下一次寻找会到全局作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">  b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo(o1);</span><br><span class="line"><span class="built_in">console</span>.log(o1.a);</span><br><span class="line"></span><br><span class="line">foo(o2);</span><br><span class="line"><span class="built_in">console</span>.log(o2.a);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//2 -&gt; 发生了作用域泄露</span></span><br></pre></td></tr></table></figure><p>当执行 <code>foo(o2)</code> 时，发现传进当前创建的 with 词法作用域中没有 a 变量，于是向外寻找到全局作用域，发现也没有。</p><p>因此，在<strong>全局作用域</strong>就地创建了一个变量 a ，导致变量外泄，而不是让 a 乖乖地保存在 o2 对象中。</p><p><del>（根本原因是产生了新的作用域 with ，并且把新的变量放在和自己所在的作用域相同的位置，而不是在 o2 作用域<strong>内</strong>就地修改）</del></p><p>with 本质上是通过把一个对象的引用当作作用域来处理，将对象的属性当作作用域的标识符来处理，从而创建了一个新的词法作用域。</p><h4 id="性能问题">性能问题</h4><p>eval 和 with 这些使得作用域动态改变的做法都应该制止！会使得代码的运行变得很慢（因为是动态的，所以优化起来很棘手，具有不确定性）</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScript</tag>
        <tag>「你不知道的 JavaScript」</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 作用域</title>
    <url>/archives/js0326.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:46 GMT+0800 (GMT+08:00) --><h2 id="作用域">作用域</h2><p>本文是由「你不知道的JavaScript」整理得的读书笔记。</p><h3 id="编译原理">编译原理</h3><p>JavaScript 的编译过程经过了</p><ol type="1"><li>词法分析</li><li>语法分析</li><li>代码生成</li></ol><p>三个阶段。</p><p>JavaScript 是一门动态语言，同时也是一门编译语言，和其他语言不同的是 JavaScript 不是<strong>提前</strong>编译的，而是即时编译，即在引擎执行代码之前时立即编译，编译的结果不可以在不同机器之间移植。</p><a id="more"></a><h3 id="作用域-1">作用域</h3><p>首先先明确编译过程中的参与者：</p><ul><li>引擎，从头到尾复杂 JavaScript 程序的编译和执行过程。</li><li>编译器，负责语法分析和代码生成。</li><li>作用域，负责收集和维护所有声明的标识符组成的一些列查询，以此确定标识符的访问权限。</li></ul><p>引入一段代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>该代码在引擎处理时，被认为是两个完全不同的声明，一个是由编译器编译的时候处理，另一个是在引擎运行时处理。</p><p>编译器处理该段代码的方式：</p><ol type="1"><li>遇到 var a，编译器会发出询问，当前作用域是否有一个该名称的变量，若是，则忽略声明继续编译。否则在当前的作用域中申请一个新的变量命名为 a 。</li><li>编译器生成引擎运行时所需的代码，该代码是用来处理 a = 2 这个赋值操作。会采用作用域查找机制寻找是否有一个变量 a 。</li><li>执行动作。<ol type="1"><li>若找到，则使用这个变量，将值 2 赋予它。</li><li>否则想引擎抛出异常。</li></ol></li></ol><h3 id="作用域查询">作用域查询</h3><p>上文提到，在声明过程中，会对变量进行以一次作用域查询，查找 a 是否已经在作用域中出现过。</p><p>关于作用域查询，这里进一步说明。</p><p>作用域查询分为两种：</p><ul><li>LHS 查询</li><li>RHS 查询</li></ul><p>很直观的，对于一段赋值语句，可以理解为。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = b;</span><br></pre></td></tr></table></figure><ul><li>对赋值操作 <code>=</code> 左边的变量 a <strong>容器</strong>的查询叫 LHS 查询（ Left Hand Side ）</li><li>对赋值操作 <code>=</code> 右边的变量的<strong>值</strong>的查询 b 叫 RHS 查询（ Right Hand Side ）</li></ul><p>其中值得注意的是，和正常的理解不一样，不能把函数当作一个变量，在引擎处理函数的时候并不会为函数分配容器，因此对于函数的调用实际上是一个 RHS 查询，如果调用的不是函数类型的值则会引发错误。</p><p>看书中给出的以下例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure><p>其中的 LHS 查询有:</p><ul><li>a=2 //隐式</li><li>var b</li><li>var c</li></ul><p>RHS 查询有：</p><ul><li>foo( ... )</li><li>b = a</li><li>a ...</li><li>...b</li></ul><p>这样变量之间的赋值操作实质上就是在交替地做 LHS 和 RHS 查询。</p><h3 id="作用域嵌套">作用域嵌套</h3><p>作用域是一套用于管理变量的一套规则。</p><p>当块或者函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套。</p><p>而根据我们的一般经验，一个变量在当前的作用域找不到时，就应该到外层的作用域中寻找。直到找到该变量。</p><p>比如下面的例子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>在执行的过程中并不会报错（如果换做是 cpp 就会发生找不到变量的错误）。</p><p>这是因为 JavaScript 独特的作用域管理机制。</p><p>JavaScript 的作用域链规则：当引擎当前的执行作用域开始查找该变量，如果没有找到，就继续向外（上一层）寻找。当到达全局作用域时，即停止。（没有找到即报错）</p><p>因此，可以把作用域可视化为：</p><p><img src="https://gitee.com/adameta/img/raw/master/1585227489_20200326203324947_4431.png"></p><p>在每次进行 LHS 和 RHS 查询时，都是在当前的作用域查询，若没有查询到，就会向外进行跨越到更大的作用域。</p><h3 id="异常">异常</h3><p>对于上文引入的两种查询的意义？</p><p>在 JavaScript 的宽松/懒惰模式下，若进行的是 LHS 查询，如果一直到全局作用域也无法找到变量，那么引擎就会为其在<strong>全局作用域</strong>创造一个该变量。</p><p>如果是在严格模式下，若到全局作用域也无法找到，则是抛出一个 <code>ReferenceError</code> 异常。</p><p>而在进行 RHS 查询成功之后，若对得到的值进行非法操作，比如：对非函数值进行函数调用操作（例如 a 是一个变量，但是使用 a() 对其调用）就会抛出一个 <code>TypeError</code> 异常。</p><p>两种异常的总结：</p><ul><li><code>ReferenceError</code> 异常是与作用域判别失败有关</li><li><code>TypeError</code> 异常是在作用域判别正确之后，进行了非法的操作</li></ul><h3 id="作用域小结">作用域小结</h3><p>作用域是一套用于查找变量的位置的规则。</p><p>如果查找的目标是要对其进行赋值操作，那就是 LHS 查询。</p><p>如果查找的目标的值，那么就是 RHS 查询。</p><p>尤其需要注意，函数的形式参数的传递是涉及到隐式的赋值操作的。</p><p>在 JavaScript 中，对语句 <code>var a = 2</code> 这样的声明实际是被拆分为两个部分。</p><ul><li>一个部分是 <code>var a</code> ，发生在代码执行前，用于申明该作用域下的变量 a</li><li>之后是 <code>a = 2</code> ，发生在运行时，动作是对 a 做 LHS 查询，并且把 2 赋值给 a</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScript</tag>
        <tag>「你不知道的 JavaScript」</tag>
      </tags>
  </entry>
  <entry>
    <title>背包入门</title>
    <url>/archives/extra03251.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h1 id="背包">背包</h1><p>给出背包入门题以及代码。</p><a id="more"></a><h2 id="背包-1">01背包</h2><p>给定<span class="math inline">\(N\)</span>个物品和容量是<span class="math inline">\(V\)</span>的背包，以及N个物体的<span class="math inline">\(v_i\)</span>和<span class="math inline">\(w_i\)</span>，每个物体只有一件。</p><p>挑选一些物体，使得总体积小于等于V，目标是使得总价值最大，问最大价值是多少？</p><p><img src="https://gitee.com/adameta/img/raw/master/1582739291_20200226204804550_31266.png"></p><p>模板：<a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener external nofollow noreferrer">01背包</a></p><h3 id="朴素写法">朴素写法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> v[maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &lt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = max(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[n][V];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滚动数组优化空间">滚动数组优化空间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> v[maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">    for (int j = V; j &lt;= 0; j--) &#123;</span></span><br><span class="line"><span class="comment">      f[i][j] = f[i - 1][j];</span></span><br><span class="line"><span class="comment">      if (j &gt;= v[i]) f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v[i]; j--) f[j] = max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[V];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包">完全背包</h2><p>给定<span class="math inline">\(N\)</span>个物品和容量是<span class="math inline">\(V\)</span>的背包，以及N个物体的<span class="math inline">\(v_i\)</span>和<span class="math inline">\(w_i\)</span>。每个物体有无限多件。</p><p>挑选一些物体，使得总体积小于等于<span class="math inline">\(V\)</span>，目标是使得总价值最大，问最大价值是多少？</p><p><img src="https://gitee.com/adameta/img/raw/master/1582739315_20200226214542240_9580.png"></p><h3 id="朴素写法-1">朴素写法</h3><p>暴力做法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k++)</span><br><span class="line">        f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - v[i] * k] + w[i] * k);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="时间优化">时间优化</h3><p>在枚举<span class="math inline">\(k\)</span>时做时间优化。</p><p>因为在对k进行枚举时有： <span class="math inline">\(f[i][j]=max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v]+2w,...,f[i-1][j-kv]+kw)\)</span></p><p><span class="math inline">\(\text{1:}f[i][j]=max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v]+2w,...,f[i-1][j-kv]+kw)\)</span></p><p><span class="math inline">\(\text{2:}f[i][j-v]=max( f[i-1][j-v],f[i-1][j-2v]+w,f[i-1][j-kv]+(k-1)w)\)</span></p><p>式子2中每一项都和式子1中从第二项开始的每一项<strong>相差1个w</strong>,那么就有:</p><p>完全背包的方程被<strong>优化</strong>为：<span class="math inline">\(f[i][j] = max(f[i][j-v]+w,f[i-1][j])\)</span></p><p>尤其注意以下细节：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=V; j++)&#123;<span class="comment">//正确</span></span><br><span class="line">    <span class="comment">// for(int j=V;j&gt;= v[i];j--)&#123;//错误</span></span><br><span class="line">    <span class="comment">//错误的写法，因为f[i][j-v]在f[i][j]前面</span></span><br><span class="line">    <span class="comment">//因此必须等f[i][j-v]更新之后才能更新f[i][j]</span></span><br><span class="line">      f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">      <span class="keyword">if</span>(j&gt;=v[i])  f[i][j]=max(f[i][j-v[i]]+w[i],f[i][j]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> w[maxn], v[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//------------------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment">/*时间优化-&gt;优化枚举k,因为</span></span><br><span class="line"><span class="comment">    1. f[i][j]      =max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2*v]+2*w,...,f[i-1][j-k*v]+k*w);</span></span><br><span class="line"><span class="comment">    2. f[i][j-v]   =max(            f[i-1][j-v],     f[i-1][j-2*v]+*w,...,f[i-1][j-k*v]+(k-1)*w);</span></span><br><span class="line"><span class="comment">    综合1和2 f[i][j]=max(f[i-1][j],f[i][j-v]+w); 其中v是v_i，w是w_i</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=V; j++)&#123;</span><br><span class="line">    <span class="comment">// for(int j=V;j&gt;= v[i];j--)&#123;</span></span><br><span class="line">    <span class="comment">//错误的写法，因为f[i][j-v]在f[i][j]前面</span></span><br><span class="line">    <span class="comment">//因此必须等f[i][j-v]更新之后才能更新f[i][j]</span></span><br><span class="line">      f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">      <span class="keyword">if</span>(j&gt;=v[i])  f[i][j]=max(f[i][j-v[i]]+w[i],f[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//滚动数组优化</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[n][V];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空间优化">空间优化</h3><p>对于上述的方程：<span class="math inline">\(f[i][j] = max(f[i][j-v]+w,f[i-1][j])\)</span></p><p>观察方程<span class="math inline">\(f[i][j]\)</span>可能是由<span class="math inline">\(f[i][j-v[i]]\)</span>转移过来，并且之前的状态一定是在上一行的前面位置。</p><p>因此，可以得知<span class="math inline">\(j-v\)</span>一定是在前面的数字情况，因此优化为1维的时候，前面的情况一定是上一个维度的。</p><p>优化空间的步骤,将阶段那一维度删除：即将i删除。</p><p>随后对代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = v[i]; j &lt;=V; j++)&#123;</span><br><span class="line">     f[j]=max(f[j-v[i]]+w[i],f[j]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="整合">整合：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> w[maxn], v[maxn];</span><br><span class="line"><span class="comment">// int f[maxn][maxn];</span></span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//朴素的完全背包</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">    for (int j = V; j &gt;= 0; j--) &#123;</span></span><br><span class="line"><span class="comment">      f[i][j] = f[i - 1][j];</span></span><br><span class="line"><span class="comment">      for (int k = 0; k * v[i] &lt;= j; k++)</span></span><br><span class="line"><span class="comment">        f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment">/*时间优化-&gt;优化枚举k,因为</span></span><br><span class="line"><span class="comment">    1. f[i][j]      =max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2*v]+2*w,...,f[i-1][j-k*v]+k*w);</span></span><br><span class="line"><span class="comment">    2. f[i][j-v]   =max(            f[i-1][j-v],     f[i-1][j-2*v]+*w,...,f[i-1][j-k*v]+(k-1)*w);</span></span><br><span class="line"><span class="comment">    综合1和2 f[i][j]=max(f[i-1][j],f[i][j-v]+w); 其中v是v_i，w是w_i</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">    for (int j = 0; j &lt;=V; j++)&#123;</span></span><br><span class="line"><span class="comment">    // for(int j=V;j&gt;= v[i];j--)&#123;</span></span><br><span class="line"><span class="comment">    //错误的写法，因为f[i][j-v]在f[i][j]前面</span></span><br><span class="line"><span class="comment">    //因此必须等f[i][j-v]更新之后才能更新f[i][j]</span></span><br><span class="line"><span class="comment">      f[i][j]=f[i-1][j];</span></span><br><span class="line"><span class="comment">      if(j&gt;=v[i])  f[i][j]=max(f[i][j-v[i]]+w[i],f[i][j]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//滚动数组优化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v[i]; j &lt;=V; j++)&#123;</span><br><span class="line">      f[j]=max(f[j-v[i]]+w[i],f[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// cout &lt;&lt; f[n][V];</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[V];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包">多重背包</h2><p>给定<span class="math inline">\(N\)</span>个物品和容量是<span class="math inline">\(V\)</span>的背包，以及N个物体的<span class="math inline">\(v_i\)</span>和<span class="math inline">\(w_i\)</span>。<strong>每个物体有<span class="math inline">\(s_i\)</span>件。</strong></p><p>挑选一些物体，使得总体积小于等于V，目标是使得总价值最大，问最大价值是多少？</p><p><img src="https://gitee.com/adameta/img/raw/master/1582739332_20200227002757507_11990.png"></p><h3 id="朴素写法-2">朴素写法</h3><p>暴力做法<span class="math inline">\(O(n^2)\)</span></p><p><a href="https://www.acwing.com/problem/content/4/" target="_blank" rel="noopener external nofollow noreferrer">暴力多重背包</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> s[maxn], v[maxn], w[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">      f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= s[i]; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= k * v[i]) &#123;</span><br><span class="line">          f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[n][V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优化时间">优化时间</h3><p>时间优化： 思路1：<strong>单调队列优化</strong>多重背包 <a href="https://zhuanlan.zhihu.com/p/47238538" target="_blank" rel="noopener external nofollow noreferrer">背包问题 (附单调队列优化多重背包)</a></p><p>思路2：<strong>倍增</strong>的思想，<strong>把多重背包转为01背包</strong>，使用二进制对<span class="math inline">\(s[i]\)</span>里面的数字范围打包：</p><p><img src="https://gitee.com/adameta/img/raw/master/1582739337_20200227005828375_30599.png"></p><p><img src="https://gitee.com/adameta/img/raw/master/1582739341_20200227012510926_23467.png"></p><p>用倍增的思想对同一物体进行打包之后物体的数目从<span class="math inline">\(S\)</span>变为了<span class="math inline">\(lgS\)</span>。因此时间复杂度由原来的<span class="math inline">\(O(NSV)\)</span>变为<span class="math inline">\(O(NV\text{lg}V)\)</span>。</p><p>建议看下『算法竞赛进阶指南』这本书上讲解倍增思想的部分。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e4</span> + <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> v[maxn], w[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//打包后的物体的编号</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*倍增的思想多多重背包打包，转为01背包*/</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt;= s) &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      <span class="comment">//将这k个物体打包成一个物体，编号为cnt</span></span><br><span class="line">      v[cnt] = a * k;</span><br><span class="line">      w[cnt] = b * k;</span><br><span class="line">      s -= k;</span><br><span class="line">      k &lt;&lt;= <span class="number">1</span>;  <span class="comment">//倍增</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s) &#123;</span><br><span class="line">      <span class="comment">//此时还剩下没有够2^&#123;k+1&#125;个的单位</span></span><br><span class="line">      <span class="comment">//单独补上为一个物体</span></span><br><span class="line">      cnt++;</span><br><span class="line">      v[cnt] = a * s;</span><br><span class="line">      w[cnt] = b * s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  n = cnt;  <span class="comment">//更新为01背包的大小</span></span><br><span class="line">  <span class="comment">//打包之后的多重背包转化为01背包</span></span><br><span class="line">  <span class="comment">//此时直接做01背包相同的操作即可</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v[i]; j--) &#123;</span><br><span class="line">      f[j] = max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组背包问题">分组背包问题</h2><p>将物品分为<span class="math inline">\(N\)</span>组，每个组有若干个物体，给定若干物体的价值<span class="math inline">\(w_i\)</span>。每组只能选一个物体（组内是互斥的）。</p><p>问有背包的价值最大是多少？</p><p><a href="https://www.acwing.com/problem/content/9/" target="_blank" rel="noopener external nofollow noreferrer">分组背包问题</a></p><p><img src="_v_images/20200227154431398_24971.png"></p><h3 id="朴素写法-3">朴素写法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//第i组的第j个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> v[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> nn;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn;</span><br><span class="line">    v[i][<span class="number">0</span>] = nn;  <span class="comment">//记录数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nn; j++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//朴素写法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= v[i][<span class="number">0</span>]; k++) &#123;</span><br><span class="line">        f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j]);</span><br><span class="line">        <span class="keyword">if</span> (j - v[i][k] &gt;= <span class="number">0</span>)</span><br><span class="line">          f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - v[i][k]] + w[i][k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[n][V] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="空间优化-1">空间优化</h3><p>滚动数组空间优化： 对于分组背包的空间优化意义不太大，因为本身存储<span class="math inline">\(v\)</span>和<span class="math inline">\(w\)</span>就已经是二维的空间花销了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//第i组的第j个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> v[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> nn;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn;</span><br><span class="line">    v[i][<span class="number">0</span>] = nn;  <span class="comment">//记录数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nn; j++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//空间优化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= v[i][<span class="number">0</span>]; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j - v[i][k] &gt;= <span class="number">0</span>)</span><br><span class="line">          f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[V] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="综合">综合</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//第i组的第j个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> v[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn][maxn];</span><br><span class="line"><span class="comment">// int f[maxn][maxn];</span></span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> nn;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn;</span><br><span class="line">    v[i][<span class="number">0</span>] = nn;  <span class="comment">//记录数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nn; j++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*朴素写法</span></span><br><span class="line"><span class="comment">  for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">    for (int j = 0; j &lt;= V; j++) &#123;</span></span><br><span class="line"><span class="comment">      for (int k = 0; k &lt;= v[i][0]; k++) &#123;</span></span><br><span class="line"><span class="comment">        f[i][j] = max(f[i][j], f[i - 1][j]);</span></span><br><span class="line"><span class="comment">        if (j - v[i][k] &gt;= 0)</span></span><br><span class="line"><span class="comment">          f[i][j] = max(f[i][j], f[i - 1][j - v[i][k]] + w[i][k]);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//空间优化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= v[i][<span class="number">0</span>]; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j - v[i][k] &gt;= <span class="number">0</span>)</span><br><span class="line">          f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1083二分答案+差分</title>
    <url>/archives/luogu1083.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h1 id="洛谷p1083-二分答案差分">洛谷P1083 二分答案+差分</h1><p>算法关键词：二分答案、差分</p><h2 id="题目描述">题目描述</h2><p>题目传送门『<a href="https://www.luogu.com.cn/problem/P1083" target="_blank" rel="noopener external nofollow noreferrer">P1083 借教室</a>』</p><p>数据范围：<span class="math inline">\(1\leq n,m\leq10^6\)</span> 题目意思：给定长度为 <span class="math inline">\(n\)</span> 的数组，和 <span class="math inline">\(m\)</span> 次询问，每次询问把数组 <span class="math inline">\([l,r]\)</span> 减去 <span class="math inline">\(d\)</span> ，问第几次询问能够使得数组能够存在小于 0 的数。</p><a id="more"></a><h2 id="朴素">朴素</h2><p>朴素做法:对当前 <span class="math inline">\(1..n\)</span> 对每个询问区间做修改(闭区间 <span class="math inline">\([l,r]\)</span> 同时减去 <span class="math inline">\(d\)</span> )，同时扫描当前区间长度 <span class="math inline">\([1,n]\)</span> 是否出现 <span class="math inline">\(a[i]\leq0\)</span> 。</p><p>不难分析时间复杂度是 <span class="math inline">\(O(nm)\)</span> ,而 <span class="math inline">\((10^6)^2&gt;&gt;10^7\)</span> 必然超时。观察数据 <span class="math inline">\(1e6\)</span> 的数据考虑 <span class="math inline">\(nlgn\)</span> 做法。</p><h2 id="二分答案和差分思想">二分答案和差分思想</h2><p>时间复杂度 <span class="math inline">\(O(\text{log}(m)*(n+m))\)</span></p><h3 id="具有二段性">具有二段性</h3><p>本题关键是如果第 <span class="math inline">\(k\)</span> 个答案是不符合要求的，那么后面的都肯定不符合要求（后面减去上一些数，肯定也是小于0的）。即答案具有二段性。</p><p>我们需要找到一个临界点，<strong>在这个临界点区间某个点下一次会被减到负数</strong>，而该点后面都是<strong>不满足的情况</strong>。</p><p>因此，我们需要实现一个函数<code>check(m)</code>，使得询问当前这个点<span class="math inline">\(m\)</span>是符合的（如果区间每一个数都是小于原来数组的那么是符合的），并且<strong>通过二分找到这个符合点的最右端点</strong> <span class="math inline">\(k\)</span> 。</p><p><img src="https://gitee.com/adameta/img/raw/master/1583338613_20200305000104121_17444.png"></p><h3 id="差分思想优化区间修改的过程">差分思想优化区间修改的过程</h3><p>再次发现，每一次再修改一个区间都是同时加上或者减去某个数，最后会询问当前这个答案m下，是否是符合的，属于离线修改区间，可以考虑使用差分思想。</p><p>方法是对于 <span class="math inline">\([l,r]\)</span> 加上<span class="math inline">\(d\)</span>实质上是对于差分数组<span class="math inline">\(p\)</span>做<span class="math inline">\(p[l]+d\)</span>,<span class="math inline">\(p[r+1]-d\)</span>。</p><p>即为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">  q[s[i]] += d[i];</span><br><span class="line">  q[t[i] + <span class="number">1</span>] -= d[i];<span class="comment">//做差分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>最后对差分数组q求前缀和：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) q[i] = q[i] + q[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>这样即可在<span class="math inline">\(O(n+m)\)</span>的时间复杂度内得到修改后的数组。<p></p><p>而暴力是需要<span class="math inline">\(O(m*n)\)</span>的时间复杂度。</p><h3 id="二分答案过程使用差分思想优化后的时间复杂度">二分答案过程使用差分思想优化后的时间复杂度</h3><p>因为总共有<span class="math inline">\(m\)</span>次询问，二分<span class="math inline">\([1,m]\)</span>区间总共是<span class="math inline">\(O(\text{log}(m))\)</span>次</p><p>而每一次是使用差分优化，差分时间复杂度是<span class="math inline">\(O(n+m)\)</span>，因此时间复杂度是<span class="math inline">\(O(\text{log}(m)*(n+m))\)</span>，综上比暴力<span class="math inline">\(O(nm)\)</span>快得多。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://www.luogu.com.cn/problem/P1083</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll q[maxn];</span><br><span class="line">ll d[maxn], s[maxn], t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="keyword">sizeof</span> q);</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>, r = idx;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">    q[s[i]] += d[i];</span><br><span class="line">    q[t[i] + <span class="number">1</span>] -= d[i];<span class="comment">//做差分</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//对差分做前缀和 得到最后m次修改之后的数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) q[i] = q[i] + q[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (q[i] &gt; a[i]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//满足分配条件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">cin</span> &gt;&gt; d[i] &gt;&gt; s[i] &gt;&gt; t[i];</span><br><span class="line">  <span class="comment">//时间复杂度O(lg(m)*(m+n))</span></span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>, r = m;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (check(mid)) &#123;  <span class="comment">//满足分配</span></span><br><span class="line">      l = mid;         <span class="comment">//试图找不满足</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r == m) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (check(r)) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; r + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//一个都不满足 此时r=1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
        <category>线性DP</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>离散化区间</title>
    <url>/archives/luogu2070.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h1 id="洛谷p2070-离散化区间">洛谷P2070 离散化区间</h1><p>『题目传送门』：<a href="https://www.luogu.com.cn/problem/P2070" target="_blank" rel="noopener external nofollow noreferrer">P2070 刷墙</a></p><p><a href="https://www.zhaohaikun.cn/2020/02/10/ti-jie-p2070-shua-qiang/" target="_blank" rel="noopener external nofollow noreferrer">『思路1 题解原链接』</a></p><a id="more"></a><h2 id="题目">题目：</h2><p>题目大意：给定<span class="math inline">\(n\)</span>个区间<span class="math inline">\([l,r]\)</span>其中区间的长度<span class="math inline">\(1\leq l,r\leq 1e^9\)</span>，要求给出区间相交数大于2的区间长度。 例如模拟给定的样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2 R</span><br><span class="line">6 L</span><br><span class="line">1 R</span><br><span class="line">8 L</span><br><span class="line">1 R</span><br><span class="line">2 R</span><br></pre></td></tr></table></figure><h2 id="思路1-思维题分情况考虑离散化对区间考虑">思路1 思维题：分情况考虑离散化（对区间考虑）</h2><p>说实话这个有点难弄清，需要细细的思考。</p><p><img src="https://gitee.com/adameta/img/raw/master/1583389332_20200305133650445_5086.png"></p><p>思路：从小到达扫描区间，维护一个可能发生重叠的区间【L,R】，在当前维护的区间的右边寻找一个区间【a[i].l,a[i].r】</p><p>使得当前的可能区间更新: 分为两种情况：（对应到图右上角的1和2）</p><ol type="1"><li>查询的区间的右端点是小于当前维护区间的右端点的，那么把【当前维护区间的左端点，当前查询区间的右端点】这一区间加入到重复区间长度计算中。并且试图在【当前查询区间的右端点，当前维护区间的右端点】寻找下一个可能的重复区间。</li><li>查询的区间的右端点是大于当前维护区间的右端点的，那么把【当前维护区间的左端点，当前维护区间的右端点】这一区间加入到重复区间长度计算中。并且试图在【当前维护区间的右端点，当前查询区间的右端点】寻找下一个可能的重复区间</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> dir;</span><br><span class="line">ll l, r;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;ll, ll&gt;&gt; alls;</span><br><span class="line">ll res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; dir;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="string">"R"</span>)</span><br><span class="line">      r = l + r;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      r = l - r;</span><br><span class="line">    ll tl, tr;</span><br><span class="line">    tl = min(l, r), tr = max(l, r);</span><br><span class="line">    alls.push_back(make_pair(tl, tr));</span><br><span class="line">    l = r;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(alls.begin(), alls.end());</span><br><span class="line">  <span class="comment">//找它区间后面左端点小于右端点并且右端点最右边的点</span></span><br><span class="line">  ll lft = alls[<span class="number">0</span>].first;</span><br><span class="line">  ll rgt = alls[<span class="number">0</span>].second;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (alls[i].second &gt; lft) &#123;  <span class="comment">//至少是有意义的区间（可能的区间至少是大于1的）</span></span><br><span class="line">      <span class="comment">//缩小左边的区间</span></span><br><span class="line">      alls[i].first = max(alls[i].first, lft);</span><br><span class="line">      <span class="comment">//【alls[i].first,alls[i].second】</span></span><br><span class="line">      <span class="comment">//【lft          ,rgt           】</span></span><br><span class="line">      <span class="keyword">if</span> (alls[i].second &gt; rgt) &#123;    <span class="comment">//比之前的右端点大全部覆盖</span></span><br><span class="line">        res += rgt - alls[i].first;  <span class="comment">//求公共区间</span></span><br><span class="line">        lft = rgt;  <span class="comment">//接下来有可能的区间是[rgt,alls[i].second]</span></span><br><span class="line">        rgt = alls[i].second;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;                                  <span class="comment">//比之前的右端点小</span></span><br><span class="line">        res += alls[i].second - alls[i].first;  <span class="comment">//求公共区间</span></span><br><span class="line">        lft = alls[i].second;  <span class="comment">//接下来可能的区间是[alls.second,rgt]</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路2离散化差分对点考虑">思路2：离散化+差分（对点考虑）</h2><p>对于一个区间【L,R】每出现一次，就相当于在<code>a[l]+=1,a[r+1]-=1;</code></p><p>那么就显而易见的，直接对区间的左右端点左修改，<span class="math inline">\(m\)</span>次查询即完成了相应的修改，最后从小到大扫描所有的区间，若进入区间左端点后当前的差分值从1变为了2即开始进入到多个区间重合的区域，从2变到1即退出重合的区域。如下图</p><p><img src="https://gitee.com/adameta/img/raw/master/1583389335_20200305141148224_18623.png"></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> dir;</span><br><span class="line">ll l, r;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; point;</span><br><span class="line">ll res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; dir;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="string">"R"</span>)</span><br><span class="line">      r = l + r;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      r = l - r;</span><br><span class="line">    ll tl, tr;</span><br><span class="line">    tl = min(l, r), tr = max(l, r);</span><br><span class="line">    point.push_back(make_pair(tl, <span class="number">1</span>));</span><br><span class="line">    point.push_back(make_pair(tr, <span class="number">-1</span>));</span><br><span class="line">    l = r;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(point.begin(), point.end());</span><br><span class="line">  <span class="keyword">int</span> old = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; point.size(); i++) &#123;</span><br><span class="line">    old = sum;</span><br><span class="line">    sum += point[i].second;</span><br><span class="line">    <span class="keyword">if</span> (old == <span class="number">1</span> &amp;&amp; sum == <span class="number">2</span>) l = point[i].first;</span><br><span class="line">    <span class="keyword">if</span> (old == <span class="number">2</span> &amp;&amp; sum == <span class="number">1</span>) res += point[i].first - l;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>离散化</category>
      </categories>
      <tags>
        <tag>离散化</tag>
        <tag>区间题</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie+贪心策略求数组最大异或对</title>
    <url>/archives/acw835.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:46 GMT+0800 (GMT+08:00) --><h1 id="trie">Trie</h1><p>Trie：高效存储和查找字符串集合的数据结构<a id="more"></a></p><figure><img src="https://gitee.com/adameta/img/raw/master/1583497809_20200211234256862_15978.png" alt="1"><figcaption>1</figcaption></figure><p>对于单词来说使用标记来注明。</p><p><strong>高效的查找前缀单词是否存在</strong></p><h2 id="模板">模板</h2><p><a href="https://www.acwing.com/problem/content/837/" target="_blank" rel="noopener external nofollow noreferrer">acwing 835</a></p><h3 id="题目">题目</h3><p>维护一个字符串集合，支持两种操作：</p><p>“I x”向集合中插入一个字符串x；</p><p>“Q x”询问一个字符串在集合中出现了多少次。</p><p>共有N个操作，输入的字符串总长度不超过 10e5，字符串仅包含小写英文字母。</p><h3 id="分析">分析</h3><p>如果使用朴素做法，那么每一次查询都需要对前<span class="math inline">\(n\)</span>个字符串求前缀匹配，而比较快速的前缀算法KMP的时间复杂度是<span class="math inline">\(O(len(n)+len(m))\)</span>。因此总的时间复杂度是<span class="math inline">\(O(n*(len(m)+len(n)))\)</span>，计算后得到是<span class="math inline">\(2*10^5*10^5\)</span>，肯定超时。</p><p>因此本题不能一次匹配一个串，而是要多个匹配，那么就想到了前缀树trie来做前缀单词匹配。</p><p>对于查询当前的单词，如果最后在trie上能够走到非空的节点，并且节点标记为终结的节点，那么该单词出现过在之前的序列中，若找到的节点是非终结节点，那么说明该单词是至少出现在之前单词的前缀中。</p><p>因此综上，对单词前缀的实时插入和查询前缀，实质是trie树所支持的基本操作。</p><ul><li>add(s) 向前缀树插入一个串</li><li>query(s) 向前缀树中查询这个串是否出现过</li></ul><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> x[maxn];</span><br><span class="line"><span class="built_in">string</span> op;</span><br><span class="line"><span class="keyword">int</span> son[maxn][<span class="number">26</span>];  <span class="comment">//存点的儿子的下标</span></span><br><span class="line"><span class="keyword">int</span> cnt[maxn];      <span class="comment">//当前点结尾的单词有出现多少次</span></span><br><span class="line"><span class="keyword">int</span> idx;            <span class="comment">//维护的数量</span></span><br><span class="line"><span class="comment">//下标是0的节点既是根节点又是空节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> str[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">    p = son[p][u];</span><br><span class="line">  &#125;</span><br><span class="line">  cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> str[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    p = son[p][u];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; op &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">"I"</span>) &#123;</span><br><span class="line">      insert(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"Q"</span>) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; query(x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="例题">例题</h2><p>在给定的N个整数<span class="math inline">\(A_1,A_2……A_N\)</span>中选出两个进行xor（异或）运算，得到的结果最大是多少？</p><p>输入格式</p><p>第一行输入一个整数N。</p><p>第二行输入N个整数 <span class="math inline">\(A_1～A_N\)</span>。</p><p>输出格式</p><p>输出一个整数表示答案。</p><p>数据范围</p><p><span class="math inline">\(1≤N≤10^5\)</span>, <span class="math inline">\(0≤A_i&lt;2^{31}\)</span></p><p>题目大意：在一个数组中求最大异或对</p><h3 id="分析-1">分析</h3><p>使用暴力做法枚举两个边界，时间复杂度是<span class="math inline">\(O(n^2)\)</span>，明显超时。</p><p>优化做法有点考验思维，直接贴出题解： 假如考虑一个数字<span class="math inline">\(a\)</span>的二进制展开是<span class="math inline">\((a_na_{n-1}....a_3a_2a_1a_0)_2\)</span>那么在和另一个数字<span class="math inline">\(b\)</span>的二进制展开<span class="math inline">\((b_nb_{n-1}....b_3b_2b_1b_0)_2\)</span>做异或操作时，考虑第<span class="math inline">\(k\)</span>位上的运算<span class="math inline">\(a_k\text{xor }b_k\)</span>可能的结果是<span class="math inline">\(1\)</span>或者<span class="math inline">\(0\)</span>，但是一定不会影响到左边或者右边的位（所以异或又被称作膜二加法或者是不进位加法）。</p><p>因此可以得出，如果想要使得当前的对是数组<span class="math inline">\(a\)</span>中异或值最大的，那么需要优先从高位到低位去考虑异或值是1的情况（贪心的思想），那么如何去实施这种贪心呢？</p><p>答案是使用<span class="math inline">\(Trie\)</span>，在当前的数字二进制展开所建立的<span class="math inline">\(Trie\)</span>上<strong>贪心</strong>地去找异或最大值。</p><p>考虑以下情况： <img src="https://gitee.com/adameta/img/raw/master/1583497864_20200306201451110_9547.png"> 对于每一个数字都使其二进制表示插到<span class="math inline">\(Trie\)</span>上，随后即为每次询问一个数K的二进制展开在这个<span class="math inline">\(Trie\)</span>上的最大异或值，因为当前的匹配中0和1组合是最大的（等于该位置上的1），因此，贪心的策略<strong>是找当前节点的非</strong>。</p><p>举个样例： <img src="https://gitee.com/adameta/img/raw/master/1583497865_20200306201842269_30518.png"></p><p>通过这样的转化，我们首先根据每一个数字的二进制展开来建立一个前缀树，之后，对每一个查询做贪心策略，都去寻找当前值的非值（期望最大化），若无法找到则选择当前节点的非，则选择当前节点（退而求其次）。</p><p>时间复杂度：最坏情况下，n个数字的二进制展开都不一致，那么对于k位数字来说总共有<span class="math inline">\(2^{32}\)</span>个节点，但是每一次匹配最多进行32次，总共有n个单词，因此时间复杂度是<span class="math inline">\(O(nk)\)</span>，简单计算得到是<span class="math inline">\(32*10^5&lt;&lt;10^7\)</span>。</p><p>其关键部分是每一次走节点的贪心策略：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxquery</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> b = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((b == <span class="number">0</span> &amp;&amp; son[p][<span class="number">1</span>]) || (b == <span class="number">1</span> &amp;&amp; son[p][<span class="number">0</span>])) &#123;</span><br><span class="line">    <span class="comment">//此时当前节点值的位存在并且和当前数字的位不同</span></span><br><span class="line">      res = res &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">      p = son[p][<span class="number">1</span> ^ b];<span class="comment">//向下走到下一个Trie节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//不存在和当前数字的位的不同的子节点，退而求其次选择和自己相同的点</span></span><br><span class="line">      res = res &lt;&lt; <span class="number">1</span> | <span class="number">0</span>;</span><br><span class="line">      p = son[p][b];<span class="comment">//向下走到下一个Trie节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> son[maxn * <span class="number">32</span>][<span class="number">2</span>], idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;  <span class="comment">// root</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> b = (x &gt;&gt; i) &amp; <span class="number">1</span>;  <span class="comment">//这个位置的数字</span></span><br><span class="line">    <span class="keyword">if</span> (!son[p][b]) son[p][b] = idx++;</span><br><span class="line">    p = son[p][b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxquery</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> b = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((b == <span class="number">0</span> &amp;&amp; son[p][<span class="number">1</span>]) || (b == <span class="number">1</span> &amp;&amp; son[p][<span class="number">0</span>])) &#123;</span><br><span class="line">      res = res &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">      p = son[p][<span class="number">1</span> ^ b];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res = res &lt;&lt; <span class="number">1</span> | <span class="number">0</span>;</span><br><span class="line">      p = son[p][b];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// bf</span></span><br><span class="line">  <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">  <span class="comment">//   for (int j = i + 1; j &lt; n; j++) &#123;</span></span><br><span class="line">  <span class="comment">//     if ((a[i] ^ a[j]) == 1033222) &#123;</span></span><br><span class="line">  <span class="comment">//       cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//因为对于^来说，把每一个数写作二进制表示后</span></span><br><span class="line">  <span class="comment">// 10010 把它填充到32位 00..10010</span></span><br><span class="line">  <span class="comment">//然后遍历每一个数字把它加入到trie上</span></span><br><span class="line">  <span class="comment">// max的数一定是期望每一位都是1</span></span><br><span class="line">  <span class="comment">//那么遍历每一个ai 期望它都走1的路线 如果1是null</span></span><br><span class="line">  <span class="comment">//就走0 这样就达到了最大</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    add(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    res = max(res, maxquery(a[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>贪心</category>
        <category>Trie</category>
      </categories>
      <tags>
        <tag>ST表</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的经典线性DP问题</title>
    <url>/archives/acw898.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h1 id="线性dp">线性DP</h1><p>线性DP是值得的是DP的转移过程可以由一种表画出，是由线性的转移过程，是最为一般的一类DP问题。 本文给出线性DP一些入门题目</p><a id="more"></a><h2 id="数字三角形">数字三角形</h2><p><a href="https://www.acwing.com/problem/content/900/" target="_blank" rel="noopener external nofollow noreferrer">898 数组三角形</a></p><p>题目大意：从起点向下或者向右下走，目标为数字和最大一条路径的长度。</p><p><img src="https://gitee.com/adameta/img/raw/master/1583590333_20200227163657918_28103.png"></p><p><img src="https://gitee.com/adameta/img/raw/master/1583590335_20200227163710213_29967.png"></p><p>思路分析过程： <img src="https://gitee.com/adameta/img/raw/master/1583590336_20200227164016195_10542.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//注意特殊处理初始转移状态</span></span><br><span class="line">  <span class="comment">/*hack data</span></span><br><span class="line"><span class="comment">    10</span></span><br><span class="line"><span class="comment">    -6</span></span><br><span class="line"><span class="comment">    -4 -5</span></span><br><span class="line"><span class="comment">    -3 7 5</span></span><br><span class="line"><span class="comment">    3 7 -2 1</span></span><br><span class="line"><span class="comment">    10 2 -6 2 -6</span></span><br><span class="line"><span class="comment">    -8 3 8 6 7 9</span></span><br><span class="line"><span class="comment">    -4 -10 0 -3 4 9 2</span></span><br><span class="line"><span class="comment">    0 5 5 5 10 -6 -5 -4</span></span><br><span class="line"><span class="comment">    -9 7 4 9 8 -5 -2 3 2</span></span><br><span class="line"><span class="comment">    -7 -4 0 -10 -8 -4 3 -5 8 9</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">      f[i][j] = max(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>]) + a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = -inf;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    res = max(res, f[n][i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长上升子序列">最长上升子序列</h2><p><a href="https://www.acwing.com/activity/content/problem/content/1003/1/" target="_blank" rel="noopener external nofollow noreferrer">最长上升子序列</a></p><p><img src="https://gitee.com/adameta/img/raw/master/1583590337_20200227204740816_13808.png"></p><h3 id="朴素做法">朴素做法</h3><p>数据的大小<span class="math inline">\(n=10^3\)</span>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="comment">// g[i]==j表示i是从j转移过来的</span></span><br><span class="line"><span class="keyword">int</span> f[maxn], g[maxn];  <span class="comment">// g数组保存的是转移的过程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> res = -inf;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] &gt; a[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i] &lt; f[j] + <span class="number">1</span>) &#123;</span><br><span class="line">          f[i] = f[j] + <span class="number">1</span>;</span><br><span class="line">          g[i] = j;  <span class="comment">//保存转移的过程</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = max(res, f[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (f[k] &lt; f[i]) k = i;  <span class="comment">//找到最后一个转移过来的数字</span></span><br><span class="line">  <span class="comment">//打印转移的顺序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = f[k]; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[k] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    k = g[k];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化做法">优化做法</h3><p>数据的大小<span class="math inline">\(n=10^5\)</span>。</p><p><a href="https://www.acwing.com/solution/AcWing/content/3783/" target="_blank" rel="noopener external nofollow noreferrer">题解1</a> <a href="https://www.acwing.com/solution/AcWing/content/6941/" target="_blank" rel="noopener external nofollow noreferrer">题解2</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// https://www.acwing.com/solution/AcWing/content/6941/</span></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">  q[<span class="number">0</span>] = -inf;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="keyword">int</span> m = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//找到比a[i]小的最大值</span></span><br><span class="line">      <span class="keyword">if</span> (q[m] &lt; a[i])</span><br><span class="line">        l = m;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        r = m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 因为此时l==r并且q[l]是表示当前小于a[i]的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    len = max(len, r + <span class="number">1</span>);<span class="comment">//更新长度 如果是增加新元素那么r==len</span></span><br><span class="line">    q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列">最长公共子序列</h2><p><img src="https://gitee.com/adameta/img/raw/master/1583590338_20200228150644922_645.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, l, r) for (int i = l; i &gt;= r; i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(s, _) memset(s, _, sizeof(s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xcfcfcfcf</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; a + <span class="number">1</span> &gt;&gt; b + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      f[i][j] = max(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编辑距离">编辑距离</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a + <span class="number">1</span> &gt;&gt; m &gt;&gt; b + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="comment">// 尝试 add  del</span></span><br><span class="line">      f[i][j] = min(f[i][j - <span class="number">1</span>] + <span class="number">1</span>, f[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// change</span></span><br><span class="line">      <span class="keyword">if</span> (a[i] != b[j])</span><br><span class="line">        f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, f[i][j]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
        <category>线性DP</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>带懒标记的线段树模板</title>
    <url>/archives/extra0325.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h1 id="带懒标记的线段树">带懒标记的线段树</h1><h2 id="性质">性质</h2><p>线段树是运用分块思想的树形结构。其主要的作用是维护<strong>区间信息</strong>的数据结构。</p><p>线段树可以在 <span class="math inline">\(O(\text{log}(n))\)</span>的时间复杂度内完成单点修改、区间修改、区间查询等操作。</p><a id="more"></a><p>值得注意的是线段树能够维护的信息需要满足<a href="https://zh.wikipedia.org/wiki/可加性" target="_blank" rel="noopener external nofollow noreferrer">可加性</a>。</p><p>即例如<span class="math inline">\(max(a,b,c)=max(max(a,b),c)=max(max(a,c),b)=max(max(b,c),a)\)</span>满足可加性，而<span class="math inline">\((a\mod b \mod c )\neq( a\mod c \mod b)\)</span>不满足可加性。</p><blockquote><p>可加性是指对于某种变换来说，特定的“加法”和该变换的顺序可颠倒而不影响结果，这样一种性质。——来自wiki百科</p></blockquote><hr><h2 id="操作">操作</h2><table><thead><tr class="header"><th>符号</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>a</td><td>原数组</td></tr><tr class="even"><td>d</td><td>线段树节点维护值</td></tr><tr class="odd"><td>lazytag</td><td>线段树节点的懒标记值</td></tr><tr class="even"><td>p</td><td>当前的节点</td></tr><tr class="odd"><td>s</td><td>查询区间的开始</td></tr><tr class="even"><td>e</td><td>查询区间的结尾</td></tr><tr class="odd"><td>l</td><td>节点区间的开始</td></tr><tr class="even"><td>r</td><td>节点区间的结尾</td></tr></tbody></table><p>一般习惯： * 建树从下标为1开始 * mid = l + r &gt;&gt; 1</p><h3 id="建立线段树">建立线段树</h3><p>以<span class="math inline">\(a=\{1,2,3\}\)</span>为例子，树的结构如下： <img src="https://gitee.com/adameta/img/raw/master/1583760077_20200309182420880_10198.png"></p><p>首先是提供的参数<code>void build(int s, int e, int p)</code>。</p><p>然后是伪代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void build(int s, int e, int p)&#123;</span><br><span class="line">    if(s &#x3D;&#x3D; e)&#123;</span><br><span class="line">    &#x2F;&#x2F;当前d[p]是叶子节点</span><br><span class="line">        d[p]&#x3D;a[p];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int m &#x3D; s + e &gt;&gt; 1;</span><br><span class="line">    build(左子树[s,m]);</span><br><span class="line">    build(左子树[m+1,e]);</span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>即为：对于一个节点，我们从根节点开始，递归的构建整个树到叶子节点，并且从叶子节点<span class="math inline">\(\text{pushup}\)</span>到根节点。</p><p>对于一个节点：</p><ul><li>若当前的节点是叶子节点，即<code>s==e</code>，那么<span class="math inline">\(d[p]\)</span>（对应区间<span class="math inline">\([s,s]\)</span>）的就是<span class="math inline">\(a[s]\)</span></li><li>若当前的节点是非叶子节点，即<code>s&lt;e</code>，那么将区间分割为两个部分即<span class="math inline">\([s,m]\)</span>(对应下标为<span class="math inline">\(p&lt;&lt;1\)</span>)和<span class="math inline">\([m+1,e]\)</span>(对应的下标为<span class="math inline">\(p&lt;&lt;1|1\)</span>),其中<span class="math inline">\(m=s+e&gt;&gt;1\)</span>，递归到左右儿子进行建树。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//[s,e]建立线段树 根为p</span></span><br><span class="line">  <span class="keyword">if</span> (s == e) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll m = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(s, m, p &lt;&lt; <span class="number">1</span>), build(m + <span class="number">1</span>, e, (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">  d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间查询">区间查询</h3><p>对于一个节点，其存储的是<span class="math inline">\([l,r]\)</span>区间内的维护的值，而对于一个区间查询<span class="math inline">\([s,e]\)</span></p><p>若有查询的区间<span class="math inline">\([s,e]\)</span><strong>完全覆盖</strong>当前的节点区间<span class="math inline">\([l,r]\)</span>，即<code>s&lt;=l &amp;&amp; r&lt;=e</code>查询的值即为<span class="math inline">\(d[p]\)</span></p><p><img src="https://gitee.com/adameta/img/raw/master/1583760080_20200309201356866_24563.png"></p><p>否则，将区间<strong>一分为二</strong>：</p><ul><li><span class="math inline">\([l,m]\)</span>左儿子对应下标为<span class="math inline">\(p&lt;&lt;1\)</span></li><li><span class="math inline">\([m+1,r]\)</span>右儿子对应的下标为<span class="math inline">\(p&lt;&lt;1|1\)</span></li></ul><p>此时递归到左右儿子子树进行查询 <img src="https://gitee.com/adameta/img/raw/master/1583760083_20200309202303370_22602.png"></p><p>如果每一次更新区间值，都会使得整个线段树向下更新到根节点。在区间更新的时候应该使用懒标记的线段树，延迟整个节点的信息更新。</p><p>带有懒标记的线段树，实际上是父节点暂时记录了下推到子节点的信息。在查询时，才将延迟更新的节点信息加载到子节点。</p><p>对于参数<span class="math inline">\(ll getsum(ll l, ll r, ll s, ll e, ll p)\)</span></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll getsum(ll l, ll r, ll s, ll e, ll p) &#123;</span><br><span class="line">    if(当前区间是叶节点) return d[p]</span><br><span class="line">    ll m &#x3D; l + r &gt;&gt; 1;</span><br><span class="line">    if(lazy[p])&#123;&#x2F;&#x2F;当前的节点是带有延迟更新的信息的</span><br><span class="line">    &#x2F;&#x2F;pushdown</span><br><span class="line">        d[p的左儿子] +&#x3D; lazy[p] * (p左儿子区间长度);</span><br><span class="line">        d[p的右儿子] +&#x3D; lazy[p] * (p右儿子区间长度);</span><br><span class="line">        lazy[p的左儿子] +&#x3D; lazy[p];</span><br><span class="line">        lazy[p的右儿子] +&#x3D; lazy[p];</span><br><span class="line">    &#125;</span><br><span class="line">    lazy[p] &#x3D; 0;&#x2F;&#x2F;还原懒惰标记</span><br><span class="line">    ll sum &#x3D; 0;&#x2F;&#x2F;查询值</span><br><span class="line">    if(左儿子存在) sum +&#x3D; getsum(l,r,左儿子区间,左儿子下标);</span><br><span class="line">    if(右儿子存在) sum +&#x3D; getsum(l,r,右儿子区间,右儿子下标);</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了将清楚流程，借用oi-wiki的图片：</p><figure><img src="https://gitee.com/adameta/img/raw/master/1583760087_20200309205136620_16905.png" alt="segt6"><figcaption>segt6</figcaption></figure><p><img src="https://gitee.com/adameta/img/raw/master/1583760088_20200309205145734_13182.png" alt="segt7"> <img src="https://gitee.com/adameta/img/raw/master/1583760091_20200309205158968_12321.png" alt="segt8"></p><figure><img src="https://gitee.com/adameta/img/raw/master/1583760093_20200309205217145_6430.png" alt="segt9"><figcaption>segt9</figcaption></figure><figure><img src="https://gitee.com/adameta/img/raw/master/1583760094_20200309205229255_8462.png" alt="segt10"><figcaption>segt10</figcaption></figure><p>此时如果当前的区间进行查询[1,1]（即为B节点）：</p><p>那么A的信息将会传递给B，这个过程即为<span class="math inline">\(pushdown\)</span>过程。 <img src="https://gitee.com/adameta/img/raw/master/1583760094_20200309205403365_7227.png" alt="segt12"></p><figure><img src="https://gitee.com/adameta/img/raw/master/1583760096_20200309205413339_11895.png" alt="segt13"><figcaption>segt13</figcaption></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(ll l, ll r, ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    [l,r]当前查询的区间</span></span><br><span class="line"><span class="comment">    [s,e]当前节点的区间</span></span><br><span class="line"><span class="comment">    p 为当前的节点编号</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; e &lt;= r) <span class="keyword">return</span> d[p];</span><br><span class="line">  ll m = (s + e) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//更新子节点和传递懒标记</span></span><br><span class="line">  <span class="keyword">if</span> (lazy[p])&#123;</span><br><span class="line">    d[p &lt;&lt; <span class="number">1</span>] += lazy[p] * (m - s + <span class="number">1</span>), d[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[p] * (e - m);</span><br><span class="line">    lazy[p &lt;&lt; <span class="number">1</span>] += lazy[p], lazy[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[p];</span><br><span class="line">  &#125;</span><br><span class="line">  lazy[p] = <span class="number">0</span>;  <span class="comment">//还原懒标记</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) sum += getsum(l, r, s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) sum += getsum(l, r, m + <span class="number">1</span>, e, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间更新">区间更新</h3><p>综上所述，区间修改（更新）过程是产生新的懒标记，而区间查询是将懒标记向下传递<span class="math inline">\(pushdown\)</span>。</p><p>函数参数<code>void update(ll l, ll r, ll c, ll s, ll e, ll p)</code></p><p>伪码描述:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll l, ll r, ll c, ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(当前的查询区间完全包裹节点) &#123;</span><br><span class="line">        d[p] += 当前节点区间长度 * 修改的值c;<span class="comment">//即把区间内的所有点都加上c,等效于这个区间加上了len*c</span></span><br><span class="line">        lazy[p] += c;<span class="comment">//区间更新的值向下传递</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lazy[p])&#123;<span class="comment">//当前的节点是带有延迟更新的信息的</span></span><br><span class="line">    <span class="comment">//pushdown(p);</span></span><br><span class="line">        d[p的左儿子] += lazy[p] * (p左儿子区间长度);</span><br><span class="line">        d[p的右儿子] += lazy[p] * (p右儿子区间长度);</span><br><span class="line">        lazy[p的左儿子] += lazy[p];</span><br><span class="line">        lazy[p的右儿子] += lazy[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(左儿子存在) update(l,r,左儿子区间,左儿子下标);</span><br><span class="line">    <span class="keyword">if</span>(右儿子存在) update(l,r,右儿子区间,右儿子下标);</span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll l, ll r, ll c, ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    带有懒标记的更新操作</span></span><br><span class="line"><span class="comment">    [l,r]当前查询的区间</span></span><br><span class="line"><span class="comment">    [s,e]当前节点的区间</span></span><br><span class="line"><span class="comment">    c维护的信息</span></span><br><span class="line"><span class="comment">    p节点位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; e &lt;= r) &#123;</span><br><span class="line">    d[p] += (e - s + <span class="number">1</span>) * c;</span><br><span class="line">    lazy[p] += c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll m = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//叶子节点不需要下放懒标记</span></span><br><span class="line">  <span class="keyword">if</span> (lazy[p]) &#123;  <span class="comment">//当前的节点懒标记可以向下传递</span></span><br><span class="line">    <span class="comment">//左儿子和右儿子更新节点信息</span></span><br><span class="line">    d[p &lt;&lt; <span class="number">1</span>] += lazy[p] * (m - s + <span class="number">1</span>), d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>] += lazy[p] * (e - m);</span><br><span class="line">    lazy[p &lt;&lt; <span class="number">1</span>] += lazy[p], lazy[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>] += lazy[p];</span><br><span class="line">    lazy[p] = <span class="number">0</span>;  <span class="comment">//消除懒标记</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) update(l, r, c, s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) update(l, r, c, m + <span class="number">1</span>, e, (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">  d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pushup">pushup</h3><p>该部分操作是递归到儿子时，回溯地影响自己的父亲节点，是自底向上的修改。</p><p>涉及的操作是<code>build</code>和<code>update</code>。</p><p>本质是更新了子节点后，重新计算父节点的信息。</p><p>操作为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p></p><h3 id="pushdown">pushdown</h3><p>该部分操作是把父亲欠下儿子的信息向下返还，用懒惰标记更新当前的维护值。</p><p>涉及的操作是<code>getsum</code>和<code>update</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (lazy[p]) &#123;  <span class="comment">//当前的节点懒标记可以向下传递</span></span><br><span class="line"><span class="comment">//左儿子和右儿子更新节点信息</span></span><br><span class="line">    d[p &lt;&lt; <span class="number">1</span>] += lazy[p] * (m - s + <span class="number">1</span>), d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>] += lazy[p] * (e - m);</span><br><span class="line">    lazy[p &lt;&lt; <span class="number">1</span>] += lazy[p], lazy[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>] += lazy[p];</span><br><span class="line">    lazy[p] = <span class="number">0</span>;  <span class="comment">//消除懒标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度">复杂度</h2><p>在<span class="math inline">\(O(\text{log}(n))\)</span>的时间复杂度内完成单点修改、区间修改、区间查询等操作</p><p>空间复杂度较高，上限是<span class="math inline">\(O(9*n)\)</span>（在默认开4倍的空间的情况下，注意！在1e5容易爆）</p><p>空间的复杂度上限为<span class="math inline">\(O(2^{\lceil{\text{log}(n)+1} \rceil })\)</span>，但是实际竞赛中一般取<span class="math inline">\(4*\text{maxn}\)</span>。</p><h2 id="模板">模板</h2><p><a href="https://www.luogu.com.cn/problem/P3372" target="_blank" rel="noopener external nofollow noreferrer">P3372洛谷 线段树模板1</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx = (<span class="keyword">int</span>)<span class="built_in">ceil</span>(<span class="built_in">log</span>(<span class="number">1e5</span>+<span class="number">10</span>)/<span class="built_in">log</span>(<span class="number">2</span>))*<span class="number">1.2</span>;<span class="comment">//270000</span></span><br><span class="line"><span class="comment">/*a是原数组,d是线段树维护的信息,b是懒标记*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 懒标记b&gt;0说明当前的节点欠儿子某些信息</span></span><br><span class="line"><span class="comment">pushdown在更新懒标记节点的时候，还要向下传递</span></span><br><span class="line"><span class="comment">更新其儿子的懒标记信息</span></span><br><span class="line"><span class="comment">2. 同时也更新儿子维护的信息d（信息的一半）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 262144 == 1 &lt;&lt; ((int)ceil(log(1e5 + 10) / log(2)) + 1);</span></span><br><span class="line">ll a[maxn], d[<span class="number">262144</span>], lazy[<span class="number">262144</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//[s,e]建立线段树 根为p</span></span><br><span class="line">  <span class="keyword">if</span> (s == e) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll m = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(s, m, p &lt;&lt; <span class="number">1</span>), build(m + <span class="number">1</span>, e, (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">  d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(ll l, ll r, ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    [l,r]当前查询的区间</span></span><br><span class="line"><span class="comment">    [s,e]当前节点的区间</span></span><br><span class="line"><span class="comment">    p 为当前的节点编号</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; e &lt;= r) <span class="keyword">return</span> d[p];</span><br><span class="line">  ll m = (s + e) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//更新子节点和传递懒标记</span></span><br><span class="line">  <span class="keyword">if</span> (lazy[p])</span><br><span class="line">    d[p &lt;&lt; <span class="number">1</span>] += lazy[p] * (m - s + <span class="number">1</span>), d[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[p] * (e - m),</span><br><span class="line">        lazy[p &lt;&lt; <span class="number">1</span>] += lazy[p], lazy[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[p];</span><br><span class="line">  lazy[p] = <span class="number">0</span>;  <span class="comment">//还原懒标记</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) sum += getsum(l, r, s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) sum += getsum(l, r, m + <span class="number">1</span>, e, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll l, ll r, ll c, ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    带有懒标记的更新操作</span></span><br><span class="line"><span class="comment">    [l,r]当前查询的区间</span></span><br><span class="line"><span class="comment">    [s,e]当前节点的区间</span></span><br><span class="line"><span class="comment">    c维护的信息</span></span><br><span class="line"><span class="comment">    p节点位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; e &lt;= r) &#123;</span><br><span class="line">    d[p] += (e - s + <span class="number">1</span>) * c;</span><br><span class="line">    lazy[p] += c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll m = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//叶子节点不需要下放懒标记</span></span><br><span class="line">  <span class="keyword">if</span> (lazy[p]) &#123;  <span class="comment">//当前的节点懒标记可以向下传递</span></span><br><span class="line">    <span class="comment">//左儿子和右儿子更新节点信息</span></span><br><span class="line">    d[p &lt;&lt; <span class="number">1</span>] += lazy[p] * (m - s + <span class="number">1</span>), d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>] += lazy[p] * (e - m);</span><br><span class="line">    lazy[p &lt;&lt; <span class="number">1</span>] += lazy[p], lazy[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>] += lazy[p];</span><br><span class="line">    lazy[p] = <span class="number">0</span>;  <span class="comment">//消除懒标记</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) update(l, r, c, s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) update(l, r, c, m + <span class="number">1</span>, e, (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">  d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ll n, q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">  ll a, b, c, d;</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; getsum(b, c, <span class="number">1</span>, n, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">      update(b, c, d, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll a[maxn], lazy[<span class="number">300000</span>], d[<span class="number">300000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(ll p)</span> </span>&#123; d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(ll p, ll s, ll m, ll e)</span> </span>&#123;</span><br><span class="line">  d[p &lt;&lt; <span class="number">1</span>] += lazy[p] * (m - s + <span class="number">1</span>);</span><br><span class="line">  d[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[p] * (e - m);</span><br><span class="line">  lazy[p &lt;&lt; <span class="number">1</span>] += lazy[p];</span><br><span class="line">  lazy[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[p];</span><br><span class="line">  lazy[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == e) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll m = s + e &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  build(m + <span class="number">1</span>, e, (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">  pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(ll l, ll r, ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; r &gt;= e) <span class="keyword">return</span> d[p];</span><br><span class="line">  ll m = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (lazy[p]) &#123;</span><br><span class="line">    pushdown(p, s, m, e);</span><br><span class="line">  &#125;</span><br><span class="line">  ll sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) sum += getsum(l, r, s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) sum += getsum(l, r, m + <span class="number">1</span>, e, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll l, ll r, ll s, ll e, ll c, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; r &gt;= e) &#123;</span><br><span class="line">    d[p] += (e - s + <span class="number">1</span>) * c;</span><br><span class="line">    lazy[p] += c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll m = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (lazy[p]) &#123;</span><br><span class="line">    pushdown(p, s, m, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) update(l, r, s, m, c, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (m &lt; r) update(l, r, m + <span class="number">1</span>, e, c, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">  pushup(p);</span><br><span class="line">&#125;</span><br><span class="line">ll m, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">  ll a, b, c, d;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">//查询bc</span></span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; getsum(b, c, <span class="number">1</span>, n, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">      update(b, c, <span class="number">1</span>, n, d, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列实现滑动窗口</title>
    <url>/archives/acw154.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h1 id="单调队列实现滑动窗口">单调队列实现滑动窗口</h1><p>单调队列和单调栈都有一个共同的思路，删去一些无用的元素，使得整个数据结构有序。</p><p>关键：单调队列的实现是使用双端队列来实现的，使用<strong>pop_back</strong>让队尾不符合序列序的弹出，并且查询队头的元素。</p><p>其中单调队列是使用<strong>双端队列</strong>实现的</p><a id="more"></a><p><strong>经典应用：求滑动窗口中最大（小）值。</strong></p><p>在这个例子中，因为-3进入了窗口并且比3小，因此，发现如果-3存在于这个队列中，那么3就没有存在的必要，因此pop_back出3，同理-1也被pop_back。</p><p><img src="https://gitee.com/adameta/img/raw/master/1581376764_20200211064055964_12274.png"></p><p><a href="https://www.acwing.com/problem/content/156/" target="_blank" rel="noopener external nofollow noreferrer">滑动窗口</a></p><p>处理细节：</p><ol type="1"><li>单调队列中存储的是原数组a中的下标</li><li>单调队列是<strong>从队尾到队头</strong>是上升的还是下降的？即hh维护的是哪一个最值(上升是维护最大值)</li><li>遇到破坏单调性的a[i]时，应该把单调队列后面的元素pop_back()出来，再加入这个元素。</li></ol><p>上面所描述的第三点具体到图片为：</p><p><img src="https://gitee.com/adameta/img/raw/master/1583858840_20200311004712261_19991.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> q[maxn], a[maxn];</span><br><span class="line"><span class="keyword">int</span> hh, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="comment">/*性质查询：查询头元素（因为是单调的队列）</span></span><br><span class="line"><span class="comment">    滑动窗口最小值，即查找队尾到队头是从大到小的队列队头</span></span><br><span class="line"><span class="comment">    滑动窗口最大值，即查找队尾到队头是从小到大的队列队头</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">//队尾到队头是从大到小的单调队列</span></span><br><span class="line">    <span class="keyword">if</span> (tt &gt;= hh &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">    <span class="keyword">while</span> (tt &gt;= hh &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;</span><br><span class="line">    q[++tt] = i;</span><br><span class="line">    <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">//队尾到队头是从小到大的单调队列</span></span><br><span class="line">    <span class="keyword">if</span> (tt &gt;= hh &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">    <span class="keyword">while</span> (tt &gt;= hh &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;</span><br><span class="line">    q[++tt] = i;</span><br><span class="line">    <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://www.luogu.com.cn/problem/P2251" target="_blank" rel="noopener external nofollow noreferrer">P2251洛谷 滑动窗口求最小值</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P2251</span></span><br><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> hh, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tt &gt;= hh &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">    <span class="keyword">while</span> (tt &gt;= hh &amp;&amp; a[i] &lt;= a[q[tt]]) tt--;</span><br><span class="line">    q[++tt] = i;</span><br><span class="line">    <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; a[q[hh]] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>思维题</category>
        <category>单调队列</category>
        <category>滑动窗口</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组优化LIS问题</title>
    <url>/archives/luogu1020.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h1 id="树状数组优化lis问题">树状数组优化LIS问题</h1><p>LIS即为最长上升子序列问题。学习动态规划问题（DP问题）中，其中有一个知识点叫最长上升子序列（longest increasing subsequence），也可以叫最长非降序子序列。</p><p>总所周知，LIS问题有贪心解法和DP解法。 贪心时间复杂度<span class="math inline">\(O(n)\)</span>，DP时间复杂度<span class="math inline">\(O(n^2)\)</span>。</p><p>本文将不讨论贪心的解法，<del>因为一般是想不到怎么去做贪心的</del>。 实际上，在面试和比赛时候更常见的是使用DP做法（更加直观和具有一般性。</p><a id="more"></a><p>『题目传送门』：<a href="https://www.luogu.com.cn/problem/P1020" target="_blank" rel="noopener external nofollow noreferrer">洛谷P1020</a></p><p>题目简述：给出一个长度不超过100000的数列，其中的数每个是不大于50000的正整数，求这个数列的最长不降子序列（问一）以及将这个数列划分为n个不降子序列时，n的最小值（问二）。 （推导过程见<a href="https://chx2333.blog.luogu.org/p1020-dao-tan-lan-jie-dong-tai-gui-hua-or-shu-zhuang-shuo-zu" target="_blank" rel="noopener external nofollow noreferrer">Dilworth定理：偏序集的最少反链划分数等于最长链的长度</a>）</p><h2 id="dp平方复杂度">DP平方复杂度</h2><p>『题目传送门』：<a href="https://www.luogu.com.cn/problem/P1020" target="_blank" rel="noopener external nofollow noreferrer">洛谷P1020</a></p><p>因为空间是1e5,如果不优化空间开二维数组肯定空间爆炸(<span class="math inline">\(({1e5})^2\)</span>)。</p><p>使用滚动数组思想优化空间后，对于最长上升子序列的状态转移方程是<span class="math inline">\(f[i]=\text{max}(f[j])\)</span>其中 <span class="math inline">\(j&lt; i\)</span>并且<span class="math inline">\(a[j]&lt; a[i]\)</span>，值得注意的是需要把每一次状态的初始值初始化为1（因为一个数的上升子序列就是1）</p><p>相同的，对于最长不上升子序列，只需要将这个过程反过来做即可，即从后面向前面做转移，方程是<span class="math inline">\(f[i]=\max (f[j])\)</span>其中 <span class="math inline">\(i&lt; j\)</span>并且<span class="math inline">\(a[j]&lt;= a[i]\)</span>，值得注意的是i的初始状态是从n开始的（从后往前做转移）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> res1 = -inf, res2 = -inf;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a[++n])</span><br><span class="line">    ;</span><br><span class="line">  n -= <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//最长不上升子序列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt; i; j--) &#123;</span><br><span class="line">      <span class="comment">// i &lt;-j</span></span><br><span class="line">      <span class="keyword">if</span> (a[i] &gt;= a[j]) &#123;</span><br><span class="line">        f[i] = max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res1 = max(res1, f[i]);</span><br><span class="line">  <span class="comment">//最长上升子序列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &lt; a[i]) &#123;  <span class="comment">// j-&gt;i</span></span><br><span class="line">        f[i] = max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res2 = max(res2, f[i]);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; res2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组维护查询nlgn复杂度">树状数组维护查询nlgn复杂度</h2><p>『题目传送门』：<a href="https://www.luogu.com.cn/problem/P1020" target="_blank" rel="noopener external nofollow noreferrer">洛谷P1020</a></p><p>不出意外上面的写法只能过10个测试点。题目给出提示：nlgn的写法能够给出200分</p><p>那么如何达到nlgn呢？我们来分析下：</p><p>我们知道DP的时间复杂度是<strong>转移的次数x各个状态转移成本</strong>，其中转移方程的次数又叫做阶段数。</p><ul><li>首先是转移方程的次数是<span class="math inline">\(n\)</span>，这个没有办法再优化了（至少要完成每一个转移）。</li><li>然后是转移的成本，分析转移方程可知，DP的LIS做法每一次都需要查找前面元素中可转移的最大值即a[j]&lt;=a[i]中a[j]最大。这一部分可以转为<strong>有条件的在区间内搜索最大值</strong>，是一个变种的RMQ问题，即可使用ST表或者线段树或者树状数组来优化。</li></ul><p>更加具体一点，树状数组<span class="math inline">\(f\)</span>(区间范围是从<span class="math inline">\(1-&gt;max(a[i])\)</span>)。</p><p>维护的是：<strong>树状数组f[i]当前以i结尾的LIS长度的最大值。</strong>（关键是理解维护的是什么）</p><p>因此每一次转移时，我们即查询以<span class="math inline">\([1,a[i]-1]\)</span>中的最大值。（区间查询操作<code>query(a[i] - 1)</code>） 然后这个最大值+1即为当前的以<span class="math inline">\(a[i]\)</span>结尾的最大值，并且把这个最大值加入到树状数组中（插入单点操作<code>add(a[i], q + 1);</code>）</p><p><img src="https://gitee.com/adameta/img/raw/master/1583996725_20200312145222788_32144.png"></p><p>手动过一遍样例。 <img src="https://gitee.com/adameta/img/raw/master/1583996729_20200312150508058_32176.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xcfcfcfcf</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> maxn = ninf;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> res1 = -inf, res2 = -inf;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= maxn; i += lowbit(i)) f[i] = max(f[i], c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//求以小于等于x的数为结尾的最长不上升子序列的长度的最大值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= lowbit(i)) res = max(res, f[i]);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*使用树状数组f来维护信息</span></span><br><span class="line"><span class="comment">    维护的是：当前以i结尾的最大的LIS长度</span></span><br><span class="line"><span class="comment">    每次查询的时间复杂度是log(max(a[i])) 即a[i]的值域的对数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a[++n]) maxn = max(a[n], maxn);</span><br><span class="line">  n -= <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//最长不上升子序列</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  求以a[i]结尾的最大的不上升子序列的长度</span></span><br><span class="line"><span class="comment">  等效于从后向前-&gt;求a[i]结尾的最长不上升子序列</span></span><br><span class="line"><span class="comment">              1 3 4 4 5</span></span><br><span class="line"><span class="comment">  最长上升    1 3 4 5</span></span><br><span class="line"><span class="comment">  最长不上升  4 4       (从后向前看，求最长不上升)</span></span><br><span class="line"><span class="comment">  所以对于这个问题只需要维护一个树状数组即可</span></span><br><span class="line"><span class="comment">  一次从后向前做（最长不上升子序列）</span></span><br><span class="line"><span class="comment">  一次从前往后做（最长上升子序列）</span></span><br><span class="line"><span class="comment">  每次查询都是问 $以a[i]结尾目前的最长子序列的长度$</span></span><br><span class="line"><span class="comment">  即树状数组维护的是长度，并且其定义域是a[i]的值域</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> q = query(a[i]);  </span><br><span class="line">    add(a[i], q + <span class="number">1</span>);</span><br><span class="line">    res1 = max(res1, q + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);  <span class="comment">// memset一下</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//最长上升子序列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> q = query(a[i] - <span class="number">1</span>);  <span class="comment">// 找到[1,a[i]-1]中的最大值</span></span><br><span class="line">    add(a[i], q + <span class="number">1</span>);  <span class="comment">//这个最大值即是有效的转移 加入到树状数组中去</span></span><br><span class="line">    res2 = max(res2, q + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; res2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>DP</category>
        <category>线性DP</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>ST表实现RMQ</title>
    <url>/archives/luogu3865.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:46 GMT+0800 (GMT+08:00) --><h1 id="st表实现rmq">ST表实现RMQ</h1><p>什么是RMQ?</p><p>RMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。</p><p>什么是ST表？</p><p>ST 表是用于解决 可重复贡献问题 的数据结构。 除 RMQ 以外，还有其它的“可重复贡献问题”。例如“区间按位和”、“区间按位或”、“区间 GCD”，ST 表都能高效地解决。(都是可以重复贡献问题)</p><a id="more"></a><p><img src="https://gitee.com/adameta/img/raw/master/1584000763_20200312154743498_14987.png"></p><p>对于更好的解释：<a href="https://oi-wiki.org/ds/sparse-table/" target="_blank" rel="noopener external nofollow noreferrer">OI-wiki_ST表</a></p><p>用ST表实现RMQ问题？</p><p>时间复杂度：<span class="math inline">\(O(n\log n)-O(1)\)</span>，空间复杂度：<span class="math inline">\(O(n\log n)\)</span></p><hr><p>题目传送门』：<a href="https://www.luogu.com.cn/problem/P3865" target="_blank" rel="noopener external nofollow noreferrer">洛谷P3865 ST表</a></p><p>题目大意：给定 <span class="math inline">\(n\)</span> 个数，有 <span class="math inline">\(m\)</span> 个询问，对于每个询问，你需要回答区间 <span class="math inline">\([l,r]\)</span> 中的最大值。</p><p>关键思想： 令一个数组<span class="math inline">\(f(i,j)\)</span>表示区间<span class="math inline">\([i,i+2^{j}-1]\)</span>的最大值，那么显然就有<span class="math inline">\(f(i,0) = a_i\)</span>。</p><p><strong>预处理数组</strong>关键递推式： <span class="math display">\[f(i,j) =\max( f(i,j-1),f(i+2^{j-1},j-1))\]</span></p><p><strong>查询</strong>操作： 查询:对于每个询问 <span class="math inline">\([l,r]\)</span> ，把它分成两部分： <span class="math inline">\(f[l,l+2^s-1]\)</span> 与 <span class="math inline">\(f[r-2^s+1,r]\)</span> 。其中 <span class="math display">\[s=\left\lfloor\log_2(r-l+1)\right\rfloor\]</span></p><p><img src="https://gitee.com/adameta/img/raw/master/1584000766_20200312161156938_6071.png"></p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> logn = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//令go(i,j)表示区间[i,i+2^j-1]的最大值。</span></span><br><span class="line"><span class="keyword">int</span> go[maxn][logn], Logn[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Logn[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  Logn[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; maxn; i++) Logn[i] = Logn[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; go[i][<span class="number">0</span>];</span><br><span class="line">  pre();  <span class="comment">//预处理Log</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= logn; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        预处理区间</span></span><br><span class="line"><span class="comment">        把区间分为[i,j]分为[i,i+2^&#123;j-1&#125;-1] [i+2^&#123;j-1&#125;,i+2^&#123;j&#125;-1]</span></span><br><span class="line"><span class="comment">        1.即从i开始，向后跳2^&#123;j-1&#125;个点，右区间到i+2^&#123;j-1&#125;-1</span></span><br><span class="line"><span class="comment">        2.即从i+2^&#123;j-1&#125;开始，向后跳2^&#123;j-1&#125;个点，右区间到i+2^&#123;j&#125;-1</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      go[i][j] = max(go[i][j - <span class="number">1</span>], go[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">int</span> s = Logn[y - x + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      go(i,j)表示区间[i,i+2^j-1]的最大值。</span></span><br><span class="line"><span class="comment">      那么对于一对查询x,y,求[x,y]区间内的最大值</span></span><br><span class="line"><span class="comment">      对于区间长度(y - x + 1)：</span></span><br><span class="line"><span class="comment">      有 [log(y - x + 1)]_&#123;floor&#125; = s</span></span><br><span class="line"><span class="comment">      [x][s]和[y - (1 &lt;&lt; s) + 1][s]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(go[x][s], go[y - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>ST表</category>
        <category>区间题</category>
      </categories>
      <tags>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>糖果传递</title>
    <url>/archives/acw122.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h1 id="糖果传递问题">糖果传递问题</h1><h2 id="题目">题目</h2><p><a href="https://www.acwing.com/problem/content/124/" target="_blank" rel="noopener external nofollow noreferrer">『算法竞赛进阶指南』糖果传递</a> 有n个小朋友坐成一圈，每人有a[i]个糖果。 每人只能给左右两人传递糖果。 每人每次传递一个糖果代价为1。 求使所有人获得均等糖果的最小代价。</p><a id="more"></a><h2 id="思路">思路</h2><p><img src="https://gitee.com/adameta/img/raw/master/1584343110_20200316145159297_13254.png"></p><p>假设<span class="math inline">\(n\)</span>个小朋友分别有<span class="math inline">\(a_1,a_2,...,a_n\)</span>个糖果，第<span class="math inline">\(i\)</span>个小朋友给<span class="math inline">\(i-1\)</span>个小朋友<span class="math inline">\(x_i\)</span>个糖果，（<span class="math inline">\(x_i\)</span>可正可负） 那么目标就为<span class="math inline">\(\min\sum|x_i|\)</span>。 对于上述的问题转化，可以列出方程组: <span class="math inline">\(\begin{cases}a_1-x_1+x_2=\bar{a} \\ a_2-x_2+x_3=\bar{a}\\...\\ a_n-x_n+x_1=\bar{a}\end{cases}\)</span></p><p>进一步的化简为: <span class="math inline">\(\begin{cases}x_1=x_1-(n\bar{a}-a_1-a_2-...-a_n)\\x_2=x_1-((n-1)\bar{a}-a_2-a_3-...-a_n)\\...\\x_{n-1}=x_1-(2\bar{a}-a_{n+1}-a_n)\\x_n=x_1-(\bar{a}-a_n)\end{cases}\)</span></p><p>注意: 化简过程是对于第i个式子，使用第i+1到第n个式子,例如对于第n-1项来说： <span class="math inline">\(\begin{cases} a_{n-1}-x_{n-1}+x_{n}=\bar{a}\\ a_n-x_n+x_1=\bar{a}\end{cases}\)</span> 将最后一个方程的<span class="math inline">\(x_n\)</span>带入到倒数第二个方程中，把<span class="math inline">\(x_n=x_1-(\bar{a}-a_n)\)</span>带入到<span class="math inline">\(a_{n-1}-x_{n-1}+x_{n}=\bar{a}\)</span>中，得到<span class="math inline">\(x_{n-1}=x_1-(2\bar{a}-a_{n+1}-a_n)\)</span>。以此类推</p><p>令右式常数分别为<span class="math inline">\(c_1,c_2,...,c_n\)</span></p><p>可以得到目标<span class="math inline">\(\min\sum|x_i|=(|x_1-c_1|+|x_1-c_2|+...+|x_1-c_n|)\)</span>，又因为<span class="math inline">\((|x_1-c_1|+|x_1-c_2|+...+|x_1-c_n|)\)</span>等价于在数轴上找一个点<span class="math inline">\(x_1\)</span>，该点到<span class="math inline">\(c_1,c_2,...,c_n\)</span>的距离之和最小。即转化为下面问题： 在一个数轴上，有偶数个点<span class="math inline">\(c_1,c_2,...,c_n\)</span>,需要找到一个点<span class="math inline">\(x_1\)</span>使得<span class="math inline">\(x_1\)</span>到其他点的距离最小，不难证明<span class="math inline">\(x_1\)</span>为中位数（可以视作一个结论，证明见最下面）。 <img src="https://gitee.com/adameta/img/raw/master/1584343112_20200316151251991_11809.png"></p><p>最后可以总结出算法 * 求出<span class="math inline">\(a\)</span>平均数<span class="math inline">\(\bar{a}\)</span> * 求出<span class="math inline">\(c_1,c_2,...,c_n\)</span> * 求出其中的中点值<span class="math inline">\(x_1\)</span>（对c数组排序） * 计算<span class="math inline">\(|x_1-c_1|+|x_1-c_2|+...+|x_1-c_n|\)</span></p><p>其中第二个步骤求出c的数组使用了一下递推式：</p><p><span class="math inline">\(\begin{cases}c_i=c_{i+1}+\bar{a}-a_i\\c_n =\bar{a}-a_n \end{cases}\)</span></p><p>递推式<span class="math inline">\(c_i=c_{i+1}+\bar{a}-a_i\)</span>使用第<span class="math inline">\(i+1\)</span>项方程减去第<span class="math inline">\(i\)</span>项方程既可。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll n;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll abar;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i], abar += a[i];</span><br><span class="line">  abar /= n;</span><br><span class="line">  a[n] = abar - a[n];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) a[i] = a[i + <span class="number">1</span>] + abar - a[i];</span><br><span class="line">  sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">  ll p = (a[n / <span class="number">2</span>] + a[n / <span class="number">2</span> + <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    res += <span class="built_in">abs</span>(a[i] - p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他">其他</h2><p>『题目传送门』：<a href="https://www.acwing.com/problem/content/106/" target="_blank" rel="noopener external nofollow noreferrer">acwing104</a> 关于一个数轴上的序列<span class="math inline">\(c_1,c_2,...,c_n\)</span>,需要找到一个点<span class="math inline">\(x_1\)</span>使得<span class="math inline">\(x_1\)</span>到其他点的距离最小。</p><p>思路：首先对<span class="math inline">\(c\)</span>排序,使得<span class="math inline">\(c_1 &lt; c_2 &lt; ... &lt; c_n\)</span>，考虑<span class="math inline">\(c_1,c_n\)</span>，<span class="math inline">\(c_2,c_{n-1}\)</span>...,<span class="math inline">\(c_{k-1},c_k\)</span>两两配对，以<span class="math inline">\(c_1,c_n\)</span>这一对来考虑 <img src="https://gitee.com/adameta/img/raw/master/1584343976_20200316152640321_695.png"></p><p>继续扩展到4个点，（两对） <img src="https://gitee.com/adameta/img/raw/master/1584343976_20200316153020498_14966.png"></p><p>推广到<span class="math inline">\(n=k\)</span>的情况下（<span class="math inline">\(k=n/2\)</span>）同理，因此可知<span class="math inline">\(x\)</span>应该取到<span class="math inline">\(\frac{x_k+x_{k+1}}{2}\)</span>。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>贪心</category>
        <category>思维题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀表达式</title>
    <url>/archives/acw1247.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h1 id="acwing1247后缀表达式">acwing1247后缀表达式</h1><p><a href="https://www.acwing.com/problem/content/description/1249/" target="_blank" rel="noopener external nofollow noreferrer">后缀表达式</a></p><hr><p>题目大意：n+1个+ m个-加入到表达式中使得整个序列最大</p><a id="more"></a><p>分析: <strong>这个题目贪心的关键是考虑到负号的数目不是m个，而是1到m+n个</strong> 考虑系列如下： <span class="math display">\[\text{target}:\max(a_1+a_2+...+a_{i-1})-\min(b_i-b_{i+1}-...-b_n)\]</span> 其中<span class="math inline">\(\min()\)</span>中可以有负号和正号，展开式子之后得到的是其取反，因此考虑极端的状态如果所有的<span class="math inline">\(n-1\)</span>个+放在<span class="math inline">\(\min\)</span>中，<span class="math inline">\(m-1\)</span>个-放在<span class="math inline">\(\max\)</span>中，那么总共就有<span class="math inline">\(n+m\)</span>个负数。同理的，可以在确定了两个数分别作为<span class="math inline">\(a_1\)</span>和<span class="math inline">\(b_{i+1}\)</span>之后，就只需在两个数列中继续加入数字即可。</p><p>即把一个负号提出来剩余负号都在b中那么就只有一个负号 如果把一个负号提出来m-2个负号在b中那么就有2个负号 ... 以此类推从总共可以有m+n到1个负号 至少有一个加号，至少有一个负号</p><p>那么因此序列如下： <span class="math display">\[\text{target}:\max(a_1(-/+)a_2(-/+)...(-/+)a_n)-\min(b_i(-/+)b_{i+1}(-/+)...(-/+)b_n)\]</span></p><p><strong>贪心策略</strong>：为了使得<span class="math inline">\(\text{target}\)</span>最大，我们尽量把<strong>所有的负数加到右边，把正数加到左边</strong>。那么相当于取到其他的数的绝对值。 因此总的答案应该是 <span class="math inline">\(a\)</span> 排序后 <span class="math display">\[\sum_{i=2}^{n-1}\text{abs}(a[i])-a[1]+a[n]\]</span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> judge</span></span><br><span class="line">  freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m + <span class="number">1</span>; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m + <span class="number">1</span>; i++) res += a[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(a + <span class="number">1</span>, a + n + m + <span class="number">2</span>);</span><br><span class="line">  res = -a[<span class="number">1</span>] + a[n + m + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + m + <span class="number">1</span>; i++) res += <span class="built_in">abs</span>(a[i]);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>贪心</category>
        <category>思维题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>约数和</title>
    <url>/archives/acw1296.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h1 id="约数和">约数和</h1><p><a href="https://www.acwing.com/problem/content/description/1298/" target="_blank" rel="noopener external nofollow noreferrer">『聪明的燕姿』</a></p><p>题目大意：给定一个S，求出所有符合质因数分解的和为S的数x</p><p>思路：DFS、约数和公式</p><p>约数和公式</p><p><span class="math display">\[ s=(p_1^0 + p_1^1 + ... + p_1^{\alpha_1})...(p_k^0+p_k^1+...+p_k^{\alpha_k}) \]</span> 其中 <span class="math inline">\(p\)</span> 为质因子，<span class="math inline">\(\alpha\)</span> 为质因子幂次。</p><a id="more"></a><p>之后，考虑到给定当前式子和，未知为质因子和质因子幂，已知约数和<span class="math inline">\(S\)</span>。考虑到式子每一项的大小，项数应该确定在10项以内（根据式子），因此使用<code>DFS</code>搜索位置系数。</p><p>那么该如何搜索？</p><ul><li>枚举p，找到一个可能的p</li><li>枚举alpha，找到一个可能的alpha</li><li>对于枚举的一个项能被整除，则进行下一个枚举</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(u,...)</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(p: <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">11.</span>..)</span></span></span><br><span class="line"><span class="function">        fact </span>= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(alpha <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">if</span> s % fact ==<span class="number">0</span></span><br><span class="line">                    dfs(u+<span class="number">1</span>,...)</span><br></pre></td></tr></table></figure><p>考虑上面式子中枚举质因子p,因为小于S的质数共有 <span class="math inline">\(\frac{S}{logn}\)</span>个（质数基本定理），粗略估计是 1e8 的数量级。 直接枚举p是不可以接受的。</p><p>如果 alpha=1 ,则因子变为 <span class="math inline">\(S=1+p_i\)</span> 的形式，当 <span class="math inline">\(S-1\)</span> 是质数的时候成立。判定质数是 <span class="math inline">\(O(\sqrt{n})\)</span></p><p>否则 当 <span class="math inline">\(S\neq1+p_i\)</span> ：</p><p>即有两种可能：</p><p><span class="math display">\[ S = (1+p_i+p_i^2+...)(...)... \\ S = (1+p_i)(...) \]</span></p><p>对于第一种情况</p><p><span class="math display">\[ S = (1+p_i+p_i^2+...)(...) \]</span></p><p><span class="math inline">\(p_i^2 &lt; S\)</span> ，发现在项中的每一项含有 <span class="math inline">\(p^2\)</span> 的项只用枚举到平方即可。时间复杂度即第一个for只用枚举到平方小于x然后再特判第一个p即可。</p><p>而对于第二种情况 <span class="math inline">\(p_i^2 &lt; S\)</span>也是必然成立的，即枚举时若有<span class="math inline">\(p_i^2 &gt; S\)</span>则直接退出当前的枚举。即对于每一个素数枚举到<span class="math inline">\(\sqrt{S}\)</span>即可，（即当<span class="math inline">\(p_i^2&lt;S\)</span>时可以枚举）这样的话根据上面分析，最多会有10项，每一项需要枚举<span class="math inline">\(\sqrt{S}\)</span>，总共k组数据所以时间复杂度是 <span class="math inline">\(10*k\sqrt{S}\)</span>即为<span class="math inline">\(5e7\)</span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> judge</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>;</span><br><span class="line"><span class="keyword">int</span> primes[maxn], cnt, used[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!used[i]) primes[cnt++] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++) &#123;</span><br><span class="line">      used[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">last 上一个fact项的质数下标是多少</span></span><br><span class="line"><span class="comment">prod 当前代求答案数</span></span><br><span class="line"><span class="comment">s 剩余的S</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_p</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; maxn) <span class="keyword">return</span> !used[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; primes[i] &lt;= x / primes[i]; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % primes[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> prod, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">1</span>) &#123;  <span class="comment">// get a ans</span></span><br><span class="line">    ans[len++] = prod;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s - <span class="number">1</span> &gt; (last &lt; <span class="number">0</span> ? <span class="number">1</span> : primes[last]) &amp;&amp; is_p(s - <span class="number">1</span>)) &#123;  <span class="comment">//上一个质数</span></span><br><span class="line">    <span class="comment">// s-1&gt;1成立 （第一次）</span></span><br><span class="line">    <span class="comment">// s-1&gt;p_last 大于上一个质数 即还可以枚举</span></span><br><span class="line">    ans[len++] = prod * (s - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = last + <span class="number">1</span>; primes[i] &lt;= s / primes[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = primes[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> + p, t = p; j &lt;= s; t *= p, j += t) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s % j == <span class="number">0</span>) &#123;</span><br><span class="line">        dfs(i, prod * t, s / j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> judge</span></span><br><span class="line">  freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  getp(maxn - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  假设自己的号码牌上写着数字 S，</span></span><br><span class="line"><span class="comment">  那么自己等的人手上的号码牌数字的所有正约数之和必定等于 S。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法是使用约数和公式</span></span><br><span class="line"><span class="comment">    一个数的约数的和等于</span></span><br><span class="line"><span class="comment">    $$(p_1^0+p_1^1+...+p_1^\alpha_1)...(p_k^0+p_k^1+...+p_k^\alpha_k)$$</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">    len = <span class="number">0</span>;  <span class="comment">//当前搜索的长度</span></span><br><span class="line">    dfs(<span class="number">-1</span>, <span class="number">1</span>, s);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (len) &#123;</span><br><span class="line">      sort(ans, ans + len);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>因式分解</category>
        <category>搜索</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>因式分解</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>blog 改造计划</title>
    <url>/archives/blog_plan.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:46 GMT+0800 (GMT+08:00) --><p>因为 kramdown 解析器对 MathJax 有支持问题，在书写某些数学公式时常常发生奇怪的错误。 最为典型的便是 <code>$x_1+x_2$</code> 会先被 markdown 解析为斜体，之后 MathJax 就无法得到正确的公式。 为了获得更好的支持体验，在前辈<a href="https://blog.yuki-nagato.com/" target="_blank" rel="noopener external nofollow noreferrer">長門有希</a>建议下使用了更好的数学公式解析支持 <a href="https://pandoc.org/" target="_blank" rel="noopener external nofollow noreferrer">Pandoc</a>，做了相关调研后，确定使用 hexo 下的 nexT 主题，将默认的解析器更换为 hexo-renderer-pandoc。完美解决了该问题<a href="https://adameta.top/archives/mathjax_plugin.html">测试mathjax插件</a>。之后对博客做些许美化，如下：</p><p>计划将博客从 jeklly 迁移到 hexo, 版本为 7.7.2。</p><a id="more"></a><ul><li>[x] 加入了搜索功能</li><li>[x] 加入 mathjax 插件支持,能够完美解析公式</li><li>[x] 添加 categories, tag, about, links 页面</li><li>[x] 在文章末尾加入了频道订阅</li><li>[x] 加入了头像和联系方式</li><li>[x] 加入了字数统计和阅读时间提醒</li><li>[x] 解决友情链接问题</li><li>[x] 加入文章进度条</li><li>[x] 对文章连接永久化操作</li><li>[x] 修改返回文章顶部按钮</li><li>[x] 文件压缩插件，以及其他加快浏览速度</li><li>[x] 文章顶置功能</li><li>[x] 修改主页文章显示长度</li><li>[x] 加入近期文章</li><li>[x] 加入中文字体</li><li>[x] 对总体样式进行优化（边角的优化）</li><li>[x] 完善联系方式</li><li>[x] 背景图片</li><li>[x] 修改 head 图标</li><li>[x] 文章末尾添加 copyright</li><li>[x] 加入代码框阴影效果,复制功能</li><li>[x] 文章评论功能</li><li>[ ] 国内外访问速度问题（Hexo 博客部署在 GitHub Pages 上并且配置 CDN 进行加速）</li><li>[ ] 提交搜索引擎收录</li><li>[ ] 加入了夜间模式 X | 目前原生支持有bug</li><li>[ ] 阅读排行榜 (热门文章) | 待完善</li></ul><hr><p>参考连接：</p><p><a href="https://tding.top/archives/aad98408.html" target="_blank" rel="noopener external nofollow noreferrer">Hexo 搭建个人博客文章汇总</a></p><p><a href="http://lx34r.coding.me/posts/3018881965/" target="_blank" rel="noopener external nofollow noreferrer">优化个人博客(theme_next)相关</a></p><p><a href="https://tding.top/archives/29bfe8c9.html" target="_blank" rel="noopener external nofollow noreferrer">Hexo-NexT Tag 插件的使用</a></p><p><a href="https://theme-next.org/docs/theme-settings/posts" target="_blank" rel="noopener external nofollow noreferrer">NexT Theme for Hexo-Posts</a></p><p><a href="https://hexo.io/docs/front-matter" target="_blank" rel="noopener external nofollow noreferrer">Front-matter</a></p><p><a href="https://www.jianshu.com/p/78c218f9d1e7" target="_blank" rel="noopener external nofollow noreferrer">Hexo-设置阅读全文</a></p><p><a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener external nofollow noreferrer">Hexo-标签插件（Tag Plugins）</a></p><p><a href="https://tding.top/archives/42c38b10" target="_blank" rel="noopener external nofollow noreferrer">Hexo-NexT (v7.0+) 主题配置</a></p><p><a href="https://theme-next.org/docs" target="_blank" rel="noopener external nofollow noreferrer">Hexo-NexT 官方文档</a></p><p><a href="https://zhangzw.com/posts/20190830.html" target="_blank" rel="noopener external nofollow noreferrer">Hexo 给文章中英文添加空格</a></p><p><a href="https://tding.top/docs/getting-started/data-files.html" target="_blank" rel="noopener external nofollow noreferrer">数据文件</a></p><p><a href="https://memento.net.cn/post/4af0cb81.html" target="_blank" rel="noopener external nofollow noreferrer">相关文章之 hexo-related-popular-posts</a></p><p><a href="http://blog.amdoing.com/the-post-copyright-in-hexo-next/" target="_blank" rel="noopener external nofollow noreferrer">使用Hexo的next主题，配置POST文章文末的版权信息</a></p><p><a href="https://github.com/1v9/hexo-next-nightmode" target="_blank" rel="noopener external nofollow noreferrer">Hexo NexT Night Mode</a></p><p><a href="https://github.com/theme-next/hexo-theme-next/pull/1386" target="_blank" rel="noopener external nofollow noreferrer">Native Dark Mode support #1386</a></p><p><a href="https://valine.js.org/hexo.html#hexo-theme-next" target="_blank" rel="noopener external nofollow noreferrer">valine hexo-theme-next</a></p><p><a href="https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener external nofollow noreferrer">hexo-Next-主题添加评论功能</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>测试mathjax插件</title>
    <url>/archives/mathjax_plugin.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><p>用于测试 Pandoc 解析器。 给出一些测试公式<a id="more"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\frac&#123;\partial u&#125;&#123;\partial t&#125;</span><br><span class="line">&#x3D; h^2 \left( \frac&#123;\partial^2 u&#125;&#123;\partial x^2&#125; +</span><br><span class="line">\frac&#123;\partial^2 u&#125;&#123;\partial y^2&#125; +</span><br><span class="line">\frac&#123;\partial^2 u&#125;&#123;\partial z^2&#125;\right)$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[\frac{\partial u}{\partial t} = h^2 \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}\right)\]</span></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\left[</span><br><span class="line">    \begin&#123;array&#125;&#123;cc|c&#125;</span><br><span class="line">      1&amp;2&amp;3\newline</span><br><span class="line">      4&amp;5&amp;6</span><br><span class="line">    \end&#123;array&#125;</span><br><span class="line">\right] </span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[ \left[ \begin{array}{cc|c} 1&amp;2&amp;3\newline 4&amp;5&amp;6 \end{array} \right] \]</span></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">&#123;\mathcal L&#125;_&#123;cyc&#125;(G,F)&#x3D;&#123;\mathbb E&#125;_&#123;x \sim p_&#123;data&#125;(x)&#125;[&#123;\|F(G(x))-x\|&#125;_&#123;1&#125;]+&#123;\mathbb E&#125;_&#123;y \sim p_&#123;data&#125;(y)&#125;[&#123;\|G(F(y))-y\|&#125;_&#123;1&#125;]</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[ {\mathcal L}_{cyc}(G,F)={\mathbb E}_{x \sim p_{data}(x)}[{\|F(G(x))-x\|}_{1}]+{\mathbb E}_{y \sim p_{data}(y)}[{\|G(F(y))-y\|}_{1}] \]</span></p><p>测试一下功能：</p><p><span class="math display">\[e_r( x^{*} ) = \frac{x-x^*}{x^*}\]</span> <span class="math display">\[\mathop{x} \limits_a^b\]</span> <span class="math display">\[e_r( x^{*} ) = \frac{x-x^*}{x^*}\]</span> <span class="math display">\[a_x+b_x=c_x\]</span> <span class="math display">\[e\left ( x^{*} \right ) = x - x^{*}\]</span> <span class="math display">\[ \left| e \right|=\left | x-x^* \right |\leq \varepsilon \]</span> <span class="math display">\[ \min_{\mathbf{w},b} \frac{1}{2} \Vert \mathbf{w} \Vert^2 \quad s.t. \quad y_i(\mathbf{w}^T\phi(\mathbf{x})+b) \geq 1, \quad i=1,2,...,m\qquad(9) \]</span> <span class="math display">\[ e\left ( x^{*} \right ) = x - x^{*}x = a_0 + \frac{1}{a_1 +\sqrt{a^2+b^2} \frac{1}{a_2 + \frac{1}{a_3 + a_4}}}\sqrt{a^2+b^2} \]</span> <span class="math display">\[ f(n)=\begin{cases} n/2, &amp; \text{如果$ x \leqslant 2 $}\\ 3n+1, &amp; \text{如果$ x&gt;2 $} \end{cases} \]</span> <span class="math display">\[\max \limits_{a&lt;x&lt;b}\{f(x)\}\]</span> <span class="math display">\[ \beta^*(D) = \mathop{argmin} \limits_{\beta} \lambda {||\beta||}^2 + \sum_{i=1}^n max(0, 1 - y_i f_{\beta}(x_i)) \]</span></p><p><span class="math display">\[ \left(\begin{array}{c}s \\ t\end{array}\right)= \left( \begin{array}{cc} cos(b) &amp; -sin(b) \\ sin(b) &amp; cos(b) \end{array} \right) \left( \begin{array}{c} x \\ y \end{array} \right) \]</span></p><p>测试源码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$e_r( x^&#123;*&#125;  ) &#x3D; \frac&#123;x-x^*&#125;&#123;x^*&#125;$$</span><br><span class="line">$$\mathop&#123;x&#125; \limits_a^b$$</span><br><span class="line">$$e_r( x^&#123;*&#125;  ) &#x3D; \frac&#123;x-x^*&#125;&#123;x^*&#125;$$</span><br><span class="line">$$a_x+b_x&#x3D;c_x$$</span><br><span class="line">$$e\left ( x^&#123;*&#125; \right ) &#x3D; x - x^&#123;*&#125;$$</span><br><span class="line">$$</span><br><span class="line">\left| e \right|&#x3D;\left | x-x^* \right |\leq \varepsilon</span><br><span class="line">$$</span><br><span class="line">$$</span><br><span class="line">\min_&#123;\mathbf&#123;w&#125;,b&#125; \frac&#123;1&#125;&#123;2&#125; \Vert \mathbf&#123;w&#125; \Vert^2 \quad s.t. \quad y_i(\mathbf&#123;w&#125;^T\phi(\mathbf&#123;x&#125;)+b) \geq 1, \quad  i&#x3D;1,2,...,m\qquad(9)</span><br><span class="line">$$</span><br><span class="line">$$</span><br><span class="line">e\left ( x^&#123;*&#125; \right ) &#x3D; x - x^&#123;*&#125;x &#x3D; a_0 + \frac&#123;1&#125;&#123;a_1 +\sqrt&#123;a^2+b^2&#125; \frac&#123;1&#125;&#123;a_2 + \frac&#123;1&#125;&#123;a_3 + a_4&#125;&#125;&#125;\sqrt&#123;a^2+b^2&#125;</span><br><span class="line">$$</span><br><span class="line">$$</span><br><span class="line">f(n)&#x3D;\begin&#123;cases&#125;</span><br><span class="line">n&#x2F;2, &amp; \text&#123;如果$ x \leqslant 2 $&#125;\\</span><br><span class="line">3n+1, &amp; \text&#123;如果$ x&gt;2 $&#125;</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br><span class="line">$$\max \limits_&#123;a&lt;x&lt;b&#125;\&#123;f(x)\&#125;$$</span><br><span class="line">$$</span><br><span class="line">\beta^*(D) &#x3D; \mathop&#123;argmin&#125; \limits_&#123;\beta&#125; \lambda &#123;||\beta||&#125;^2 + \sum_&#123;i&#x3D;1&#125;^n max(0, 1 - y_i f_&#123;\beta&#125;(x_i)) </span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\left(\begin&#123;array&#125;&#123;c&#125;s \\</span><br><span class="line">  t\end&#123;array&#125;\right)&#x3D;</span><br><span class="line">\left(</span><br><span class="line">    \begin&#123;array&#125;&#123;cc&#125;</span><br><span class="line">      cos(b) &amp; -sin(b) \\</span><br><span class="line">      sin(b) &amp; cos(b)</span><br><span class="line">    \end&#123;array&#125;</span><br><span class="line">\right)</span><br><span class="line">\left(</span><br><span class="line">    \begin&#123;array&#125;&#123;c&#125;</span><br><span class="line">      x \\</span><br><span class="line">      y</span><br><span class="line">    \end&#123;array&#125;</span><br><span class="line">\right)</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>工具</category>
        <category>MathJax</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>支持区间修改的树状数组</title>
    <url>/archives/variant_BIT.html</url>
    <content><![CDATA[<!-- build time:Sat Jun 20 2020 01:38:47 GMT+0800 (GMT+08:00) --><h1 id="支持区间修改的树状数组">支持区间修改的树状数组</h1><p>能够在对数时间复杂度内支持区间修改的树状数组变种。 实质是两个树状数组来维护着差分前缀和，其中空间是3倍的区间长度,<span class="math inline">\(O(3*n)\)</span>。</p><a id="more"></a><h2 id="原理">原理</h2><p>对于一个数组<span class="math inline">\(a\)</span>，以及<span class="math inline">\(a\)</span>的差分<span class="math inline">\(c\)</span>，显然有</p><p><span class="math inline">\(c[i]=a[i]-a[i-1]\)</span></p><p>那么对于数组a的前缀和有</p><p><span class="math inline">\(\sum_{i=1}^n{a_i}=c[1]+(c[1]+c[2])+...(c[1]+c[2]+...+c[n])\)</span></p><p>进一步的：</p><p><span class="math inline">\(\sum_{i=1}^n{a_i}=c[1]*n+c[2]*(n-1)+...+c[n]*(n-n+1)\)</span></p><p>展开括号内</p><p><span class="math inline">\(\sum_{i=1}^n{a_i}=c[1]*n+c[2]*n+...+c[n]*n-(c[1]*(1-1)+c[2]*(2-1)+...+c[n]*(n-1))\)</span></p><p>即为</p><p><span class="math inline">\(\sum_{i=1}^n{a_i}=n*\sum_{i=1}^n{c[i]}-\sum_{i=1}^n{c[i]*(i-1)}\)</span></p><p>因此维护一个前缀和数组需要维护两个差分前缀和<span class="math inline">\(c[i]\)</span>和<span class="math inline">\((i-1)*c[i]\)</span>，对应为维护<span class="math inline">\(\sum_{i=1}^n{c[i]}\)</span>，<span class="math inline">\(\sum_{i=1}^n{(i-1)*c[i]}\)</span></p><p>这里使用两个树状数组对上述差分数组前缀和维护，分别命名为<span class="math inline">\(tr\)</span>和<span class="math inline">\(tr1\)</span>。</p><h2 id="实现">实现</h2><p>首先明确基本树状数组的两个基本操作：<strong>区间查询</strong>和<strong>单调查询</strong>。使用树状数组维护前缀和：</p><ol type="1"><li>区间查询 <span class="math inline">\(\text{query}(k)\)</span>，1到k之间的前缀和<span class="math inline">\(\sum_{i=1}^k{a[i]}\)</span>。</li><li>单点修改 <span class="math inline">\(\text{add}(k,x)\)</span>, <span class="math inline">\(a[k]+=x\)</span>。</li></ol><p>那么对于本文中的<strong>支持区间修改</strong>的树状数组有以下操作：</p><p>1.<strong>区间修改</strong> <span class="math inline">\(\text{add}(l,r,k)\)</span>(l和r包含),等效于操作<span class="math inline">\(\text{add1(l,x)}\)</span>,<span class="math inline">\(\text{add1}(r+1,-x)\)</span>和<span class="math inline">\(\text{add2}(l,(l-1)*x)\)</span>,<span class="math inline">\(\text{add2}(r+1,r*(-x))\)</span>(差分性质定义)</p><p>2.区间查询 ,<span class="math inline">\(querysum(k)\)</span>,等效于操作<span class="math inline">\(k*\text{query1}(k)*k-\text{query2}(k)\)</span></p><h2 id="操作">操作</h2><h3 id="基本树状数组">基本树状数组</h3><p>实现了<span class="math inline">\(O(log(n))\)</span>单点修改和区间查询。 支持单点修改，区间查询，单点查询。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll tr[maxn];  <span class="comment">//树状数组1用于维护差分前缀和$\sum_&#123;i=1&#125;^n&#123;c[i]&#125;$</span></span><br><span class="line">ll tr1[maxn]; <span class="comment">//树状数组2用于维护差分前缀和$\sum_&#123;i=1&#125;^n&#123;(i-1)*c[i]&#125;$</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll tr[], <span class="keyword">int</span> l, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= n; i += lowbit(i)) tr[i] = (tr[i] + k) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll tr[], <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i -= lowbit(i)) res = (res + tr[i]) % mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化">初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> nn)</span> </span>&#123;</span><br><span class="line">  n = nn + <span class="number">2</span>;<span class="comment">//防止空间越界</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) tr[i] = tr1[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间修改">区间修改</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//[l,r]区间修改+x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  add(tr, l, x);</span><br><span class="line">  add(tr, r + <span class="number">1</span>, -x);</span><br><span class="line">  add(tr1, l, <span class="number">1l</span>l * (l - <span class="number">1</span>) * x);</span><br><span class="line">  add(tr1, r + <span class="number">1</span>, <span class="number">1l</span>l * r * (-x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间查询">区间查询</h3><p>查询<span class="math inline">\(\sum_{i=1}^ka[i]\)</span>，即查询<span class="math inline">\([1,k]\)</span>内的前缀和</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//区间查询原数组sum(a[1,k])</span></span><br><span class="line"><span class="function">ll <span class="title">querysum</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1l</span>l * query(tr, k) * k)  - query(tr1, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间修改-1">区间修改</h3><p>在<span class="math inline">\(a[l]...a[r]\)</span>区间加上<span class="math inline">\(x\)</span>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//[l,r]区间修改+x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  add(tr, l, x);</span><br><span class="line">  add(tr, r + <span class="number">1</span>, -x);</span><br><span class="line">  add(tr1, l, <span class="number">1l</span>l * (l - <span class="number">1</span>) * x);<span class="comment">//防止暴int</span></span><br><span class="line">  add(tr1, r + <span class="number">1</span>, <span class="number">1l</span>l * r * (-x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="复杂度分析">复杂度分析</h2><p>实质是两个树状数组来维护着差分前缀和，其中空间是3倍的区间长度,<span class="math inline">\(O(3*n)\)</span> 时间复杂度： 在以下操作均为<span class="math inline">\(O(log(n))\)</span>：</p><ul><li>区间同加x</li><li>区间查询</li><li>单点查询</li><li>单调同加x</li></ul><p>相比线段树空间复杂度<span class="math inline">\(O(4*n)\)</span>要小 时间复杂度相同。</p><p>编程复杂度差不多（<del>都好难orz</del>）</p><h2 id="整合模板">整合模板</h2><p><a href="https://acm.uestc.edu.cn/problem/qing-xue-jie-chong-mei-li-de-hua/description" target="_blank" rel="noopener external nofollow noreferrer">题目传送门</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">772002</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll tr[maxn];  <span class="comment">//树状数组1</span></span><br><span class="line">ll tr1[maxn]; <span class="comment">//树状数组2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll tr[], <span class="keyword">int</span> l, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= n; i += lowbit(i)) tr[i] = (tr[i] + k) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll tr[], <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i -= lowbit(i)) res = (res + tr[i]) % mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[l,r]区间修改+x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  add(tr, l, x);</span><br><span class="line">  add(tr, r + <span class="number">1</span>, -x);</span><br><span class="line">  add(tr1, l, <span class="number">1l</span>l * (l - <span class="number">1</span>) * x);</span><br><span class="line">  add(tr1, r + <span class="number">1</span>, (<span class="number">1l</span>l * r * (-x)%mod+mod)%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询原数组sum(a[1,k])</span></span><br><span class="line"><span class="function">ll <span class="title">querysum</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (((<span class="number">1l</span>l * query(tr, k) * k) % mod - query(tr1, k) % mod) % mod + mod) %</span><br><span class="line">         mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> nn)</span> </span>&#123;</span><br><span class="line">  n = nn + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) tr[i] = tr1[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//按题目要求区间[l,r]修改 [l+1,r]+d,[l,l]+a0,[r+1,r+1]-前面两个的和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addad</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a0, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  add(l, l, a0);                     <span class="comment">//单点l上+a0</span></span><br><span class="line">  <span class="keyword">if</span> (l + <span class="number">1</span> &lt;= r) add(l + <span class="number">1</span>, r, d);  <span class="comment">//区间[l+1,r] +d</span></span><br><span class="line">  add(r + <span class="number">1</span>, r + <span class="number">1</span>,</span><br><span class="line">      (-(a0 + (<span class="number">1l</span>l * (r - l) * d)) % mod + mod) % mod);  <span class="comment">//单点r+1 -前面两个的和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询原数组sum(a[1,k])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryad</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123; <span class="keyword">return</span> querysum(k); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> op;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> judge</span></span><br><span class="line">  freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i],a[i]%=mod;</span><br><span class="line">  init(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> x, y;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      <span class="comment">//(y+1)y/2</span></span><br><span class="line">      <span class="comment">//对[x,x+y-1]加上一个-1</span></span><br><span class="line">      <span class="keyword">int</span> l = x, r = min(x + y - <span class="number">1</span>, n);</span><br><span class="line">      addad(l, r, y, <span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; (a[x] + queryad(x)) % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.cnblogs.com/acmsong/p/7225903.html" target="_blank" rel="noopener external nofollow noreferrer">树状数组区间加等差数列</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
</search>
