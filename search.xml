<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ST表实现RMQ</title>
    <url>/archives/luogu3865.html</url>
    <content><![CDATA[<!-- build time:Wed Mar 25 2020 17:18:30 GMT+0800 (GMT+08:00) --><h1 id="st表实现rmq">ST表实现RMQ</h1><p>什么是RMQ?</p><p>RMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。</p><p>什么是ST表？</p><p>ST 表是用于解决 可重复贡献问题 的数据结构。 除 RMQ 以外，还有其它的“可重复贡献问题”。例如“区间按位和”、“区间按位或”、“区间 GCD”，ST 表都能高效地解决。(都是可以重复贡献问题)</p><a id="more"></a><p><img src="https://gitee.com/adameta/img/raw/master/1584000763_20200312154743498_14987.png"></p><p>对于更好的解释：<a href="https://oi-wiki.org/ds/sparse-table/" target="_blank" rel="noopener external nofollow noreferrer">OI-wiki_ST表</a></p><p>用ST表实现RMQ问题？</p><p>时间复杂度：<span class="math inline">\(O(n\log n)-O(1)\)</span>，空间复杂度：<span class="math inline">\(O(n\log n)\)</span></p><hr><p>题目传送门』：<a href="https://www.luogu.com.cn/problem/P3865" target="_blank" rel="noopener external nofollow noreferrer">洛谷P3865 ST表</a></p><p>题目大意：给定 <span class="math inline">\(n\)</span> 个数，有 <span class="math inline">\(m\)</span> 个询问，对于每个询问，你需要回答区间 <span class="math inline">\([l,r]\)</span> 中的最大值。</p><p>关键思想： 令一个数组<span class="math inline">\(f(i,j)\)</span>表示区间<span class="math inline">\([i,i+2^{j}-1]\)</span>的最大值，那么显然就有<span class="math inline">\(f(i,0) = a_i\)</span>。</p><p><strong>预处理数组</strong>关键递推式： <span class="math display">\[f(i,j) =\max( f(i,j-1),f(i+2^{j-1},j-1))\]</span></p><p><strong>查询</strong>操作： 查询:对于每个询问 <span class="math inline">\([l,r]\)</span> ，把它分成两部分： <span class="math inline">\(f[l,l+2^s-1]\)</span> 与 <span class="math inline">\(f[r-2^s+1,r]\)</span> 。其中 <span class="math display">\[s=\left\lfloor\log_2(r-l+1)\right\rfloor\]</span></p><p><img src="https://gitee.com/adameta/img/raw/master/1584000766_20200312161156938_6071.png"></p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> logn = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//令go(i,j)表示区间[i,i+2^j-1]的最大值。</span></span><br><span class="line"><span class="keyword">int</span> go[maxn][logn], Logn[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Logn[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  Logn[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; maxn; i++) Logn[i] = Logn[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; go[i][<span class="number">0</span>];</span><br><span class="line">  pre();  <span class="comment">//预处理Log</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= logn; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        预处理区间</span></span><br><span class="line"><span class="comment">        把区间分为[i,j]分为[i,i+2^&#123;j-1&#125;-1] [i+2^&#123;j-1&#125;,i+2^&#123;j&#125;-1]</span></span><br><span class="line"><span class="comment">        1.即从i开始，向后跳2^&#123;j-1&#125;个点，右区间到i+2^&#123;j-1&#125;-1</span></span><br><span class="line"><span class="comment">        2.即从i+2^&#123;j-1&#125;开始，向后跳2^&#123;j-1&#125;个点，右区间到i+2^&#123;j&#125;-1</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      go[i][j] = max(go[i][j - <span class="number">1</span>], go[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">int</span> s = Logn[y - x + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      go(i,j)表示区间[i,i+2^j-1]的最大值。</span></span><br><span class="line"><span class="comment">      那么对于一对查询x,y,求[x,y]区间内的最大值</span></span><br><span class="line"><span class="comment">      对于区间长度(y - x + 1)：</span></span><br><span class="line"><span class="comment">      有 [log(y - x + 1)]_&#123;floor&#125; = s</span></span><br><span class="line"><span class="comment">      [x][s]和[y - (1 &lt;&lt; s) + 1][s]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(go[x][s], go[y - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>ST表</category>
        <category>区间题</category>
      </categories>
      <tags>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>糖果传递</title>
    <url>/archives/acw122.html</url>
    <content><![CDATA[<!-- build time:Wed Mar 25 2020 17:13:36 GMT+0800 (GMT+08:00) --><h1 id="糖果传递问题">糖果传递问题</h1><h2 id="题目">题目</h2><p><a href="https://www.acwing.com/problem/content/124/" target="_blank" rel="noopener external nofollow noreferrer">『算法竞赛进阶指南』糖果传递</a> 有n个小朋友坐成一圈，每人有a[i]个糖果。 每人只能给左右两人传递糖果。 每人每次传递一个糖果代价为1。 求使所有人获得均等糖果的最小代价。</p><a id="more"></a><h2 id="思路">思路</h2><p><img src="https://gitee.com/adameta/img/raw/master/1584343110_20200316145159297_13254.png"></p><p>假设<span class="math inline">\(n\)</span>个小朋友分别有<span class="math inline">\(a_1,a_2,...,a_n\)</span>个糖果，第<span class="math inline">\(i\)</span>个小朋友给<span class="math inline">\(i-1\)</span>个小朋友<span class="math inline">\(x_i\)</span>个糖果，（<span class="math inline">\(x_i\)</span>可正可负） 那么目标就为<span class="math inline">\(\min\sum|x_i|\)</span>。 对于上述的问题转化，可以列出方程组: <span class="math inline">\(\begin{cases}a_1-x_1+x_2=\bar{a} \\ a_2-x_2+x_3=\bar{a}\\...\\ a_n-x_n+x_1=\bar{a}\end{cases}\)</span></p><p>进一步的化简为: <span class="math inline">\(\begin{cases}x_1=x_1-(n\bar{a}-a_1-a_2-...-a_n)\\x_2=x_1-((n-1)\bar{a}-a_2-a_3-...-a_n)\\...\\x_{n-1}=x_1-(2\bar{a}-a_{n+1}-a_n)\\x_n=x_1-(\bar{a}-a_n)\end{cases}\)</span></p><p>注意: 化简过程是对于第i个式子，使用第i+1到第n个式子,例如对于第n-1项来说： <span class="math inline">\(\begin{cases} a_{n-1}-x_{n-1}+x_{n}=\bar{a}\\ a_n-x_n+x_1=\bar{a}\end{cases}\)</span> 将最后一个方程的<span class="math inline">\(x_n\)</span>带入到倒数第二个方程中，把<span class="math inline">\(x_n=x_1-(\bar{a}-a_n)\)</span>带入到<span class="math inline">\(a_{n-1}-x_{n-1}+x_{n}=\bar{a}\)</span>中，得到<span class="math inline">\(x_{n-1}=x_1-(2\bar{a}-a_{n+1}-a_n)\)</span>。以此类推</p><p>令右式常数分别为<span class="math inline">\(c_1,c_2,...,c_n\)</span></p><p>可以得到目标<span class="math inline">\(\min\sum|x_i|=(|x_1-c_1|+|x_1-c_2|+...+|x_1-c_n|)\)</span>，又因为<span class="math inline">\((|x_1-c_1|+|x_1-c_2|+...+|x_1-c_n|)\)</span>等价于在数轴上找一个点<span class="math inline">\(x_1\)</span>，该点到<span class="math inline">\(c_1,c_2,...,c_n\)</span>的距离之和最小。即转化为下面问题： 在一个数轴上，有偶数个点<span class="math inline">\(c_1,c_2,...,c_n\)</span>,需要找到一个点<span class="math inline">\(x_1\)</span>使得<span class="math inline">\(x_1\)</span>到其他点的距离最小，不难证明<span class="math inline">\(x_1\)</span>为中位数（可以视作一个结论，证明见最下面）。 <img src="https://gitee.com/adameta/img/raw/master/1584343112_20200316151251991_11809.png"></p><p>最后可以总结出算法 * 求出<span class="math inline">\(a\)</span>平均数<span class="math inline">\(\bar{a}\)</span> * 求出<span class="math inline">\(c_1,c_2,...,c_n\)</span> * 求出其中的中点值<span class="math inline">\(x_1\)</span>（对c数组排序） * 计算<span class="math inline">\(|x_1-c_1|+|x_1-c_2|+...+|x_1-c_n|\)</span></p><p>其中第二个步骤求出c的数组使用了一下递推式：</p><p><span class="math inline">\(\begin{cases}c_i=c_{i+1}+\bar{a}-a_i\\c_n =\bar{a}-a_n \end{cases}\)</span></p><p>递推式<span class="math inline">\(c_i=c_{i+1}+\bar{a}-a_i\)</span>使用第<span class="math inline">\(i+1\)</span>项方程减去第<span class="math inline">\(i\)</span>项方程既可。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll n;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll abar;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i], abar += a[i];</span><br><span class="line">  abar /= n;</span><br><span class="line">  a[n] = abar - a[n];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) a[i] = a[i + <span class="number">1</span>] + abar - a[i];</span><br><span class="line">  sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">  ll p = (a[n / <span class="number">2</span>] + a[n / <span class="number">2</span> + <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    res += <span class="built_in">abs</span>(a[i] - p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他">其他</h2><p>『题目传送门』：<a href="https://www.acwing.com/problem/content/106/" target="_blank" rel="noopener external nofollow noreferrer">acwing104</a> 关于一个数轴上的序列<span class="math inline">\(c_1,c_2,...,c_n\)</span>,需要找到一个点<span class="math inline">\(x_1\)</span>使得<span class="math inline">\(x_1\)</span>到其他点的距离最小。</p><p>思路：首先对<span class="math inline">\(c\)</span>排序,使得<span class="math inline">\(c_1 &lt; c_2 &lt; ... &lt; c_n\)</span>，考虑<span class="math inline">\(c_1,c_n\)</span>，<span class="math inline">\(c_2,c_{n-1}\)</span>...,<span class="math inline">\(c_{k-1},c_k\)</span>两两配对，以<span class="math inline">\(c_1,c_n\)</span>这一对来考虑 <img src="https://gitee.com/adameta/img/raw/master/1584343976_20200316152640321_695.png"></p><p>继续扩展到4个点，（两对） <img src="https://gitee.com/adameta/img/raw/master/1584343976_20200316153020498_14966.png"></p><p>推广到<span class="math inline">\(n=k\)</span>的情况下（<span class="math inline">\(k=n/2\)</span>）同理，因此可知<span class="math inline">\(x\)</span>应该取到<span class="math inline">\(\frac{x_k+x_{k+1}}{2}\)</span>。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>贪心</category>
        <category>思维题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀表达式</title>
    <url>/archives/acw1247.html</url>
    <content><![CDATA[<!-- build time:Wed Mar 25 2020 17:13:36 GMT+0800 (GMT+08:00) --><h1 id="acwing1247后缀表达式">acwing1247后缀表达式</h1><p><a href="https://www.acwing.com/problem/content/description/1249/" target="_blank" rel="noopener external nofollow noreferrer">后缀表达式</a></p><hr><p>题目大意：n+1个+ m个-加入到表达式中使得整个序列最大</p><a id="more"></a><p>分析: <strong>这个题目贪心的关键是考虑到负号的数目不是m个，而是1到m+n个</strong> 考虑系列如下： <span class="math display">\[\text{target}:\max(a_1+a_2+...+a_{i-1})-\min(b_i-b_{i+1}-...-b_n)\]</span> 其中<span class="math inline">\(\min()\)</span>中可以有负号和正号，展开式子之后得到的是其取反，因此考虑极端的状态如果所有的<span class="math inline">\(n-1\)</span>个+放在<span class="math inline">\(\min\)</span>中，<span class="math inline">\(m-1\)</span>个-放在<span class="math inline">\(\max\)</span>中，那么总共就有<span class="math inline">\(n+m\)</span>个负数。同理的，可以在确定了两个数分别作为<span class="math inline">\(a_1\)</span>和<span class="math inline">\(b_{i+1}\)</span>之后，就只需在两个数列中继续加入数字即可。</p><p>即把一个负号提出来剩余负号都在b中那么就只有一个负号 如果把一个负号提出来m-2个负号在b中那么就有2个负号 ... 以此类推从总共可以有m+n到1个负号 至少有一个加号，至少有一个负号</p><p>那么因此序列如下： <span class="math display">\[\text{target}:\max(a_1(-/+)a_2(-/+)...(-/+)a_n)-\min(b_i(-/+)b_{i+1}(-/+)...(-/+)b_n)\]</span></p><p><strong>贪心策略</strong>：为了使得<span class="math inline">\(\text{target}\)</span>最大，我们尽量把<strong>所有的负数加到右边，把正数加到左边</strong>。那么相当于取到其他的数的绝对值。 因此总的答案应该是 <span class="math inline">\(a\)</span> 排序后 <span class="math display">\[\sum_{i=2}^{n-1}\text{abs}(a[i])-a[1]+a[n]\]</span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> judge</span></span><br><span class="line">  freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m + <span class="number">1</span>; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m + <span class="number">1</span>; i++) res += a[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(a + <span class="number">1</span>, a + n + m + <span class="number">2</span>);</span><br><span class="line">  res = -a[<span class="number">1</span>] + a[n + m + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + m + <span class="number">1</span>; i++) res += <span class="built_in">abs</span>(a[i]);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>贪心</category>
        <category>思维题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>约数和</title>
    <url>/archives/acw1296.html</url>
    <content><![CDATA[<!-- build time:Wed Mar 25 2020 17:13:36 GMT+0800 (GMT+08:00) --><h1 id="约数和">约数和</h1><p><a href="https://www.acwing.com/problem/content/description/1298/" target="_blank" rel="noopener external nofollow noreferrer">『聪明的燕姿』</a></p><p>题目大意：给定一个S，求出所有符合质因数分解的和为S的数x</p><p>思路：DFS、约数和公式</p><p>约数和公式</p><p><span class="math display">\[ s=(p_1^0 + p_1^1 + ... + p_1^{\alpha_1})...(p_k^0+p_k^1+...+p_k^{\alpha_k}) \]</span> 其中 <span class="math inline">\(p\)</span> 为质因子，<span class="math inline">\(\alpha\)</span> 为质因子幂次。</p><a id="more"></a><p>之后，考虑到给定当前式子和，未知为质因子和质因子幂，已知约数和<span class="math inline">\(S\)</span>。考虑到式子每一项的大小，项数应该确定在10项以内（根据式子），因此使用<code>DFS</code>搜索位置系数。</p><p>那么该如何搜索？</p><ul><li>枚举p，找到一个可能的p</li><li>枚举alpha，找到一个可能的alpha</li><li>对于枚举的一个项能被整除，则进行下一个枚举</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(u,...)</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(p: <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">11.</span>..)</span></span></span><br><span class="line"><span class="function">        fact </span>= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(alpha <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">if</span> s % fact ==<span class="number">0</span></span><br><span class="line">                    dfs(u+<span class="number">1</span>,...)</span><br></pre></td></tr></table></figure><p>考虑上面式子中枚举质因子p,因为小于S的质数共有 <span class="math inline">\(\frac{S}{logn}\)</span>个（质数基本定理），粗略估计是 1e8 的数量级。 直接枚举p是不可以接受的。</p><p>如果 alpha=1 ,则因子变为 <span class="math inline">\(S=1+p_i\)</span> 的形式，当 <span class="math inline">\(S-1\)</span> 是质数的时候成立。判定质数是 <span class="math inline">\(O(\sqrt{n})\)</span></p><p>否则 当 <span class="math inline">\(S\neq1+p_i\)</span> ：</p><p>即有两种可能：</p><p><span class="math display">\[ S = (1+p_i+p_i^2+...)(...)... \\ S = (1+p_i)(...) \]</span></p><p>对于第一种情况</p><p><span class="math display">\[ S = (1+p_i+p_i^2+...)(...) \]</span></p><p><span class="math inline">\(p_i^2 &lt; S\)</span> ，发现在项中的每一项含有 <span class="math inline">\(p^2\)</span> 的项只用枚举到平方即可。时间复杂度即第一个for只用枚举到平方小于x然后再特判第一个p即可。</p><p>而对于第二种情况 <span class="math inline">\(p_i^2 &lt; S\)</span>也是必然成立的，即枚举时若有<span class="math inline">\(p_i^2 &gt; S\)</span>则直接退出当前的枚举。即对于每一个素数枚举到<span class="math inline">\(\sqrt{S}\)</span>即可，（即当<span class="math inline">\(p_i^2&lt;S\)</span>时可以枚举）这样的话根据上面分析，最多会有10项，每一项需要枚举<span class="math inline">\(\sqrt{S}\)</span>，总共k组数据所以时间复杂度是 <span class="math inline">\(10*k\sqrt{S}\)</span>即为<span class="math inline">\(5e7\)</span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> judge</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>;</span><br><span class="line"><span class="keyword">int</span> primes[maxn], cnt, used[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!used[i]) primes[cnt++] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++) &#123;</span><br><span class="line">      used[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">last 上一个fact项的质数下标是多少</span></span><br><span class="line"><span class="comment">prod 当前代求答案数</span></span><br><span class="line"><span class="comment">s 剩余的S</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_p</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; maxn) <span class="keyword">return</span> !used[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; primes[i] &lt;= x / primes[i]; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % primes[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> prod, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">1</span>) &#123;  <span class="comment">// get a ans</span></span><br><span class="line">    ans[len++] = prod;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s - <span class="number">1</span> &gt; (last &lt; <span class="number">0</span> ? <span class="number">1</span> : primes[last]) &amp;&amp; is_p(s - <span class="number">1</span>)) &#123;  <span class="comment">//上一个质数</span></span><br><span class="line">    <span class="comment">// s-1&gt;1成立 （第一次）</span></span><br><span class="line">    <span class="comment">// s-1&gt;p_last 大于上一个质数 即还可以枚举</span></span><br><span class="line">    ans[len++] = prod * (s - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = last + <span class="number">1</span>; primes[i] &lt;= s / primes[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = primes[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> + p, t = p; j &lt;= s; t *= p, j += t) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s % j == <span class="number">0</span>) &#123;</span><br><span class="line">        dfs(i, prod * t, s / j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> judge</span></span><br><span class="line">  freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  getp(maxn - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  假设自己的号码牌上写着数字 S，</span></span><br><span class="line"><span class="comment">  那么自己等的人手上的号码牌数字的所有正约数之和必定等于 S。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法是使用约数和公式</span></span><br><span class="line"><span class="comment">    一个数的约数的和等于</span></span><br><span class="line"><span class="comment">    $$(p_1^0+p_1^1+...+p_1^\alpha_1)...(p_k^0+p_k^1+...+p_k^\alpha_k)$$</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">    len = <span class="number">0</span>;  <span class="comment">//当前搜索的长度</span></span><br><span class="line">    dfs(<span class="number">-1</span>, <span class="number">1</span>, s);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (len) &#123;</span><br><span class="line">      sort(ans, ans + len);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>因式分解</category>
        <category>搜索，DFS</category>
      </categories>
      <tags>
        <tag>因式分解</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>blog 改造计划</title>
    <url>/archives/blog_plan.html</url>
    <content><![CDATA[<!-- build time:Wed Mar 25 2020 17:13:36 GMT+0800 (GMT+08:00) --><p>因为 kardown 解析器对 MathJax 有支持问题，在书写某些数学公式时常常发生奇怪的错误。 最为典型的便是 <code>$x_1+x_2$</code> 会先被 markdown 解析为斜体，之后 MathJax 就无法得到正确的公式。 为了获得更好的支持体验，在前辈<a href="https://blog.yuki-nagato.com/" target="_blank" rel="noopener external nofollow noreferrer">長門有希</a>建议下使用了更好的数学公式解析支持 <a href="https://pandoc.org/" target="_blank" rel="noopener external nofollow noreferrer">Pandoc</a>，做了相关调研后，确定使用 hexo 下的 nexT 主题，将默认的解析器更换为 hexo-renderer-pandoc。完美解决了该问题<a href="https://adameta.top/archives/mathjax_plugin.html">测试mathjax插件</a>。之后对博客做些许美化，如下：</p><p>计划将博客从 jeklly 迁移到 hexo, 版本为 7.7.2。</p><a id="more"></a><ul><li>[x] 加入了搜索功能</li><li>[x] 加入 mathjax 插件支持,能够完美解析公式</li><li>[x] 添加 categories, tag, about, links 页面</li><li>[x] 在文章末尾加入了频道订阅</li><li>[x] 加入了头像和联系方式</li><li>[x] 加入了字数统计和阅读时间提醒</li><li>[x] 解决友情链接问题</li><li>[x] 加入文章进度条</li><li>[x] 对文章连接永久化操作</li><li>[x] 修改返回文章顶部按钮</li><li>[x] 文件压缩插件，以及其他加快浏览速度</li><li>[x] 文章顶置功能</li><li>[x] 修改主页文章显示长度</li><li>[x] 加入近期文章</li><li>[x] 加入中文字体</li><li>[x] 对总体样式进行优化（边角的优化）</li><li>[x] 完善联系方式</li><li>[x] 背景图片</li><li>[x] 修改 head 图标</li><li>[x] 文章末尾添加 copyright</li><li>[x] 加入代码框阴影效果,复制功能</li><li>[x] 文章评论功能</li><li>[ ] 国内外访问速度问题（Hexo 博客部署在 GitHub Pages 上并且配置 CDN 进行加速）</li><li>[ ] 提交搜索引擎收录</li><li>[ ] 加入了夜间模式 X | 目前原生支持有bug</li><li>[ ] 阅读排行榜 (热门文章) | 待完善</li></ul><hr><p>参考连接：</p><p><a href="https://tding.top/archives/aad98408.html" target="_blank" rel="noopener external nofollow noreferrer">Hexo 搭建个人博客文章汇总</a></p><p><a href="http://lx34r.coding.me/posts/3018881965/" target="_blank" rel="noopener external nofollow noreferrer">优化个人博客(theme_next)相关</a></p><p><a href="https://tding.top/archives/29bfe8c9.html" target="_blank" rel="noopener external nofollow noreferrer">Hexo-NexT Tag 插件的使用</a></p><p><a href="https://theme-next.org/docs/theme-settings/posts" target="_blank" rel="noopener external nofollow noreferrer">NexT Theme for Hexo-Posts</a></p><p><a href="https://hexo.io/docs/front-matter" target="_blank" rel="noopener external nofollow noreferrer">Front-matter</a></p><p><a href="https://www.jianshu.com/p/78c218f9d1e7" target="_blank" rel="noopener external nofollow noreferrer">Hexo-设置阅读全文</a></p><p><a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener external nofollow noreferrer">Hexo-标签插件（Tag Plugins）</a></p><p><a href="https://tding.top/archives/42c38b10" target="_blank" rel="noopener external nofollow noreferrer">Hexo-NexT (v7.0+) 主题配置</a></p><p><a href="https://theme-next.org/docs" target="_blank" rel="noopener external nofollow noreferrer">Hexo-NexT 官方文档</a></p><p><a href="https://zhangzw.com/posts/20190830.html" target="_blank" rel="noopener external nofollow noreferrer">Hexo 给文章中英文添加空格</a></p><p><a href="https://tding.top/docs/getting-started/data-files.html" target="_blank" rel="noopener external nofollow noreferrer">数据文件</a></p><p><a href="https://memento.net.cn/post/4af0cb81.html" target="_blank" rel="noopener external nofollow noreferrer">相关文章之 hexo-related-popular-posts</a></p><p><a href="http://blog.amdoing.com/the-post-copyright-in-hexo-next/" target="_blank" rel="noopener external nofollow noreferrer">使用Hexo的next主题，配置POST文章文末的版权信息</a></p><p><a href="https://github.com/1v9/hexo-next-nightmode" target="_blank" rel="noopener external nofollow noreferrer">Hexo NexT Night Mode</a></p><p><a href="https://github.com/theme-next/hexo-theme-next/pull/1386" target="_blank" rel="noopener external nofollow noreferrer">Native Dark Mode support #1386</a></p><p><a href="https://valine.js.org/hexo.html#hexo-theme-next" target="_blank" rel="noopener external nofollow noreferrer">valine hexo-theme-next</a></p><p><a href="https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener external nofollow noreferrer">hexo-Next-主题添加评论功能</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>测试mathjax插件</title>
    <url>/archives/mathjax_plugin.html</url>
    <content><![CDATA[<!-- build time:Wed Mar 25 2020 17:13:36 GMT+0800 (GMT+08:00) --><p>用于测试 Pandoc 解析器。 给出一些测试公式<a id="more"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\frac&#123;\partial u&#125;&#123;\partial t&#125;</span><br><span class="line">&#x3D; h^2 \left( \frac&#123;\partial^2 u&#125;&#123;\partial x^2&#125; +</span><br><span class="line">\frac&#123;\partial^2 u&#125;&#123;\partial y^2&#125; +</span><br><span class="line">\frac&#123;\partial^2 u&#125;&#123;\partial z^2&#125;\right)$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[\frac{\partial u}{\partial t} = h^2 \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}\right)\]</span></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\left[</span><br><span class="line">    \begin&#123;array&#125;&#123;cc|c&#125;</span><br><span class="line">      1&amp;2&amp;3\newline</span><br><span class="line">      4&amp;5&amp;6</span><br><span class="line">    \end&#123;array&#125;</span><br><span class="line">\right] </span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[ \left[ \begin{array}{cc|c} 1&amp;2&amp;3\newline 4&amp;5&amp;6 \end{array} \right] \]</span></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">&#123;\mathcal L&#125;_&#123;cyc&#125;(G,F)&#x3D;&#123;\mathbb E&#125;_&#123;x \sim p_&#123;data&#125;(x)&#125;[&#123;\|F(G(x))-x\|&#125;_&#123;1&#125;]+&#123;\mathbb E&#125;_&#123;y \sim p_&#123;data&#125;(y)&#125;[&#123;\|G(F(y))-y\|&#125;_&#123;1&#125;]</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[ {\mathcal L}_{cyc}(G,F)={\mathbb E}_{x \sim p_{data}(x)}[{\|F(G(x))-x\|}_{1}]+{\mathbb E}_{y \sim p_{data}(y)}[{\|G(F(y))-y\|}_{1}] \]</span></p><p>测试一下功能：</p><p><span class="math display">\[e_r( x^{*} ) = \frac{x-x^*}{x^*}\]</span> <span class="math display">\[\mathop{x} \limits_a^b\]</span> <span class="math display">\[e_r( x^{*} ) = \frac{x-x^*}{x^*}\]</span> <span class="math display">\[a_x+b_x=c_x\]</span> <span class="math display">\[e\left ( x^{*} \right ) = x - x^{*}\]</span> <span class="math display">\[ \left| e \right|=\left | x-x^* \right |\leq \varepsilon \]</span> <span class="math display">\[ \min_{\mathbf{w},b} \frac{1}{2} \Vert \mathbf{w} \Vert^2 \quad s.t. \quad y_i(\mathbf{w}^T\phi(\mathbf{x})+b) \geq 1, \quad i=1,2,...,m\qquad(9) \]</span> <span class="math display">\[ e\left ( x^{*} \right ) = x - x^{*}x = a_0 + \frac{1}{a_1 +\sqrt{a^2+b^2} \frac{1}{a_2 + \frac{1}{a_3 + a_4}}}\sqrt{a^2+b^2} \]</span> <span class="math display">\[ f(n)=\begin{cases} n/2, &amp; \text{如果$ x \leqslant 2 $}\\ 3n+1, &amp; \text{如果$ x&gt;2 $} \end{cases} \]</span> <span class="math display">\[\max \limits_{a&lt;x&lt;b}\{f(x)\}\]</span> <span class="math display">\[ \beta^*(D) = \mathop{argmin} \limits_{\beta} \lambda {||\beta||}^2 + \sum_{i=1}^n max(0, 1 - y_i f_{\beta}(x_i)) \]</span></p><p><span class="math display">\[ \left(\begin{array}{c}s \\ t\end{array}\right)= \left( \begin{array}{cc} cos(b) &amp; -sin(b) \\ sin(b) &amp; cos(b) \end{array} \right) \left( \begin{array}{c} x \\ y \end{array} \right) \]</span></p><p>测试源码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$e_r( x^&#123;*&#125;  ) &#x3D; \frac&#123;x-x^*&#125;&#123;x^*&#125;$$</span><br><span class="line">$$\mathop&#123;x&#125; \limits_a^b$$</span><br><span class="line">$$e_r( x^&#123;*&#125;  ) &#x3D; \frac&#123;x-x^*&#125;&#123;x^*&#125;$$</span><br><span class="line">$$a_x+b_x&#x3D;c_x$$</span><br><span class="line">$$e\left ( x^&#123;*&#125; \right ) &#x3D; x - x^&#123;*&#125;$$</span><br><span class="line">$$</span><br><span class="line">\left| e \right|&#x3D;\left | x-x^* \right |\leq \varepsilon</span><br><span class="line">$$</span><br><span class="line">$$</span><br><span class="line">\min_&#123;\mathbf&#123;w&#125;,b&#125; \frac&#123;1&#125;&#123;2&#125; \Vert \mathbf&#123;w&#125; \Vert^2 \quad s.t. \quad y_i(\mathbf&#123;w&#125;^T\phi(\mathbf&#123;x&#125;)+b) \geq 1, \quad  i&#x3D;1,2,...,m\qquad(9)</span><br><span class="line">$$</span><br><span class="line">$$</span><br><span class="line">e\left ( x^&#123;*&#125; \right ) &#x3D; x - x^&#123;*&#125;x &#x3D; a_0 + \frac&#123;1&#125;&#123;a_1 +\sqrt&#123;a^2+b^2&#125; \frac&#123;1&#125;&#123;a_2 + \frac&#123;1&#125;&#123;a_3 + a_4&#125;&#125;&#125;\sqrt&#123;a^2+b^2&#125;</span><br><span class="line">$$</span><br><span class="line">$$</span><br><span class="line">f(n)&#x3D;\begin&#123;cases&#125;</span><br><span class="line">n&#x2F;2, &amp; \text&#123;如果$ x \leqslant 2 $&#125;\\</span><br><span class="line">3n+1, &amp; \text&#123;如果$ x&gt;2 $&#125;</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br><span class="line">$$\max \limits_&#123;a&lt;x&lt;b&#125;\&#123;f(x)\&#125;$$</span><br><span class="line">$$</span><br><span class="line">\beta^*(D) &#x3D; \mathop&#123;argmin&#125; \limits_&#123;\beta&#125; \lambda &#123;||\beta||&#125;^2 + \sum_&#123;i&#x3D;1&#125;^n max(0, 1 - y_i f_&#123;\beta&#125;(x_i)) </span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\left(\begin&#123;array&#125;&#123;c&#125;s \\</span><br><span class="line">  t\end&#123;array&#125;\right)&#x3D;</span><br><span class="line">\left(</span><br><span class="line">    \begin&#123;array&#125;&#123;cc&#125;</span><br><span class="line">      cos(b) &amp; -sin(b) \\</span><br><span class="line">      sin(b) &amp; cos(b)</span><br><span class="line">    \end&#123;array&#125;</span><br><span class="line">\right)</span><br><span class="line">\left(</span><br><span class="line">    \begin&#123;array&#125;&#123;c&#125;</span><br><span class="line">      x \\</span><br><span class="line">      y</span><br><span class="line">    \end&#123;array&#125;</span><br><span class="line">\right)</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>工具</category>
        <category>MathJax</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>支持区间修改的树状数组</title>
    <url>/archives/variant_BIT.html</url>
    <content><![CDATA[<!-- build time:Wed Mar 25 2020 17:13:36 GMT+0800 (GMT+08:00) --><h1 id="支持区间修改的树状数组">支持区间修改的树状数组</h1><p>能够在对数时间复杂度内支持区间修改的树状数组变种。 实质是两个树状数组来维护着差分前缀和，其中空间是3倍的区间长度,<span class="math inline">\(O(3*n)\)</span>。</p><a id="more"></a><h2 id="原理">原理</h2><p>对于一个数组<span class="math inline">\(a\)</span>，以及<span class="math inline">\(a\)</span>的差分<span class="math inline">\(c\)</span>，显然有</p><p><span class="math inline">\(c[i]=a[i]-a[i-1]\)</span></p><p>那么对于数组a的前缀和有</p><p><span class="math inline">\(\sum_{i=1}^n{a_i}=c[1]+(c[1]+c[2])+...(c[1]+c[2]+...+c[n])\)</span></p><p>进一步的：</p><p><span class="math inline">\(\sum_{i=1}^n{a_i}=c[1]*n+c[2]*(n-1)+...+c[n]*(n-n+1)\)</span></p><p>展开括号内</p><p><span class="math inline">\(\sum_{i=1}^n{a_i}=c[1]*n+c[2]*n+...+c[n]*n-(c[1]*(1-1)+c[2]*(2-1)+...+c[n]*(n-1))\)</span></p><p>即为</p><p><span class="math inline">\(\sum_{i=1}^n{a_i}=n*\sum_{i=1}^n{c[i]}-\sum_{i=1}^n{c[i]*(i-1)}\)</span></p><p>因此维护一个前缀和数组需要维护两个差分前缀和<span class="math inline">\(c[i]\)</span>和<span class="math inline">\((i-1)*c[i]\)</span>，对应为维护<span class="math inline">\(\sum_{i=1}^n{c[i]}\)</span>，<span class="math inline">\(\sum_{i=1}^n{(i-1)*c[i]}\)</span></p><p>这里使用两个树状数组对上述差分数组前缀和维护，分别命名为<span class="math inline">\(tr\)</span>和<span class="math inline">\(tr1\)</span>。</p><h2 id="实现">实现</h2><p>首先明确基本树状数组的两个基本操作：<strong>区间查询</strong>和<strong>单调查询</strong>。使用树状数组维护前缀和：</p><ol type="1"><li>区间查询 <span class="math inline">\(\text{query}(k)\)</span>，1到k之间的前缀和<span class="math inline">\(\sum_{i=1}^k{a[i]}\)</span>。</li><li>单点修改 <span class="math inline">\(\text{add}(k,x)\)</span>, <span class="math inline">\(a[k]+=x\)</span>。</li></ol><p>那么对于本文中的<strong>支持区间修改</strong>的树状数组有以下操作：</p><p>1.<strong>区间修改</strong> <span class="math inline">\(\text{add}(l,r,k)\)</span>(l和r包含),等效于操作<span class="math inline">\(\text{add1(l,x)}\)</span>,<span class="math inline">\(\text{add1}(r+1,-x)\)</span>和<span class="math inline">\(\text{add2}(l,(l-1)*x)\)</span>,<span class="math inline">\(\text{add2}(r+1,r*(-x))\)</span>(差分性质定义)</p><p>2.区间查询 ,<span class="math inline">\(querysum(k)\)</span>,等效于操作<span class="math inline">\(k*\text{query1}(k)*k-\text{query2}(k)\)</span></p><h2 id="操作">操作</h2><h3 id="基本树状数组">基本树状数组</h3><p>实现了<span class="math inline">\(O(log(n))\)</span>单点修改和区间查询。 支持单点修改，区间查询，单点查询。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll tr[maxn];  <span class="comment">//树状数组1用于维护差分前缀和$\sum_&#123;i=1&#125;^n&#123;c[i]&#125;$</span></span><br><span class="line">ll tr1[maxn]; <span class="comment">//树状数组2用于维护差分前缀和$\sum_&#123;i=1&#125;^n&#123;(i-1)*c[i]&#125;$</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll tr[], <span class="keyword">int</span> l, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= n; i += lowbit(i)) tr[i] = (tr[i] + k) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll tr[], <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i -= lowbit(i)) res = (res + tr[i]) % mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化">初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> nn)</span> </span>&#123;</span><br><span class="line">  n = nn + <span class="number">2</span>;<span class="comment">//防止空间越界</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) tr[i] = tr1[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间修改">区间修改</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//[l,r]区间修改+x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  add(tr, l, x);</span><br><span class="line">  add(tr, r + <span class="number">1</span>, -x);</span><br><span class="line">  add(tr1, l, <span class="number">1l</span>l * (l - <span class="number">1</span>) * x);</span><br><span class="line">  add(tr1, r + <span class="number">1</span>, <span class="number">1l</span>l * r * (-x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间查询">区间查询</h3><p>查询<span class="math inline">\(\sum_{i=1}^ka[i]\)</span>，即查询<span class="math inline">\([1,k]\)</span>内的前缀和</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//区间查询原数组sum(a[1,k])</span></span><br><span class="line"><span class="function">ll <span class="title">querysum</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1l</span>l * query(tr, k) * k)  - query(tr1, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间修改-1">区间修改</h3><p>在<span class="math inline">\(a[l]...a[r]\)</span>区间加上<span class="math inline">\(x\)</span>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//[l,r]区间修改+x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  add(tr, l, x);</span><br><span class="line">  add(tr, r + <span class="number">1</span>, -x);</span><br><span class="line">  add(tr1, l, <span class="number">1l</span>l * (l - <span class="number">1</span>) * x);<span class="comment">//防止暴int</span></span><br><span class="line">  add(tr1, r + <span class="number">1</span>, <span class="number">1l</span>l * r * (-x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="复杂度分析">复杂度分析</h2><p>实质是两个树状数组来维护着差分前缀和，其中空间是3倍的区间长度,<span class="math inline">\(O(3*n)\)</span> 时间复杂度： 在以下操作均为<span class="math inline">\(O(log(n))\)</span>：</p><ul><li>区间同加x</li><li>区间查询</li><li>单点查询</li><li>单调同加x</li></ul><p>相比线段树空间复杂度<span class="math inline">\(O(4*n)\)</span>要小 时间复杂度相同。</p><p>编程复杂度差不多（<del>都好难orz</del>）</p><h2 id="整合模板">整合模板</h2><p><a href="https://acm.uestc.edu.cn/problem/qing-xue-jie-chong-mei-li-de-hua/description" target="_blank" rel="noopener external nofollow noreferrer">题目传送门</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">772002</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll tr[maxn];  <span class="comment">//树状数组1</span></span><br><span class="line">ll tr1[maxn]; <span class="comment">//树状数组2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll tr[], <span class="keyword">int</span> l, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= n; i += lowbit(i)) tr[i] = (tr[i] + k) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll tr[], <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i -= lowbit(i)) res = (res + tr[i]) % mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[l,r]区间修改+x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  add(tr, l, x);</span><br><span class="line">  add(tr, r + <span class="number">1</span>, -x);</span><br><span class="line">  add(tr1, l, <span class="number">1l</span>l * (l - <span class="number">1</span>) * x);</span><br><span class="line">  add(tr1, r + <span class="number">1</span>, (<span class="number">1l</span>l * r * (-x)%mod+mod)%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询原数组sum(a[1,k])</span></span><br><span class="line"><span class="function">ll <span class="title">querysum</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (((<span class="number">1l</span>l * query(tr, k) * k) % mod - query(tr1, k) % mod) % mod + mod) %</span><br><span class="line">         mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> nn)</span> </span>&#123;</span><br><span class="line">  n = nn + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) tr[i] = tr1[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//按题目要求区间[l,r]修改 [l+1,r]+d,[l,l]+a0,[r+1,r+1]-前面两个的和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addad</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a0, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  add(l, l, a0);                     <span class="comment">//单点l上+a0</span></span><br><span class="line">  <span class="keyword">if</span> (l + <span class="number">1</span> &lt;= r) add(l + <span class="number">1</span>, r, d);  <span class="comment">//区间[l+1,r] +d</span></span><br><span class="line">  add(r + <span class="number">1</span>, r + <span class="number">1</span>,</span><br><span class="line">      (-(a0 + (<span class="number">1l</span>l * (r - l) * d)) % mod + mod) % mod);  <span class="comment">//单点r+1 -前面两个的和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询原数组sum(a[1,k])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryad</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123; <span class="keyword">return</span> querysum(k); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> op;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> judge</span></span><br><span class="line">  freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i],a[i]%=mod;</span><br><span class="line">  init(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> x, y;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      <span class="comment">//(y+1)y/2</span></span><br><span class="line">      <span class="comment">//对[x,x+y-1]加上一个-1</span></span><br><span class="line">      <span class="keyword">int</span> l = x, r = min(x + y - <span class="number">1</span>, n);</span><br><span class="line">      addad(l, r, y, <span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; (a[x] + queryad(x)) % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.cnblogs.com/acmsong/p/7225903.html" target="_blank" rel="noopener external nofollow noreferrer">树状数组区间加等差数列</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
</search>
