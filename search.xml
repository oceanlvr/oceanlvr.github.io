<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>测试mathjax插件</title>
    <url>/2020/03/20/%E6%B5%8B%E8%AF%95mathjax%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\frac&#123;\partial u&#125;&#123;\partial t&#125;</span><br><span class="line">&#x3D; h^2 \left( \frac&#123;\partial^2 u&#125;&#123;\partial x^2&#125; +</span><br><span class="line">\frac&#123;\partial^2 u&#125;&#123;\partial y^2&#125; +</span><br><span class="line">\frac&#123;\partial^2 u&#125;&#123;\partial z^2&#125;\right)$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[\frac{\partial u}{\partial t}
= h^2 \left( \frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2} +
\frac{\partial^2 u}{\partial z^2}\right)\]</span></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\left[</span><br><span class="line">    \begin&#123;array&#125;&#123;cc|c&#125;</span><br><span class="line">      1&amp;2&amp;3\newline</span><br><span class="line">      4&amp;5&amp;6</span><br><span class="line">    \end&#123;array&#125;</span><br><span class="line">\right] </span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\left[
    \begin{array}{cc|c}
      1&amp;2&amp;3\newline
      4&amp;5&amp;6
    \end{array}
\right] 
\]</span></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">&#123;\mathcal L&#125;_&#123;cyc&#125;(G,F)&#x3D;&#123;\mathbb E&#125;_&#123;x \sim p_&#123;data&#125;(x)&#125;[&#123;\|F(G(x))-x\|&#125;_&#123;1&#125;]+&#123;\mathbb E&#125;_&#123;y \sim p_&#123;data&#125;(y)&#125;[&#123;\|G(F(y))-y\|&#125;_&#123;1&#125;]</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
{\mathcal L}_{cyc}(G,F)={\mathbb E}_{x \sim p_{data}(x)}[{\|F(G(x))-x\|}_{1}]+{\mathbb E}_{y \sim p_{data}(y)}[{\|G(F(y))-y\|}_{1}]
\]</span></p>
<p>测试一下功能：</p>
<p><span class="math display">\[e_r( x^{*}  ) = \frac{x-x^*}{x^*}\]</span> <span class="math display">\[\mathop{x} \limits_a^b\]</span> <span class="math display">\[e_r( x^{*}  ) = \frac{x-x^*}{x^*}\]</span> <span class="math display">\[a_x+b_x=c_x\]</span> <span class="math display">\[e\left ( x^{*} \right ) = x - x^{*}\]</span> <span class="math display">\[
\left| e \right|=\left | x-x^* \right |\leq \varepsilon
\]</span> <span class="math display">\[
\min_{\mathbf{w},b} \frac{1}{2} \Vert \mathbf{w} \Vert^2 \quad s.t. \quad y_i(\mathbf{w}^T\phi(\mathbf{x})+b) \geq 1, \quad  i=1,2,...,m\qquad(9)
\]</span> <span class="math display">\[
e\left ( x^{*} \right ) = x - x^{*}x = a_0 + \frac{1}{a_1 +\sqrt{a^2+b^2} \frac{1}{a_2 + \frac{1}{a_3 + a_4}}}\sqrt{a^2+b^2}
\]</span> <span class="math display">\[
f(n)=\begin{cases}
n/2, &amp; \text{如果$ x \leqslant 2 $}\\
3n+1, &amp; \text{如果$ x&gt;2 $}
\end{cases}
\]</span> <span class="math display">\[\max \limits_{a&lt;x&lt;b}\{f(x)\}\]</span> <span class="math display">\[
\beta^*(D) = \mathop{argmin} \limits_{\beta} \lambda {||\beta||}^2 + \sum_{i=1}^n max(0, 1 - y_i f_{\beta}(x_i)) 
\]</span></p>
<p><span class="math display">\[
\left(\begin{array}{c}s \\
  t\end{array}\right)=
\left(
    \begin{array}{cc}
      cos(b) &amp; -sin(b) \\
      sin(b) &amp; cos(b)
    \end{array}
\right)
\left(
    \begin{array}{c}
      x \\
      y
    \end{array}
\right)
\]</span></p>
]]></content>
      <tags>
        <tag>mathjax</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>支持区间修改的树状数组</title>
    <url>/2020/03/20/%E6%94%AF%E6%8C%81%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E7%9A%84%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="支持区间修改的树状数组">支持区间修改的树状数组</h1>
<p>能够在对数时间复杂度内支持区间修改的树状数组变种</p>
<h2 id="原理">原理</h2>
<p>对于一个数组<span class="math inline">\(a\)</span>，以及<span class="math inline">\(a\)</span>的差分<span class="math inline">\(c\)</span>，显然有</p>
<p><span class="math inline">\(c[i]=a[i]-a[i-1]\)</span></p>
<p>那么对于数组a的前缀和有</p>
<p><span class="math inline">\(\sum_{i=1}^n{a_i}=c[1]+(c[1]+c[2])+...(c[1]+c[2]+...+c[n])\)</span></p>
<p>进一步的：</p>
<p><span class="math inline">\(\sum_{i=1}^n{a_i}=c[1]*n+c[2]*(n-1)+...+c[n]*(n-n+1)\)</span></p>
<p>展开括号内</p>
<p><span class="math inline">\(\sum_{i=1}^n{a_i}=c[1]*n+c[2]*n+...+c[n]*n-(c[1]*(1-1)+c[2]*(2-1)+...+c[n]*(n-1))\)</span></p>
<p>即为</p>
<p><span class="math inline">\(\sum_{i=1}^n{a_i}=n*\sum_{i=1}^n{c[i]}-\sum_{i=1}^n{c[i]*(i-1)}\)</span></p>
<p>因此维护一个前缀和数组需要维护两个差分前缀和<span class="math inline">\(c[i]\)</span>和<span class="math inline">\((i-1)*c[i]\)</span>，对应为维护<span class="math inline">\(\sum_{i=1}^n{c[i]}\)</span>，<span class="math inline">\(\sum_{i=1}^n{(i-1)*c[i]}\)</span></p>
<p>这里使用两个树状数组对上述差分数组前缀和维护，分别命名为<span class="math inline">\(tr\)</span>和<span class="math inline">\(tr1\)</span>。</p>
<h2 id="实现">实现</h2>
<p>首先明确基本树状数组的两个基本操作：<strong>区间查询</strong>和<strong>单调查询</strong>。使用树状数组维护前缀和：</p>
<ol type="1">
<li>区间查询 <span class="math inline">\(\text{query}(k)\)</span>，1到k之间的前缀和<span class="math inline">\(\sum_{i=1}^k{a[i]}\)</span>。</li>
<li>单点修改 <span class="math inline">\(\text{add}(k,x)\)</span>, <span class="math inline">\(a[k]+=x\)</span>。</li>
</ol>
<p>那么对于本文中的<strong>支持区间修改</strong>的树状数组有以下操作：</p>
<p>1.<strong>区间修改</strong> <span class="math inline">\(\text{add}(l,r,k)\)</span>(l和r包含),等效于操作<span class="math inline">\(\text{add1(l,x)}\)</span>,<span class="math inline">\(\text{add1}(r+1,-x)\)</span>和<span class="math inline">\(\text{add2}(l,(l-1)*x)\)</span>,<span class="math inline">\(\text{add2}(r+1,r*(-x))\)</span>(差分性质定义)</p>
<p>2.区间查询 ,<span class="math inline">\(querysum(k)\)</span>,等效于操作<span class="math inline">\(k*\text{query1}(k)*k-\text{query2}(k)\)</span></p>
<h2 id="操作">操作</h2>
<h3 id="基本树状数组">基本树状数组</h3>
<p>实现了<span class="math inline">\(O(log(n))\)</span>单点修改和区间查询。 支持单点修改，区间查询，单点查询。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll tr[maxn];  <span class="comment">//树状数组1用于维护差分前缀和$\sum_&#123;i=1&#125;^n&#123;c[i]&#125;$</span></span><br><span class="line">ll tr1[maxn]; <span class="comment">//树状数组2用于维护差分前缀和$\sum_&#123;i=1&#125;^n&#123;(i-1)*c[i]&#125;$</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll tr[], <span class="keyword">int</span> l, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= n; i += lowbit(i)) tr[i] = (tr[i] + k) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll tr[], <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i -= lowbit(i)) res = (res + tr[i]) % mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化">初始化</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> nn)</span> </span>&#123;</span><br><span class="line">  n = nn + <span class="number">2</span>;<span class="comment">//防止空间越界</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) tr[i] = tr1[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间修改">区间修改</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//[l,r]区间修改+x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  add(tr, l, x);</span><br><span class="line">  add(tr, r + <span class="number">1</span>, -x);</span><br><span class="line">  add(tr1, l, <span class="number">1l</span>l * (l - <span class="number">1</span>) * x);</span><br><span class="line">  add(tr1, r + <span class="number">1</span>, <span class="number">1l</span>l * r * (-x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间查询">区间查询</h3>
<p>查询<span class="math inline">\(\sum_{i=1}^ka[i]\)</span>，即查询<span class="math inline">\([1,k]\)</span>内的前缀和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//区间查询原数组sum(a[1,k])</span></span><br><span class="line"><span class="function">ll <span class="title">querysum</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1l</span>l * query(tr, k) * k)  - query(tr1, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间修改-1">区间修改</h3>
<p>在<span class="math inline">\(a[l]...a[r]\)</span>区间加上<span class="math inline">\(x\)</span>. <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//[l,r]区间修改+x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  add(tr, l, x);</span><br><span class="line">  add(tr, r + <span class="number">1</span>, -x);</span><br><span class="line">  add(tr1, l, <span class="number">1l</span>l * (l - <span class="number">1</span>) * x);<span class="comment">//防止暴int</span></span><br><span class="line">  add(tr1, r + <span class="number">1</span>, <span class="number">1l</span>l * r * (-x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="复杂度分析">复杂度分析</h2>
<p>实质是两个树状数组来维护着差分前缀和，其中空间是3倍的区间长度,<span class="math inline">\(O(3*n)\)</span> 时间复杂度： 在以下操作均为<span class="math inline">\(O(log(n))\)</span>：</p>
<ul>
<li>区间同加x</li>
<li>区间查询</li>
<li>单点查询</li>
<li>单调同加x</li>
</ul>
<p>相比线段树空间复杂度<span class="math inline">\(O(4*n)\)</span>要小 时间复杂度相同。</p>
<p>编程复杂度差不多（<del>都好难orz</del>）</p>
<h2 id="整合模板">整合模板</h2>
<p><a href="https://acm.uestc.edu.cn/problem/qing-xue-jie-chong-mei-li-de-hua/description" target="_blank" rel="noopener external nofollow noreferrer">题目传送门</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">772002</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll tr[maxn];  <span class="comment">//树状数组1</span></span><br><span class="line">ll tr1[maxn]; <span class="comment">//树状数组2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll tr[], <span class="keyword">int</span> l, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= n; i += lowbit(i)) tr[i] = (tr[i] + k) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll tr[], <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i -= lowbit(i)) res = (res + tr[i]) % mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[l,r]区间修改+x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  add(tr, l, x);</span><br><span class="line">  add(tr, r + <span class="number">1</span>, -x);</span><br><span class="line">  add(tr1, l, <span class="number">1l</span>l * (l - <span class="number">1</span>) * x);</span><br><span class="line">  add(tr1, r + <span class="number">1</span>, (<span class="number">1l</span>l * r * (-x)%mod+mod)%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询原数组sum(a[1,k])</span></span><br><span class="line"><span class="function">ll <span class="title">querysum</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (((<span class="number">1l</span>l * query(tr, k) * k) % mod - query(tr1, k) % mod) % mod + mod) %</span><br><span class="line">         mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> nn)</span> </span>&#123;</span><br><span class="line">  n = nn + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) tr[i] = tr1[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//按题目要求区间[l,r]修改 [l+1,r]+d,[l,l]+a0,[r+1,r+1]-前面两个的和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addad</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a0, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  add(l, l, a0);                     <span class="comment">//单点l上+a0</span></span><br><span class="line">  <span class="keyword">if</span> (l + <span class="number">1</span> &lt;= r) add(l + <span class="number">1</span>, r, d);  <span class="comment">//区间[l+1,r] +d</span></span><br><span class="line">  add(r + <span class="number">1</span>, r + <span class="number">1</span>,</span><br><span class="line">      (-(a0 + (<span class="number">1l</span>l * (r - l) * d)) % mod + mod) % mod);  <span class="comment">//单点r+1 -前面两个的和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询原数组sum(a[1,k])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryad</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123; <span class="keyword">return</span> querysum(k); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> op;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> judge</span></span><br><span class="line">  freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i],a[i]%=mod;</span><br><span class="line">  init(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> x, y;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      <span class="comment">//(y+1)y/2</span></span><br><span class="line">      <span class="comment">//对[x,x+y-1]加上一个-1</span></span><br><span class="line">      <span class="keyword">int</span> l = x, r = min(x + y - <span class="number">1</span>, n);</span><br><span class="line">      addad(l, r, y, <span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; (a[x] + queryad(x)) % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://www.cnblogs.com/acmsong/p/7225903.html" target="_blank" rel="noopener external nofollow noreferrer">树状数组区间加等差数列</a></p>
]]></content>
      <tags>
        <tag>模板题</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
</search>
