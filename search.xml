<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>线性DP优化-方格取数</title>
    <url>/archives/acw1027.html</url>
    <content><![CDATA[<!-- build time:Fri Apr 03 2020 01:38:20 GMT+0800 (GMT+08:00) --><h1 id="线性dp优化方格取数">线性DP优化「方格取数」</h1><p>题目传送门 <a href="https://www.acwing.com/problem/content/1029/" target="_blank" rel="noopener external nofollow noreferrer">「1027. 方格取数」</a></p><p>题目大意：</p><p>给定一个矩阵，矩阵填写着正数，从左上角 (1,1) 走到右下角 (n,n) 所需的代价定义为经过的数字的和。</p><p>问从 (1,1) 走到 (n,n) <strong>两次</strong>所需的代价和?</p><a id="more"></a><h2 id="朴素线性dp做法">朴素线性DP做法</h2><p>若只跑一次则状态有两个 <code>[i][j]</code> 表示当前的位置。</p><p>若考虑两次求值，则有四个状态，分别为 <code>[i1][j1][i2][j2]</code>。</p><p>那么考虑如下状态转移：</p><p><img src="https://gitee.com/adameta/img/raw/master/1585848459_20200403000907363_2426.png"></p><p>注意到本题中说明第一次到达之后会抹除掉当前的数值，因此，如果当前的节点 <span class="math inline">\(i_1=i_2\)</span> 并且 <span class="math inline">\(j_1=j_2\)</span> ，即说明当前的节点有重合。</p><p>此时仅需要加一次数值即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> row, col, val;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; row &gt;&gt; col &gt;&gt; val, row || col || val) a[row][col] = val;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">1</span>; i1 &lt;= n; i1++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">1</span>; i2 &lt;= n; i2++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j1 = <span class="number">1</span>; j1 &lt;= n; j1++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">1</span>; j2 &lt;= n; j2++) &#123;</span><br><span class="line">          <span class="keyword">int</span> t = a[i1][j1];</span><br><span class="line">          <span class="keyword">if</span> (i1 != i2 &amp;&amp; j1 != j2) t += a[i2][j2];</span><br><span class="line">          f[i1][j1][i2][j2] = max(f[i1][j1][i2][j2], f[i1 - <span class="number">1</span>][j1][i2 - <span class="number">1</span>][j2]+t);</span><br><span class="line">          f[i1][j1][i2][j2] = max(f[i1][j1][i2][j2], f[i1 - <span class="number">1</span>][j1][i2][j2 - <span class="number">1</span>]+t);</span><br><span class="line">          f[i1][j1][i2][j2] = max(f[i1][j1][i2][j2], f[i1][j1 - <span class="number">1</span>][i2 - <span class="number">1</span>][j2]+t);</span><br><span class="line">          f[i1][j1][i2][j2] = max(f[i1][j1][i2][j2], f[i1][j1 - <span class="number">1</span>][i2][j2 - <span class="number">1</span>]+t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;f[n][n][n][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间优化">时间优化</h2><p>如何处理同一个格子不能重复备选？</p><p>排除 i1+j1 == i2+j2 的情况,只有这种情况下才可能路线重合</p><p>根据上文，若当前的第一次移动和第二次移动有重合。</p><p><strong>重合时必有</strong>：</p><p><span class="math display">\[ i_1=i_2 \]</span> <span class="math display">\[ j_1=j_2 \]</span> <span class="math display">\[ i_1+j_1=i_2+j_2 \]</span></p><p>因此，设 <span class="math inline">\(k=i_1+j_1=i_2+j_2\)</span> 。 此时枚举 <span class="math inline">\(i_1\)</span> <span class="math inline">\(i_2\)</span> 和 <span class="math inline">\(k\)</span> 即可。</p><p>我们期望找到重合在 <code>[n][n]</code> 上的两条线路的值最大。（<strong>此时必定有</strong> <span class="math inline">\(i_1+j_1=i_2+j_2\)</span> ）</p><p>因此，综上所述，选择从小到达枚举 <span class="math inline">\(k\)</span> <span class="math inline">\(i_1\)</span> <span class="math inline">\(i_2\)</span>。</p><p>状态表示如下：</p><p><img src="https://gitee.com/adameta/img/raw/master/1585848460_20200403012729638_20437.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn * <span class="number">2</span>][maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> row, col, val;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; row &gt;&gt; col &gt;&gt; val, row || col || val) a[row][col] = val;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= n + n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">1</span>; i1 &lt;= n; i1++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">1</span>; i2 &lt;= n; i2++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j1 = k - i1, j2 = k - i2;</span><br><span class="line">        <span class="keyword">if</span> (j1 &gt;= <span class="number">1</span> &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= <span class="number">1</span> &amp;&amp; j2 &lt;= n) &#123;</span><br><span class="line">          <span class="keyword">int</span> t = a[i1][j1];</span><br><span class="line">          <span class="keyword">if</span> (i1 != i2) t += a[i2][j2];  <span class="comment">//没有重合 即加 a[i1][j1] 和</span></span><br><span class="line">          a[i2][j2]</span><br><span class="line">          <span class="comment">//两条路的 4 种情况</span></span><br><span class="line">          f[k][i1][i2] = max(f[k][i1][i2], f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2 - <span class="number">1</span>] + t);</span><br><span class="line">          f[k][i1][i2] = max(f[k][i1][i2], f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2] + t);</span><br><span class="line">          f[k][i1][i2] = max(f[k][i1][i2], f[k - <span class="number">1</span>][i1][i2 - <span class="number">1</span>] + t);</span><br><span class="line">          f[k][i1][i2] = max(f[k][i1][i2], f[k - <span class="number">1</span>][i1][i2] + t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[n + n][n][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
        <category>线性DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 词法作用域</title>
    <url>/archives/js0327.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h2 id="词法作用域">词法作用域</h2><h3 id="词法阶段">词法阶段</h3><p>作用域有两种工作类型，一种是<strong>动态作用域</strong>（大多为脚本语言），一种是<strong>静态作用域</strong>。</p><p>在编译过程的词法阶段，是识别和解析单词的过程。</p><p>在词法阶段所产生的作用域叫做词法作用域。</p><a id="more"></a><p>而词法作用域是和<strong>块</strong>有关。</p><p>考虑以下代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( a, b, c );</span><br><span class="line">    &#125;</span><br><span class="line">    bar( b * <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure><p>有 3 个块作用域，分别是全局作用域，foo() 作用域和 bar() 作用域。</p><p>并且他们是<strong>逐级严格包含</strong>的。</p><p>而在查找的过程中，是采用从<strong>当前的执行代码所在块</strong>开始，逐级向外查找，直到找到匹配的标识符时停止，这就是<strong>遮蔽效应</strong>。</p><p>而当某个对象处于外层，但是内层也存在同名的变量时，想要访问外层变量该怎么做呢？</p><p>答案是使用<strong>全局对象 dot 变量名</strong>的方式。</p><p>例如当前作用域有一个变量为 a ，全局也有一个变量 a ，想要访问全局的 a 时，考虑使用 <code>window.a</code>。（ window 是全局对象 ）</p><p>这样的技术就可以任意访问任何作用域的变量了。</p><p>重点：无论函数在<strong>哪里</strong>被调用以及<strong>如何</strong>调用，函数的词法作用域都<strong>只由</strong>函数被声明时所处的位置决定。</p><h3 id="欺骗词法">欺骗词法</h3><p>在 JavaScript 中有两种主要的方法可以来欺骗词法作用域。</p><blockquote><p>欺骗词法作用域会导致性能下降</p></blockquote><h4 id="eval">eval</h4><p>JavaScript 中的 <code>eval(...)</code> 函数可以接受一个字符串作为参数，并且将其中的内容视为好像在书写时就存在于这个位置的代码。也就是在可以运行字符串其中的代码。</p><p>根据这个原理理解 <code>eval(...)</code> ，这样就可以在词法期间来修改环境。</p><p>在执行 eval 代码时，引擎并不知道前面的代码被动态地插入进去，并且对词法作用域进行了修改。引擎只会照常地向外查找变量。</p><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str , a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>( str );<span class="comment">//发生欺骗 相当于 var b = 3;</span></span><br><span class="line">    <span class="built_in">console</span>.log( a, b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo( <span class="string">"var b = 3;"</span>, <span class="number">1</span> );<span class="comment">//1, 3</span></span><br></pre></td></tr></table></figure><p>在这个例子中，b 的值是采用 str 字符串中的代码。</p><p>因为 <code>eval</code> 会像执行其他代码一样执行字符串参数。</p><p>所以，在上述例子中，相当于在执行语句 <code>var b = 3;</code>。在发生 b 的变量查询时就会查找到 foo 作用域内的 b 而不是全局作用域的 b 。</p><p>即发生了「欺骗」。</p><p>这样动态的执行静态的代码（例子中的赋值为 3 是静态的）并不是好的实践，比直接写静态的代码效率低</p><blockquote><p>严格模式下，eval有自己的词法作用域，也就意味着无法影响其中声明所在的语法作用域</p></blockquote><p>在实际场景中，少使用动态生成代码，否则会大大影响性能。</p><h4 id="with">with</h4><p>with 通常被视作引用同意对象的多个属性快捷方式，而不需要重复引用该对象。</p><p>考虑下面代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化变量</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">obj.b = <span class="number">3</span>;</span><br><span class="line">obj.c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// with 写法</span></span><br><span class="line"><span class="keyword">with</span>(obj) &#123;</span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line">    c = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>但是 <code>with</code> 有点奇怪的特性。</p><p><code>with</code> 会创建一个新的语法作用域，并将其变量的语法作用域设置为 <strong>with 外</strong>。这样会引发一些词法作用域修改问题。</p><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span>(obj) &#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// with 内变量 a 的作用域,a 和 with所处的作用域相同</span></span><br><span class="line">  <span class="comment">// 由于对象 o2 没有 a属性</span></span><br><span class="line">  <span class="comment">// 并且 a 和 obj 都是处于 foo 函数区域中</span></span><br><span class="line">  <span class="comment">// 因此导致 a 的下一次寻找会到全局作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">  b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo(o1);</span><br><span class="line"><span class="built_in">console</span>.log(o1.a);</span><br><span class="line"></span><br><span class="line">foo(o2);</span><br><span class="line"><span class="built_in">console</span>.log(o2.a);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//2 -&gt; 发生了作用域泄露</span></span><br></pre></td></tr></table></figure><p>当执行 <code>foo(o2)</code> 时，发现传进当前创建的 with 词法作用域中没有 a 变量，于是向外寻找到全局作用域，发现也没有。</p><p>因此，在<strong>全局作用域</strong>就地创建了一个变量 a ，导致变量外泄，而不是让 a 乖乖地保存在 o2 对象中。</p><p><del>（根本原因是产生了新的作用域 with ，并且把新的变量放在和自己所在的作用域相同的位置，而不是在 o2 作用域<strong>内</strong>就地修改）</del></p><p>with 本质上是通过把一个对象的引用当作作用域来处理，将对象的属性当作作用域的标识符来处理，从而创建了一个新的词法作用域。</p><h4 id="性能问题">性能问题</h4><p>eval 和 with 这些使得作用域动态改变的做法都应该制止！会使得代码的运行变得很慢（因为是动态的，所以优化起来很棘手，具有不确定性）</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScript</tag>
        <tag>「你不知道的 JavaScript」</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 作用域</title>
    <url>/archives/js0326.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h2 id="作用域">作用域</h2><p>本文是由「你不知道的JavaScript」整理得的读书笔记。</p><h3 id="编译原理">编译原理</h3><p>JavaScript 的编译过程经过了</p><ol type="1"><li>词法分析</li><li>语法分析</li><li>代码生成</li></ol><p>三个阶段。</p><p>JavaScript 是一门动态语言，同时也是一门编译语言，和其他语言不同的是 JavaScript 不是<strong>提前</strong>编译的，而是即时编译，即在引擎执行代码之前时立即编译，编译的结果不可以在不同机器之间移植。</p><a id="more"></a><h3 id="作用域-1">作用域</h3><p>首先先明确编译过程中的参与者：</p><ul><li>引擎，从头到尾复杂 JavaScript 程序的编译和执行过程。</li><li>编译器，负责语法分析和代码生成。</li><li>作用域，负责收集和维护所有声明的标识符组成的一些列查询，以此确定标识符的访问权限。</li></ul><p>引入一段代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>该代码在引擎处理时，被认为是两个完全不同的声明，一个是由编译器编译的时候处理，另一个是在引擎运行时处理。</p><p>编译器处理该段代码的方式：</p><ol type="1"><li>遇到 var a，编译器会发出询问，当前作用域是否有一个该名称的变量，若是，则忽略声明继续编译。否则在当前的作用域中申请一个新的变量命名为 a 。</li><li>编译器生成引擎运行时所需的代码，该代码是用来处理 a = 2 这个赋值操作。会采用作用域查找机制寻找是否有一个变量 a 。</li><li>执行动作。<ol type="1"><li>若找到，则使用这个变量，将值 2 赋予它。</li><li>否则想引擎抛出异常。</li></ol></li></ol><h3 id="作用域查询">作用域查询</h3><p>上文提到，在声明过程中，会对变量进行以一次作用域查询，查找 a 是否已经在作用域中出现过。</p><p>关于作用域查询，这里进一步说明。</p><p>作用域查询分为两种：</p><ul><li>LHS 查询</li><li>RHS 查询</li></ul><p>很直观的，对于一段赋值语句，可以理解为。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = b;</span><br></pre></td></tr></table></figure><ul><li>对赋值操作 <code>=</code> 左边的变量 a <strong>容器</strong>的查询叫 LHS 查询（ Left Hand Side ）</li><li>对赋值操作 <code>=</code> 右边的变量的<strong>值</strong>的查询 b 叫 RHS 查询（ Right Hand Side ）</li></ul><p>其中值得注意的是，和正常的理解不一样，不能把函数当作一个变量，在引擎处理函数的时候并不会为函数分配容器，因此对于函数的调用实际上是一个 RHS 查询，如果调用的不是函数类型的值则会引发错误。</p><p>看书中给出的以下例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure><p>其中的 LHS 查询有:</p><ul><li>a=2 //隐式</li><li>var b</li><li>var c</li></ul><p>RHS 查询有：</p><ul><li>foo( ... )</li><li>b = a</li><li>a ...</li><li>...b</li></ul><p>这样变量之间的赋值操作实质上就是在交替地做 LHS 和 RHS 查询。</p><h3 id="作用域嵌套">作用域嵌套</h3><p>作用域是一套用于管理变量的一套规则。</p><p>当块或者函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套。</p><p>而根据我们的一般经验，一个变量在当前的作用域找不到时，就应该到外层的作用域中寻找。直到找到该变量。</p><p>比如下面的例子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>在执行的过程中并不会报错（如果换做是 cpp 就会发生找不到变量的错误）。</p><p>这是因为 JavaScript 独特的作用域管理机制。</p><p>JavaScript 的作用域链规则：当引擎当前的执行作用域开始查找该变量，如果没有找到，就继续向外（上一层）寻找。当到达全局作用域时，即停止。（没有找到即报错）</p><p>因此，可以把作用域可视化为：</p><p><img src="https://gitee.com/adameta/img/raw/master/1585227489_20200326203324947_4431.png"></p><p>在每次进行 LHS 和 RHS 查询时，都是在当前的作用域查询，若没有查询到，就会向外进行跨越到更大的作用域。</p><h3 id="异常">异常</h3><p>对于上文引入的两种查询的意义？</p><p>在 JavaScript 的宽松/懒惰模式下，若进行的是 LHS 查询，如果一直到全局作用域也无法找到变量，那么引擎就会为其在<strong>全局作用域</strong>创造一个该变量。</p><p>如果是在严格模式下，若到全局作用域也无法找到，则是抛出一个 <code>ReferenceError</code> 异常。</p><p>而在进行 RHS 查询成功之后，若对得到的值进行非法操作，比如：对非函数值进行函数调用操作（例如 a 是一个变量，但是使用 a() 对其调用）就会抛出一个 <code>TypeError</code> 异常。</p><p>两种异常的总结：</p><ul><li><code>ReferenceError</code> 异常是与作用域判别失败有关</li><li><code>TypeError</code> 异常是在作用域判别正确之后，进行了非法的操作</li></ul><h3 id="作用域小结">作用域小结</h3><p>作用域是一套用于查找变量的位置的规则。</p><p>如果查找的目标是要对其进行赋值操作，那就是 LHS 查询。</p><p>如果查找的目标的值，那么就是 RHS 查询。</p><p>尤其需要注意，函数的形式参数的传递是涉及到隐式的赋值操作的。</p><p>在 JavaScript 中，对语句 <code>var a = 2</code> 这样的声明实际是被拆分为两个部分。</p><ul><li>一个部分是 <code>var a</code> ，发生在代码执行前，用于申明该作用域下的变量 a</li><li>之后是 <code>a = 2</code> ，发生在运行时，动作是对 a 做 LHS 查询，并且把 2 赋值给 a</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScript</tag>
        <tag>「你不知道的 JavaScript」</tag>
      </tags>
  </entry>
  <entry>
    <title>背包入门</title>
    <url>/archives/extra03251.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h1 id="背包">背包</h1><p>给出背包入门题以及代码。</p><a id="more"></a><h2 id="背包-1">01背包</h2><p>给定<span class="math inline">\(N\)</span>个物品和容量是<span class="math inline">\(V\)</span>的背包，以及N个物体的<span class="math inline">\(v_i\)</span>和<span class="math inline">\(w_i\)</span>，每个物体只有一件。</p><p>挑选一些物体，使得总体积小于等于V，目标是使得总价值最大，问最大价值是多少？</p><p><img src="https://gitee.com/adameta/img/raw/master/1582739291_20200226204804550_31266.png"></p><p>模板：<a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener external nofollow noreferrer">01背包</a></p><h3 id="朴素写法">朴素写法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> v[maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &lt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = max(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[n][V];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滚动数组优化空间">滚动数组优化空间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> v[maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">    for (int j = V; j &lt;= 0; j--) &#123;</span></span><br><span class="line"><span class="comment">      f[i][j] = f[i - 1][j];</span></span><br><span class="line"><span class="comment">      if (j &gt;= v[i]) f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v[i]; j--) f[j] = max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[V];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包">完全背包</h2><p>给定<span class="math inline">\(N\)</span>个物品和容量是<span class="math inline">\(V\)</span>的背包，以及N个物体的<span class="math inline">\(v_i\)</span>和<span class="math inline">\(w_i\)</span>。每个物体有无限多件。</p><p>挑选一些物体，使得总体积小于等于<span class="math inline">\(V\)</span>，目标是使得总价值最大，问最大价值是多少？</p><p><img src="https://gitee.com/adameta/img/raw/master/1582739315_20200226214542240_9580.png"></p><h3 id="朴素写法-1">朴素写法</h3><p>暴力做法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k++)</span><br><span class="line">        f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - v[i] * k] + w[i] * k);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="时间优化">时间优化</h3><p>在枚举<span class="math inline">\(k\)</span>时做时间优化。</p><p>因为在对k进行枚举时有： <span class="math inline">\(f[i][j]=max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v]+2w,...,f[i-1][j-kv]+kw)\)</span></p><p><span class="math inline">\(\text{1:}f[i][j]=max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v]+2w,...,f[i-1][j-kv]+kw)\)</span></p><p><span class="math inline">\(\text{2:}f[i][j-v]=max( f[i-1][j-v],f[i-1][j-2v]+w,f[i-1][j-kv]+(k-1)w)\)</span></p><p>式子2中每一项都和式子1中从第二项开始的每一项<strong>相差1个w</strong>,那么就有:</p><p>完全背包的方程被<strong>优化</strong>为：<span class="math inline">\(f[i][j] = max(f[i][j-v]+w,f[i-1][j])\)</span></p><p>尤其注意以下细节：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=V; j++)&#123;<span class="comment">//正确</span></span><br><span class="line">    <span class="comment">// for(int j=V;j&gt;= v[i];j--)&#123;//错误</span></span><br><span class="line">    <span class="comment">//错误的写法，因为f[i][j-v]在f[i][j]前面</span></span><br><span class="line">    <span class="comment">//因此必须等f[i][j-v]更新之后才能更新f[i][j]</span></span><br><span class="line">      f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">      <span class="keyword">if</span>(j&gt;=v[i])  f[i][j]=max(f[i][j-v[i]]+w[i],f[i][j]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> w[maxn], v[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//------------------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment">/*时间优化-&gt;优化枚举k,因为</span></span><br><span class="line"><span class="comment">    1. f[i][j]      =max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2*v]+2*w,...,f[i-1][j-k*v]+k*w);</span></span><br><span class="line"><span class="comment">    2. f[i][j-v]   =max(            f[i-1][j-v],     f[i-1][j-2*v]+*w,...,f[i-1][j-k*v]+(k-1)*w);</span></span><br><span class="line"><span class="comment">    综合1和2 f[i][j]=max(f[i-1][j],f[i][j-v]+w); 其中v是v_i，w是w_i</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=V; j++)&#123;</span><br><span class="line">    <span class="comment">// for(int j=V;j&gt;= v[i];j--)&#123;</span></span><br><span class="line">    <span class="comment">//错误的写法，因为f[i][j-v]在f[i][j]前面</span></span><br><span class="line">    <span class="comment">//因此必须等f[i][j-v]更新之后才能更新f[i][j]</span></span><br><span class="line">      f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">      <span class="keyword">if</span>(j&gt;=v[i])  f[i][j]=max(f[i][j-v[i]]+w[i],f[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//滚动数组优化</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[n][V];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空间优化">空间优化</h3><p>对于上述的方程：<span class="math inline">\(f[i][j] = max(f[i][j-v]+w,f[i-1][j])\)</span></p><p>观察方程<span class="math inline">\(f[i][j]\)</span>可能是由<span class="math inline">\(f[i][j-v[i]]\)</span>转移过来，并且之前的状态一定是在上一行的前面位置。</p><p>因此，可以得知<span class="math inline">\(j-v\)</span>一定是在前面的数字情况，因此优化为1维的时候，前面的情况一定是上一个维度的。</p><p>优化空间的步骤,将阶段那一维度删除：即将i删除。</p><p>随后对代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = v[i]; j &lt;=V; j++)&#123;</span><br><span class="line">     f[j]=max(f[j-v[i]]+w[i],f[j]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="整合">整合：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> w[maxn], v[maxn];</span><br><span class="line"><span class="comment">// int f[maxn][maxn];</span></span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//朴素的完全背包</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">    for (int j = V; j &gt;= 0; j--) &#123;</span></span><br><span class="line"><span class="comment">      f[i][j] = f[i - 1][j];</span></span><br><span class="line"><span class="comment">      for (int k = 0; k * v[i] &lt;= j; k++)</span></span><br><span class="line"><span class="comment">        f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment">/*时间优化-&gt;优化枚举k,因为</span></span><br><span class="line"><span class="comment">    1. f[i][j]      =max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2*v]+2*w,...,f[i-1][j-k*v]+k*w);</span></span><br><span class="line"><span class="comment">    2. f[i][j-v]   =max(            f[i-1][j-v],     f[i-1][j-2*v]+*w,...,f[i-1][j-k*v]+(k-1)*w);</span></span><br><span class="line"><span class="comment">    综合1和2 f[i][j]=max(f[i-1][j],f[i][j-v]+w); 其中v是v_i，w是w_i</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">    for (int j = 0; j &lt;=V; j++)&#123;</span></span><br><span class="line"><span class="comment">    // for(int j=V;j&gt;= v[i];j--)&#123;</span></span><br><span class="line"><span class="comment">    //错误的写法，因为f[i][j-v]在f[i][j]前面</span></span><br><span class="line"><span class="comment">    //因此必须等f[i][j-v]更新之后才能更新f[i][j]</span></span><br><span class="line"><span class="comment">      f[i][j]=f[i-1][j];</span></span><br><span class="line"><span class="comment">      if(j&gt;=v[i])  f[i][j]=max(f[i][j-v[i]]+w[i],f[i][j]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//滚动数组优化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v[i]; j &lt;=V; j++)&#123;</span><br><span class="line">      f[j]=max(f[j-v[i]]+w[i],f[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// cout &lt;&lt; f[n][V];</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[V];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包">多重背包</h2><p>给定<span class="math inline">\(N\)</span>个物品和容量是<span class="math inline">\(V\)</span>的背包，以及N个物体的<span class="math inline">\(v_i\)</span>和<span class="math inline">\(w_i\)</span>。<strong>每个物体有<span class="math inline">\(s_i\)</span>件。</strong></p><p>挑选一些物体，使得总体积小于等于V，目标是使得总价值最大，问最大价值是多少？</p><p><img src="https://gitee.com/adameta/img/raw/master/1582739332_20200227002757507_11990.png"></p><h3 id="朴素写法-2">朴素写法</h3><p>暴力做法<span class="math inline">\(O(n^2)\)</span></p><p><a href="https://www.acwing.com/problem/content/4/" target="_blank" rel="noopener external nofollow noreferrer">暴力多重背包</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> s[maxn], v[maxn], w[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">      f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= s[i]; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= k * v[i]) &#123;</span><br><span class="line">          f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[n][V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优化时间">优化时间</h3><p>时间优化： 思路1：<strong>单调队列优化</strong>多重背包 <a href="https://zhuanlan.zhihu.com/p/47238538" target="_blank" rel="noopener external nofollow noreferrer">背包问题 (附单调队列优化多重背包)</a></p><p>思路2：<strong>倍增</strong>的思想，<strong>把多重背包转为01背包</strong>，使用二进制对<span class="math inline">\(s[i]\)</span>里面的数字范围打包：</p><p><img src="https://gitee.com/adameta/img/raw/master/1582739337_20200227005828375_30599.png"></p><p><img src="https://gitee.com/adameta/img/raw/master/1582739341_20200227012510926_23467.png"></p><p>用倍增的思想对同一物体进行打包之后物体的数目从<span class="math inline">\(S\)</span>变为了<span class="math inline">\(lgS\)</span>。因此时间复杂度由原来的<span class="math inline">\(O(NSV)\)</span>变为<span class="math inline">\(O(NV\text{lg}V)\)</span>。</p><p>建议看下『算法竞赛进阶指南』这本书上讲解倍增思想的部分。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e4</span> + <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> v[maxn], w[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//打包后的物体的编号</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*倍增的思想多多重背包打包，转为01背包*/</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt;= s) &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      <span class="comment">//将这k个物体打包成一个物体，编号为cnt</span></span><br><span class="line">      v[cnt] = a * k;</span><br><span class="line">      w[cnt] = b * k;</span><br><span class="line">      s -= k;</span><br><span class="line">      k &lt;&lt;= <span class="number">1</span>;  <span class="comment">//倍增</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s) &#123;</span><br><span class="line">      <span class="comment">//此时还剩下没有够2^&#123;k+1&#125;个的单位</span></span><br><span class="line">      <span class="comment">//单独补上为一个物体</span></span><br><span class="line">      cnt++;</span><br><span class="line">      v[cnt] = a * s;</span><br><span class="line">      w[cnt] = b * s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  n = cnt;  <span class="comment">//更新为01背包的大小</span></span><br><span class="line">  <span class="comment">//打包之后的多重背包转化为01背包</span></span><br><span class="line">  <span class="comment">//此时直接做01背包相同的操作即可</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v[i]; j--) &#123;</span><br><span class="line">      f[j] = max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组背包问题">分组背包问题</h2><p>将物品分为<span class="math inline">\(N\)</span>组，每个组有若干个物体，给定若干物体的价值<span class="math inline">\(w_i\)</span>。每组只能选一个物体（组内是互斥的）。</p><p>问有背包的价值最大是多少？</p><p><a href="https://www.acwing.com/problem/content/9/" target="_blank" rel="noopener external nofollow noreferrer">分组背包问题</a></p><p><img src="_v_images/20200227154431398_24971.png"></p><h3 id="朴素写法-3">朴素写法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//第i组的第j个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> v[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> nn;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn;</span><br><span class="line">    v[i][<span class="number">0</span>] = nn;  <span class="comment">//记录数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nn; j++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//朴素写法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= v[i][<span class="number">0</span>]; k++) &#123;</span><br><span class="line">        f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j]);</span><br><span class="line">        <span class="keyword">if</span> (j - v[i][k] &gt;= <span class="number">0</span>)</span><br><span class="line">          f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - v[i][k]] + w[i][k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[n][V] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="空间优化-1">空间优化</h3><p>滚动数组空间优化： 对于分组背包的空间优化意义不太大，因为本身存储<span class="math inline">\(v\)</span>和<span class="math inline">\(w\)</span>就已经是二维的空间花销了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//第i组的第j个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> v[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> nn;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn;</span><br><span class="line">    v[i][<span class="number">0</span>] = nn;  <span class="comment">//记录数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nn; j++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//空间优化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= v[i][<span class="number">0</span>]; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j - v[i][k] &gt;= <span class="number">0</span>)</span><br><span class="line">          f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[V] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="综合">综合</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//第i组的第j个物品的体积和价值</span></span><br><span class="line"><span class="keyword">int</span> v[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn][maxn];</span><br><span class="line"><span class="comment">// int f[maxn][maxn];</span></span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> nn;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn;</span><br><span class="line">    v[i][<span class="number">0</span>] = nn;  <span class="comment">//记录数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nn; j++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*朴素写法</span></span><br><span class="line"><span class="comment">  for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">    for (int j = 0; j &lt;= V; j++) &#123;</span></span><br><span class="line"><span class="comment">      for (int k = 0; k &lt;= v[i][0]; k++) &#123;</span></span><br><span class="line"><span class="comment">        f[i][j] = max(f[i][j], f[i - 1][j]);</span></span><br><span class="line"><span class="comment">        if (j - v[i][k] &gt;= 0)</span></span><br><span class="line"><span class="comment">          f[i][j] = max(f[i][j], f[i - 1][j - v[i][k]] + w[i][k]);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//空间优化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= v[i][<span class="number">0</span>]; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j - v[i][k] &gt;= <span class="number">0</span>)</span><br><span class="line">          f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1083二分答案+差分</title>
    <url>/archives/luogu1083.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h1 id="洛谷p1083-二分答案差分">洛谷P1083 二分答案+差分</h1><p>算法关键词：二分答案、差分</p><h2 id="题目描述">题目描述</h2><p>题目传送门『<a href="https://www.luogu.com.cn/problem/P1083" target="_blank" rel="noopener external nofollow noreferrer">P1083 借教室</a>』</p><p>数据范围：<span class="math inline">\(1\leq n,m\leq10^6\)</span> 题目意思：给定长度为 <span class="math inline">\(n\)</span> 的数组，和 <span class="math inline">\(m\)</span> 次询问，每次询问把数组 <span class="math inline">\([l,r]\)</span> 减去 <span class="math inline">\(d\)</span> ，问第几次询问能够使得数组能够存在小于 0 的数。</p><a id="more"></a><h2 id="朴素">朴素</h2><p>朴素做法:对当前 <span class="math inline">\(1..n\)</span> 对每个询问区间做修改(闭区间 <span class="math inline">\([l,r]\)</span> 同时减去 <span class="math inline">\(d\)</span> )，同时扫描当前区间长度 <span class="math inline">\([1,n]\)</span> 是否出现 <span class="math inline">\(a[i]\leq0\)</span> 。</p><p>不难分析时间复杂度是 <span class="math inline">\(O(nm)\)</span> ,而 <span class="math inline">\((10^6)^2&gt;&gt;10^7\)</span> 必然超时。观察数据 <span class="math inline">\(1e6\)</span> 的数据考虑 <span class="math inline">\(nlgn\)</span> 做法。</p><h2 id="二分答案和差分思想">二分答案和差分思想</h2><p>时间复杂度 <span class="math inline">\(O(\text{log}(m)*(n+m))\)</span></p><h3 id="具有二段性">具有二段性</h3><p>本题关键是如果第 <span class="math inline">\(k\)</span> 个答案是不符合要求的，那么后面的都肯定不符合要求（后面减去上一些数，肯定也是小于0的）。即答案具有二段性。</p><p>我们需要找到一个临界点，<strong>在这个临界点区间某个点下一次会被减到负数</strong>，而该点后面都是<strong>不满足的情况</strong>。</p><p>因此，我们需要实现一个函数<code>check(m)</code>，使得询问当前这个点<span class="math inline">\(m\)</span>是符合的（如果区间每一个数都是小于原来数组的那么是符合的），并且<strong>通过二分找到这个符合点的最右端点</strong> <span class="math inline">\(k\)</span> 。</p><p><img src="https://gitee.com/adameta/img/raw/master/1583338613_20200305000104121_17444.png"></p><h3 id="差分思想优化区间修改的过程">差分思想优化区间修改的过程</h3><p>再次发现，每一次再修改一个区间都是同时加上或者减去某个数，最后会询问当前这个答案m下，是否是符合的，属于离线修改区间，可以考虑使用差分思想。</p><p>方法是对于 <span class="math inline">\([l,r]\)</span> 加上<span class="math inline">\(d\)</span>实质上是对于差分数组<span class="math inline">\(p\)</span>做<span class="math inline">\(p[l]+d\)</span>,<span class="math inline">\(p[r+1]-d\)</span>。</p><p>即为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">  q[s[i]] += d[i];</span><br><span class="line">  q[t[i] + <span class="number">1</span>] -= d[i];<span class="comment">//做差分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>最后对差分数组q求前缀和：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) q[i] = q[i] + q[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>这样即可在<span class="math inline">\(O(n+m)\)</span>的时间复杂度内得到修改后的数组。<p></p><p>而暴力是需要<span class="math inline">\(O(m*n)\)</span>的时间复杂度。</p><h3 id="二分答案过程使用差分思想优化后的时间复杂度">二分答案过程使用差分思想优化后的时间复杂度</h3><p>因为总共有<span class="math inline">\(m\)</span>次询问，二分<span class="math inline">\([1,m]\)</span>区间总共是<span class="math inline">\(O(\text{log}(m))\)</span>次</p><p>而每一次是使用差分优化，差分时间复杂度是<span class="math inline">\(O(n+m)\)</span>，因此时间复杂度是<span class="math inline">\(O(\text{log}(m)*(n+m))\)</span>，综上比暴力<span class="math inline">\(O(nm)\)</span>快得多。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://www.luogu.com.cn/problem/P1083</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll q[maxn];</span><br><span class="line">ll d[maxn], s[maxn], t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="keyword">sizeof</span> q);</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>, r = idx;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">    q[s[i]] += d[i];</span><br><span class="line">    q[t[i] + <span class="number">1</span>] -= d[i];<span class="comment">//做差分</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//对差分做前缀和 得到最后m次修改之后的数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) q[i] = q[i] + q[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (q[i] &gt; a[i]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//满足分配条件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">cin</span> &gt;&gt; d[i] &gt;&gt; s[i] &gt;&gt; t[i];</span><br><span class="line">  <span class="comment">//时间复杂度O(lg(m)*(m+n))</span></span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>, r = m;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (check(mid)) &#123;  <span class="comment">//满足分配</span></span><br><span class="line">      l = mid;         <span class="comment">//试图找不满足</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r == m) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (check(r)) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; r + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//一个都不满足 此时r=1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
        <category>线性DP</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>离散化区间</title>
    <url>/archives/luogu2070.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h1 id="洛谷p2070-离散化区间">洛谷P2070 离散化区间</h1><p>『题目传送门』：<a href="https://www.luogu.com.cn/problem/P2070" target="_blank" rel="noopener external nofollow noreferrer">P2070 刷墙</a></p><p><a href="https://www.zhaohaikun.cn/2020/02/10/ti-jie-p2070-shua-qiang/" target="_blank" rel="noopener external nofollow noreferrer">『思路1 题解原链接』</a></p><a id="more"></a><h2 id="题目">题目：</h2><p>题目大意：给定<span class="math inline">\(n\)</span>个区间<span class="math inline">\([l,r]\)</span>其中区间的长度<span class="math inline">\(1\leq l,r\leq 1e^9\)</span>，要求给出区间相交数大于2的区间长度。 例如模拟给定的样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2 R</span><br><span class="line">6 L</span><br><span class="line">1 R</span><br><span class="line">8 L</span><br><span class="line">1 R</span><br><span class="line">2 R</span><br></pre></td></tr></table></figure><h2 id="思路1-思维题分情况考虑离散化对区间考虑">思路1 思维题：分情况考虑离散化（对区间考虑）</h2><p>说实话这个有点难弄清，需要细细的思考。</p><p><img src="https://gitee.com/adameta/img/raw/master/1583389332_20200305133650445_5086.png"></p><p>思路：从小到达扫描区间，维护一个可能发生重叠的区间【L,R】，在当前维护的区间的右边寻找一个区间【a[i].l,a[i].r】</p><p>使得当前的可能区间更新: 分为两种情况：（对应到图右上角的1和2）</p><ol type="1"><li>查询的区间的右端点是小于当前维护区间的右端点的，那么把【当前维护区间的左端点，当前查询区间的右端点】这一区间加入到重复区间长度计算中。并且试图在【当前查询区间的右端点，当前维护区间的右端点】寻找下一个可能的重复区间。</li><li>查询的区间的右端点是大于当前维护区间的右端点的，那么把【当前维护区间的左端点，当前维护区间的右端点】这一区间加入到重复区间长度计算中。并且试图在【当前维护区间的右端点，当前查询区间的右端点】寻找下一个可能的重复区间</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> dir;</span><br><span class="line">ll l, r;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;ll, ll&gt;&gt; alls;</span><br><span class="line">ll res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; dir;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="string">"R"</span>)</span><br><span class="line">      r = l + r;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      r = l - r;</span><br><span class="line">    ll tl, tr;</span><br><span class="line">    tl = min(l, r), tr = max(l, r);</span><br><span class="line">    alls.push_back(make_pair(tl, tr));</span><br><span class="line">    l = r;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(alls.begin(), alls.end());</span><br><span class="line">  <span class="comment">//找它区间后面左端点小于右端点并且右端点最右边的点</span></span><br><span class="line">  ll lft = alls[<span class="number">0</span>].first;</span><br><span class="line">  ll rgt = alls[<span class="number">0</span>].second;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (alls[i].second &gt; lft) &#123;  <span class="comment">//至少是有意义的区间（可能的区间至少是大于1的）</span></span><br><span class="line">      <span class="comment">//缩小左边的区间</span></span><br><span class="line">      alls[i].first = max(alls[i].first, lft);</span><br><span class="line">      <span class="comment">//【alls[i].first,alls[i].second】</span></span><br><span class="line">      <span class="comment">//【lft          ,rgt           】</span></span><br><span class="line">      <span class="keyword">if</span> (alls[i].second &gt; rgt) &#123;    <span class="comment">//比之前的右端点大全部覆盖</span></span><br><span class="line">        res += rgt - alls[i].first;  <span class="comment">//求公共区间</span></span><br><span class="line">        lft = rgt;  <span class="comment">//接下来有可能的区间是[rgt,alls[i].second]</span></span><br><span class="line">        rgt = alls[i].second;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;                                  <span class="comment">//比之前的右端点小</span></span><br><span class="line">        res += alls[i].second - alls[i].first;  <span class="comment">//求公共区间</span></span><br><span class="line">        lft = alls[i].second;  <span class="comment">//接下来可能的区间是[alls.second,rgt]</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路2离散化差分对点考虑">思路2：离散化+差分（对点考虑）</h2><p>对于一个区间【L,R】每出现一次，就相当于在<code>a[l]+=1,a[r+1]-=1;</code></p><p>那么就显而易见的，直接对区间的左右端点左修改，<span class="math inline">\(m\)</span>次查询即完成了相应的修改，最后从小到大扫描所有的区间，若进入区间左端点后当前的差分值从1变为了2即开始进入到多个区间重合的区域，从2变到1即退出重合的区域。如下图</p><p><img src="https://gitee.com/adameta/img/raw/master/1583389335_20200305141148224_18623.png"></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> dir;</span><br><span class="line">ll l, r;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; point;</span><br><span class="line">ll res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; dir;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="string">"R"</span>)</span><br><span class="line">      r = l + r;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      r = l - r;</span><br><span class="line">    ll tl, tr;</span><br><span class="line">    tl = min(l, r), tr = max(l, r);</span><br><span class="line">    point.push_back(make_pair(tl, <span class="number">1</span>));</span><br><span class="line">    point.push_back(make_pair(tr, <span class="number">-1</span>));</span><br><span class="line">    l = r;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(point.begin(), point.end());</span><br><span class="line">  <span class="keyword">int</span> old = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; point.size(); i++) &#123;</span><br><span class="line">    old = sum;</span><br><span class="line">    sum += point[i].second;</span><br><span class="line">    <span class="keyword">if</span> (old == <span class="number">1</span> &amp;&amp; sum == <span class="number">2</span>) l = point[i].first;</span><br><span class="line">    <span class="keyword">if</span> (old == <span class="number">2</span> &amp;&amp; sum == <span class="number">1</span>) res += point[i].first - l;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>离散化</category>
      </categories>
      <tags>
        <tag>离散化</tag>
        <tag>区间题</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie+贪心策略求数组最大异或对</title>
    <url>/archives/acw835.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h1 id="trie">Trie</h1><p>Trie：高效存储和查找字符串集合的数据结构<a id="more"></a></p><figure><img src="https://gitee.com/adameta/img/raw/master/1583497809_20200211234256862_15978.png" alt="1"><figcaption>1</figcaption></figure><p>对于单词来说使用标记来注明。</p><p><strong>高效的查找前缀单词是否存在</strong></p><h2 id="模板">模板</h2><p><a href="https://www.acwing.com/problem/content/837/" target="_blank" rel="noopener external nofollow noreferrer">acwing 835</a></p><h3 id="题目">题目</h3><p>维护一个字符串集合，支持两种操作：</p><p>“I x”向集合中插入一个字符串x；</p><p>“Q x”询问一个字符串在集合中出现了多少次。</p><p>共有N个操作，输入的字符串总长度不超过 10e5，字符串仅包含小写英文字母。</p><h3 id="分析">分析</h3><p>如果使用朴素做法，那么每一次查询都需要对前<span class="math inline">\(n\)</span>个字符串求前缀匹配，而比较快速的前缀算法KMP的时间复杂度是<span class="math inline">\(O(len(n)+len(m))\)</span>。因此总的时间复杂度是<span class="math inline">\(O(n*(len(m)+len(n)))\)</span>，计算后得到是<span class="math inline">\(2*10^5*10^5\)</span>，肯定超时。</p><p>因此本题不能一次匹配一个串，而是要多个匹配，那么就想到了前缀树trie来做前缀单词匹配。</p><p>对于查询当前的单词，如果最后在trie上能够走到非空的节点，并且节点标记为终结的节点，那么该单词出现过在之前的序列中，若找到的节点是非终结节点，那么说明该单词是至少出现在之前单词的前缀中。</p><p>因此综上，对单词前缀的实时插入和查询前缀，实质是trie树所支持的基本操作。</p><ul><li>add(s) 向前缀树插入一个串</li><li>query(s) 向前缀树中查询这个串是否出现过</li></ul><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> x[maxn];</span><br><span class="line"><span class="built_in">string</span> op;</span><br><span class="line"><span class="keyword">int</span> son[maxn][<span class="number">26</span>];  <span class="comment">//存点的儿子的下标</span></span><br><span class="line"><span class="keyword">int</span> cnt[maxn];      <span class="comment">//当前点结尾的单词有出现多少次</span></span><br><span class="line"><span class="keyword">int</span> idx;            <span class="comment">//维护的数量</span></span><br><span class="line"><span class="comment">//下标是0的节点既是根节点又是空节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> str[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">    p = son[p][u];</span><br><span class="line">  &#125;</span><br><span class="line">  cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> str[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    p = son[p][u];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; op &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">"I"</span>) &#123;</span><br><span class="line">      insert(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"Q"</span>) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; query(x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="例题">例题</h2><p>在给定的N个整数<span class="math inline">\(A_1,A_2……A_N\)</span>中选出两个进行xor（异或）运算，得到的结果最大是多少？</p><p>输入格式</p><p>第一行输入一个整数N。</p><p>第二行输入N个整数 <span class="math inline">\(A_1～A_N\)</span>。</p><p>输出格式</p><p>输出一个整数表示答案。</p><p>数据范围</p><p><span class="math inline">\(1≤N≤10^5\)</span>, <span class="math inline">\(0≤A_i&lt;2^{31}\)</span></p><p>题目大意：在一个数组中求最大异或对</p><h3 id="分析-1">分析</h3><p>使用暴力做法枚举两个边界，时间复杂度是<span class="math inline">\(O(n^2)\)</span>，明显超时。</p><p>优化做法有点考验思维，直接贴出题解： 假如考虑一个数字<span class="math inline">\(a\)</span>的二进制展开是<span class="math inline">\((a_na_{n-1}....a_3a_2a_1a_0)_2\)</span>那么在和另一个数字<span class="math inline">\(b\)</span>的二进制展开<span class="math inline">\((b_nb_{n-1}....b_3b_2b_1b_0)_2\)</span>做异或操作时，考虑第<span class="math inline">\(k\)</span>位上的运算<span class="math inline">\(a_k\text{xor }b_k\)</span>可能的结果是<span class="math inline">\(1\)</span>或者<span class="math inline">\(0\)</span>，但是一定不会影响到左边或者右边的位（所以异或又被称作膜二加法或者是不进位加法）。</p><p>因此可以得出，如果想要使得当前的对是数组<span class="math inline">\(a\)</span>中异或值最大的，那么需要优先从高位到低位去考虑异或值是1的情况（贪心的思想），那么如何去实施这种贪心呢？</p><p>答案是使用<span class="math inline">\(Trie\)</span>，在当前的数字二进制展开所建立的<span class="math inline">\(Trie\)</span>上<strong>贪心</strong>地去找异或最大值。</p><p>考虑以下情况： <img src="https://gitee.com/adameta/img/raw/master/1583497864_20200306201451110_9547.png"> 对于每一个数字都使其二进制表示插到<span class="math inline">\(Trie\)</span>上，随后即为每次询问一个数K的二进制展开在这个<span class="math inline">\(Trie\)</span>上的最大异或值，因为当前的匹配中0和1组合是最大的（等于该位置上的1），因此，贪心的策略<strong>是找当前节点的非</strong>。</p><p>举个样例： <img src="https://gitee.com/adameta/img/raw/master/1583497865_20200306201842269_30518.png"></p><p>通过这样的转化，我们首先根据每一个数字的二进制展开来建立一个前缀树，之后，对每一个查询做贪心策略，都去寻找当前值的非值（期望最大化），若无法找到则选择当前节点的非，则选择当前节点（退而求其次）。</p><p>时间复杂度：最坏情况下，n个数字的二进制展开都不一致，那么对于k位数字来说总共有<span class="math inline">\(2^{32}\)</span>个节点，但是每一次匹配最多进行32次，总共有n个单词，因此时间复杂度是<span class="math inline">\(O(nk)\)</span>，简单计算得到是<span class="math inline">\(32*10^5&lt;&lt;10^7\)</span>。</p><p>其关键部分是每一次走节点的贪心策略：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxquery</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> b = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((b == <span class="number">0</span> &amp;&amp; son[p][<span class="number">1</span>]) || (b == <span class="number">1</span> &amp;&amp; son[p][<span class="number">0</span>])) &#123;</span><br><span class="line">    <span class="comment">//此时当前节点值的位存在并且和当前数字的位不同</span></span><br><span class="line">      res = res &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">      p = son[p][<span class="number">1</span> ^ b];<span class="comment">//向下走到下一个Trie节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//不存在和当前数字的位的不同的子节点，退而求其次选择和自己相同的点</span></span><br><span class="line">      res = res &lt;&lt; <span class="number">1</span> | <span class="number">0</span>;</span><br><span class="line">      p = son[p][b];<span class="comment">//向下走到下一个Trie节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> son[maxn * <span class="number">32</span>][<span class="number">2</span>], idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;  <span class="comment">// root</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> b = (x &gt;&gt; i) &amp; <span class="number">1</span>;  <span class="comment">//这个位置的数字</span></span><br><span class="line">    <span class="keyword">if</span> (!son[p][b]) son[p][b] = idx++;</span><br><span class="line">    p = son[p][b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxquery</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> b = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((b == <span class="number">0</span> &amp;&amp; son[p][<span class="number">1</span>]) || (b == <span class="number">1</span> &amp;&amp; son[p][<span class="number">0</span>])) &#123;</span><br><span class="line">      res = res &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">      p = son[p][<span class="number">1</span> ^ b];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res = res &lt;&lt; <span class="number">1</span> | <span class="number">0</span>;</span><br><span class="line">      p = son[p][b];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// bf</span></span><br><span class="line">  <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">  <span class="comment">//   for (int j = i + 1; j &lt; n; j++) &#123;</span></span><br><span class="line">  <span class="comment">//     if ((a[i] ^ a[j]) == 1033222) &#123;</span></span><br><span class="line">  <span class="comment">//       cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//因为对于^来说，把每一个数写作二进制表示后</span></span><br><span class="line">  <span class="comment">// 10010 把它填充到32位 00..10010</span></span><br><span class="line">  <span class="comment">//然后遍历每一个数字把它加入到trie上</span></span><br><span class="line">  <span class="comment">// max的数一定是期望每一位都是1</span></span><br><span class="line">  <span class="comment">//那么遍历每一个ai 期望它都走1的路线 如果1是null</span></span><br><span class="line">  <span class="comment">//就走0 这样就达到了最大</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    add(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    res = max(res, maxquery(a[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>贪心</category>
        <category>Trie</category>
      </categories>
      <tags>
        <tag>ST表</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的经典线性DP问题</title>
    <url>/archives/acw898.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h1 id="线性dp">线性DP</h1><p>线性DP是值得的是DP的转移过程可以由一种表画出，是由线性的转移过程，是最为一般的一类DP问题。 本文给出线性DP一些入门题目</p><a id="more"></a><h2 id="数字三角形">数字三角形</h2><p><a href="https://www.acwing.com/problem/content/900/" target="_blank" rel="noopener external nofollow noreferrer">898 数组三角形</a></p><p>题目大意：从起点向下或者向右下走，目标为数字和最大一条路径的长度。</p><p><img src="https://gitee.com/adameta/img/raw/master/1583590333_20200227163657918_28103.png"></p><p><img src="https://gitee.com/adameta/img/raw/master/1583590335_20200227163710213_29967.png"></p><p>思路分析过程： <img src="https://gitee.com/adameta/img/raw/master/1583590336_20200227164016195_10542.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//注意特殊处理初始转移状态</span></span><br><span class="line">  <span class="comment">/*hack data</span></span><br><span class="line"><span class="comment">    10</span></span><br><span class="line"><span class="comment">    -6</span></span><br><span class="line"><span class="comment">    -4 -5</span></span><br><span class="line"><span class="comment">    -3 7 5</span></span><br><span class="line"><span class="comment">    3 7 -2 1</span></span><br><span class="line"><span class="comment">    10 2 -6 2 -6</span></span><br><span class="line"><span class="comment">    -8 3 8 6 7 9</span></span><br><span class="line"><span class="comment">    -4 -10 0 -3 4 9 2</span></span><br><span class="line"><span class="comment">    0 5 5 5 10 -6 -5 -4</span></span><br><span class="line"><span class="comment">    -9 7 4 9 8 -5 -2 3 2</span></span><br><span class="line"><span class="comment">    -7 -4 0 -10 -8 -4 3 -5 8 9</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">      f[i][j] = max(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>]) + a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = -inf;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    res = max(res, f[n][i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长上升子序列">最长上升子序列</h2><p><a href="https://www.acwing.com/activity/content/problem/content/1003/1/" target="_blank" rel="noopener external nofollow noreferrer">最长上升子序列</a></p><p><img src="https://gitee.com/adameta/img/raw/master/1583590337_20200227204740816_13808.png"></p><h3 id="朴素做法">朴素做法</h3><p>数据的大小<span class="math inline">\(n=10^3\)</span>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="comment">// g[i]==j表示i是从j转移过来的</span></span><br><span class="line"><span class="keyword">int</span> f[maxn], g[maxn];  <span class="comment">// g数组保存的是转移的过程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> res = -inf;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] &gt; a[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i] &lt; f[j] + <span class="number">1</span>) &#123;</span><br><span class="line">          f[i] = f[j] + <span class="number">1</span>;</span><br><span class="line">          g[i] = j;  <span class="comment">//保存转移的过程</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = max(res, f[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (f[k] &lt; f[i]) k = i;  <span class="comment">//找到最后一个转移过来的数字</span></span><br><span class="line">  <span class="comment">//打印转移的顺序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = f[k]; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[k] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    k = g[k];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化做法">优化做法</h3><p>数据的大小<span class="math inline">\(n=10^5\)</span>。</p><p><a href="https://www.acwing.com/solution/AcWing/content/3783/" target="_blank" rel="noopener external nofollow noreferrer">题解1</a> <a href="https://www.acwing.com/solution/AcWing/content/6941/" target="_blank" rel="noopener external nofollow noreferrer">题解2</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// https://www.acwing.com/solution/AcWing/content/6941/</span></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">  q[<span class="number">0</span>] = -inf;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="keyword">int</span> m = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//找到比a[i]小的最大值</span></span><br><span class="line">      <span class="keyword">if</span> (q[m] &lt; a[i])</span><br><span class="line">        l = m;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        r = m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 因为此时l==r并且q[l]是表示当前小于a[i]的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    len = max(len, r + <span class="number">1</span>);<span class="comment">//更新长度 如果是增加新元素那么r==len</span></span><br><span class="line">    q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列">最长公共子序列</h2><p><img src="https://gitee.com/adameta/img/raw/master/1583590338_20200228150644922_645.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, l, r) for (int i = l; i &gt;= r; i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(s, _) memset(s, _, sizeof(s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xcfcfcfcf</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; a + <span class="number">1</span> &gt;&gt; b + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      f[i][j] = max(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编辑距离">编辑距离</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a + <span class="number">1</span> &gt;&gt; m &gt;&gt; b + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="comment">// 尝试 add  del</span></span><br><span class="line">      f[i][j] = min(f[i][j - <span class="number">1</span>] + <span class="number">1</span>, f[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// change</span></span><br><span class="line">      <span class="keyword">if</span> (a[i] != b[j])</span><br><span class="line">        f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, f[i][j]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
        <category>线性DP</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>带懒标记的线段树模板</title>
    <url>/archives/extra0325.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h1 id="带懒标记的线段树">带懒标记的线段树</h1><h2 id="性质">性质</h2><p>线段树是运用分块思想的树形结构。其主要的作用是维护<strong>区间信息</strong>的数据结构。</p><p>线段树可以在 <span class="math inline">\(O(\text{log}(n))\)</span>的时间复杂度内完成单点修改、区间修改、区间查询等操作。</p><a id="more"></a><p>值得注意的是线段树能够维护的信息需要满足<a href="https://zh.wikipedia.org/wiki/可加性" target="_blank" rel="noopener external nofollow noreferrer">可加性</a>。</p><p>即例如<span class="math inline">\(max(a,b,c)=max(max(a,b),c)=max(max(a,c),b)=max(max(b,c),a)\)</span>满足可加性，而<span class="math inline">\((a\mod b \mod c )\neq( a\mod c \mod b)\)</span>不满足可加性。</p><blockquote><p>可加性是指对于某种变换来说，特定的“加法”和该变换的顺序可颠倒而不影响结果，这样一种性质。——来自wiki百科</p></blockquote><hr><h2 id="操作">操作</h2><table><thead><tr class="header"><th>符号</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>a</td><td>原数组</td></tr><tr class="even"><td>d</td><td>线段树节点维护值</td></tr><tr class="odd"><td>lazytag</td><td>线段树节点的懒标记值</td></tr><tr class="even"><td>p</td><td>当前的节点</td></tr><tr class="odd"><td>s</td><td>查询区间的开始</td></tr><tr class="even"><td>e</td><td>查询区间的结尾</td></tr><tr class="odd"><td>l</td><td>节点区间的开始</td></tr><tr class="even"><td>r</td><td>节点区间的结尾</td></tr></tbody></table><p>一般习惯： * 建树从下标为1开始 * mid = l + r &gt;&gt; 1</p><h3 id="建立线段树">建立线段树</h3><p>以<span class="math inline">\(a=\{1,2,3\}\)</span>为例子，树的结构如下： <img src="https://gitee.com/adameta/img/raw/master/1583760077_20200309182420880_10198.png"></p><p>首先是提供的参数<code>void build(int s, int e, int p)</code>。</p><p>然后是伪代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void build(int s, int e, int p)&#123;</span><br><span class="line">    if(s &#x3D;&#x3D; e)&#123;</span><br><span class="line">    &#x2F;&#x2F;当前d[p]是叶子节点</span><br><span class="line">        d[p]&#x3D;a[p];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int m &#x3D; s + e &gt;&gt; 1;</span><br><span class="line">    build(左子树[s,m]);</span><br><span class="line">    build(左子树[m+1,e]);</span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>即为：对于一个节点，我们从根节点开始，递归的构建整个树到叶子节点，并且从叶子节点<span class="math inline">\(\text{pushup}\)</span>到根节点。</p><p>对于一个节点：</p><ul><li>若当前的节点是叶子节点，即<code>s==e</code>，那么<span class="math inline">\(d[p]\)</span>（对应区间<span class="math inline">\([s,s]\)</span>）的就是<span class="math inline">\(a[s]\)</span></li><li>若当前的节点是非叶子节点，即<code>s&lt;e</code>，那么将区间分割为两个部分即<span class="math inline">\([s,m]\)</span>(对应下标为<span class="math inline">\(p&lt;&lt;1\)</span>)和<span class="math inline">\([m+1,e]\)</span>(对应的下标为<span class="math inline">\(p&lt;&lt;1|1\)</span>),其中<span class="math inline">\(m=s+e&gt;&gt;1\)</span>，递归到左右儿子进行建树。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//[s,e]建立线段树 根为p</span></span><br><span class="line">  <span class="keyword">if</span> (s == e) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll m = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(s, m, p &lt;&lt; <span class="number">1</span>), build(m + <span class="number">1</span>, e, (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">  d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间查询">区间查询</h3><p>对于一个节点，其存储的是<span class="math inline">\([l,r]\)</span>区间内的维护的值，而对于一个区间查询<span class="math inline">\([s,e]\)</span></p><p>若有查询的区间<span class="math inline">\([s,e]\)</span><strong>完全覆盖</strong>当前的节点区间<span class="math inline">\([l,r]\)</span>，即<code>s&lt;=l &amp;&amp; r&lt;=e</code>查询的值即为<span class="math inline">\(d[p]\)</span></p><p><img src="https://gitee.com/adameta/img/raw/master/1583760080_20200309201356866_24563.png"></p><p>否则，将区间<strong>一分为二</strong>：</p><ul><li><span class="math inline">\([l,m]\)</span>左儿子对应下标为<span class="math inline">\(p&lt;&lt;1\)</span></li><li><span class="math inline">\([m+1,r]\)</span>右儿子对应的下标为<span class="math inline">\(p&lt;&lt;1|1\)</span></li></ul><p>此时递归到左右儿子子树进行查询 <img src="https://gitee.com/adameta/img/raw/master/1583760083_20200309202303370_22602.png"></p><p>如果每一次更新区间值，都会使得整个线段树向下更新到根节点。在区间更新的时候应该使用懒标记的线段树，延迟整个节点的信息更新。</p><p>带有懒标记的线段树，实际上是父节点暂时记录了下推到子节点的信息。在查询时，才将延迟更新的节点信息加载到子节点。</p><p>对于参数<span class="math inline">\(ll getsum(ll l, ll r, ll s, ll e, ll p)\)</span></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll getsum(ll l, ll r, ll s, ll e, ll p) &#123;</span><br><span class="line">    if(当前区间是叶节点) return d[p]</span><br><span class="line">    ll m &#x3D; l + r &gt;&gt; 1;</span><br><span class="line">    if(lazy[p])&#123;&#x2F;&#x2F;当前的节点是带有延迟更新的信息的</span><br><span class="line">    &#x2F;&#x2F;pushdown</span><br><span class="line">        d[p的左儿子] +&#x3D; lazy[p] * (p左儿子区间长度);</span><br><span class="line">        d[p的右儿子] +&#x3D; lazy[p] * (p右儿子区间长度);</span><br><span class="line">        lazy[p的左儿子] +&#x3D; lazy[p];</span><br><span class="line">        lazy[p的右儿子] +&#x3D; lazy[p];</span><br><span class="line">    &#125;</span><br><span class="line">    lazy[p] &#x3D; 0;&#x2F;&#x2F;还原懒惰标记</span><br><span class="line">    ll sum &#x3D; 0;&#x2F;&#x2F;查询值</span><br><span class="line">    if(左儿子存在) sum +&#x3D; getsum(l,r,左儿子区间,左儿子下标);</span><br><span class="line">    if(右儿子存在) sum +&#x3D; getsum(l,r,右儿子区间,右儿子下标);</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了将清楚流程，借用oi-wiki的图片：</p><figure><img src="https://gitee.com/adameta/img/raw/master/1583760087_20200309205136620_16905.png" alt="segt6"><figcaption>segt6</figcaption></figure><p><img src="https://gitee.com/adameta/img/raw/master/1583760088_20200309205145734_13182.png" alt="segt7"> <img src="https://gitee.com/adameta/img/raw/master/1583760091_20200309205158968_12321.png" alt="segt8"></p><figure><img src="https://gitee.com/adameta/img/raw/master/1583760093_20200309205217145_6430.png" alt="segt9"><figcaption>segt9</figcaption></figure><figure><img src="https://gitee.com/adameta/img/raw/master/1583760094_20200309205229255_8462.png" alt="segt10"><figcaption>segt10</figcaption></figure><p>此时如果当前的区间进行查询[1,1]（即为B节点）：</p><p>那么A的信息将会传递给B，这个过程即为<span class="math inline">\(pushdown\)</span>过程。 <img src="https://gitee.com/adameta/img/raw/master/1583760094_20200309205403365_7227.png" alt="segt12"></p><figure><img src="https://gitee.com/adameta/img/raw/master/1583760096_20200309205413339_11895.png" alt="segt13"><figcaption>segt13</figcaption></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(ll l, ll r, ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    [l,r]当前查询的区间</span></span><br><span class="line"><span class="comment">    [s,e]当前节点的区间</span></span><br><span class="line"><span class="comment">    p 为当前的节点编号</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; e &lt;= r) <span class="keyword">return</span> d[p];</span><br><span class="line">  ll m = (s + e) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//更新子节点和传递懒标记</span></span><br><span class="line">  <span class="keyword">if</span> (lazy[p])&#123;</span><br><span class="line">    d[p &lt;&lt; <span class="number">1</span>] += lazy[p] * (m - s + <span class="number">1</span>), d[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[p] * (e - m);</span><br><span class="line">    lazy[p &lt;&lt; <span class="number">1</span>] += lazy[p], lazy[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[p];</span><br><span class="line">  &#125;</span><br><span class="line">  lazy[p] = <span class="number">0</span>;  <span class="comment">//还原懒标记</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) sum += getsum(l, r, s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) sum += getsum(l, r, m + <span class="number">1</span>, e, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间更新">区间更新</h3><p>综上所述，区间修改（更新）过程是产生新的懒标记，而区间查询是将懒标记向下传递<span class="math inline">\(pushdown\)</span>。</p><p>函数参数<code>void update(ll l, ll r, ll c, ll s, ll e, ll p)</code></p><p>伪码描述:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll l, ll r, ll c, ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(当前的查询区间完全包裹节点) &#123;</span><br><span class="line">        d[p] += 当前节点区间长度 * 修改的值c;<span class="comment">//即把区间内的所有点都加上c,等效于这个区间加上了len*c</span></span><br><span class="line">        lazy[p] += c;<span class="comment">//区间更新的值向下传递</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lazy[p])&#123;<span class="comment">//当前的节点是带有延迟更新的信息的</span></span><br><span class="line">    <span class="comment">//pushdown(p);</span></span><br><span class="line">        d[p的左儿子] += lazy[p] * (p左儿子区间长度);</span><br><span class="line">        d[p的右儿子] += lazy[p] * (p右儿子区间长度);</span><br><span class="line">        lazy[p的左儿子] += lazy[p];</span><br><span class="line">        lazy[p的右儿子] += lazy[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(左儿子存在) update(l,r,左儿子区间,左儿子下标);</span><br><span class="line">    <span class="keyword">if</span>(右儿子存在) update(l,r,右儿子区间,右儿子下标);</span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll l, ll r, ll c, ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    带有懒标记的更新操作</span></span><br><span class="line"><span class="comment">    [l,r]当前查询的区间</span></span><br><span class="line"><span class="comment">    [s,e]当前节点的区间</span></span><br><span class="line"><span class="comment">    c维护的信息</span></span><br><span class="line"><span class="comment">    p节点位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; e &lt;= r) &#123;</span><br><span class="line">    d[p] += (e - s + <span class="number">1</span>) * c;</span><br><span class="line">    lazy[p] += c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll m = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//叶子节点不需要下放懒标记</span></span><br><span class="line">  <span class="keyword">if</span> (lazy[p]) &#123;  <span class="comment">//当前的节点懒标记可以向下传递</span></span><br><span class="line">    <span class="comment">//左儿子和右儿子更新节点信息</span></span><br><span class="line">    d[p &lt;&lt; <span class="number">1</span>] += lazy[p] * (m - s + <span class="number">1</span>), d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>] += lazy[p] * (e - m);</span><br><span class="line">    lazy[p &lt;&lt; <span class="number">1</span>] += lazy[p], lazy[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>] += lazy[p];</span><br><span class="line">    lazy[p] = <span class="number">0</span>;  <span class="comment">//消除懒标记</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) update(l, r, c, s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) update(l, r, c, m + <span class="number">1</span>, e, (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">  d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pushup">pushup</h3><p>该部分操作是递归到儿子时，回溯地影响自己的父亲节点，是自底向上的修改。</p><p>涉及的操作是<code>build</code>和<code>update</code>。</p><p>本质是更新了子节点后，重新计算父节点的信息。</p><p>操作为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p></p><h3 id="pushdown">pushdown</h3><p>该部分操作是把父亲欠下儿子的信息向下返还，用懒惰标记更新当前的维护值。</p><p>涉及的操作是<code>getsum</code>和<code>update</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (lazy[p]) &#123;  <span class="comment">//当前的节点懒标记可以向下传递</span></span><br><span class="line"><span class="comment">//左儿子和右儿子更新节点信息</span></span><br><span class="line">    d[p &lt;&lt; <span class="number">1</span>] += lazy[p] * (m - s + <span class="number">1</span>), d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>] += lazy[p] * (e - m);</span><br><span class="line">    lazy[p &lt;&lt; <span class="number">1</span>] += lazy[p], lazy[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>] += lazy[p];</span><br><span class="line">    lazy[p] = <span class="number">0</span>;  <span class="comment">//消除懒标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度">复杂度</h2><p>在<span class="math inline">\(O(\text{log}(n))\)</span>的时间复杂度内完成单点修改、区间修改、区间查询等操作</p><p>空间复杂度较高，上限是<span class="math inline">\(O(9*n)\)</span>（在默认开4倍的空间的情况下，注意！在1e5容易爆）</p><p>空间的复杂度上限为<span class="math inline">\(O(2^{\lceil{\text{log}(n)+1} \rceil })\)</span>，但是实际竞赛中一般取<span class="math inline">\(4*\text{maxn}\)</span>。</p><h2 id="模板">模板</h2><p><a href="https://www.luogu.com.cn/problem/P3372" target="_blank" rel="noopener external nofollow noreferrer">P3372洛谷 线段树模板1</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx = (<span class="keyword">int</span>)<span class="built_in">ceil</span>(<span class="built_in">log</span>(<span class="number">1e5</span>+<span class="number">10</span>)/<span class="built_in">log</span>(<span class="number">2</span>))*<span class="number">1.2</span>;<span class="comment">//270000</span></span><br><span class="line"><span class="comment">/*a是原数组,d是线段树维护的信息,b是懒标记*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 懒标记b&gt;0说明当前的节点欠儿子某些信息</span></span><br><span class="line"><span class="comment">pushdown在更新懒标记节点的时候，还要向下传递</span></span><br><span class="line"><span class="comment">更新其儿子的懒标记信息</span></span><br><span class="line"><span class="comment">2. 同时也更新儿子维护的信息d（信息的一半）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 262144 == 1 &lt;&lt; ((int)ceil(log(1e5 + 10) / log(2)) + 1);</span></span><br><span class="line">ll a[maxn], d[<span class="number">262144</span>], lazy[<span class="number">262144</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//[s,e]建立线段树 根为p</span></span><br><span class="line">  <span class="keyword">if</span> (s == e) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll m = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(s, m, p &lt;&lt; <span class="number">1</span>), build(m + <span class="number">1</span>, e, (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">  d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(ll l, ll r, ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    [l,r]当前查询的区间</span></span><br><span class="line"><span class="comment">    [s,e]当前节点的区间</span></span><br><span class="line"><span class="comment">    p 为当前的节点编号</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; e &lt;= r) <span class="keyword">return</span> d[p];</span><br><span class="line">  ll m = (s + e) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//更新子节点和传递懒标记</span></span><br><span class="line">  <span class="keyword">if</span> (lazy[p])</span><br><span class="line">    d[p &lt;&lt; <span class="number">1</span>] += lazy[p] * (m - s + <span class="number">1</span>), d[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[p] * (e - m),</span><br><span class="line">        lazy[p &lt;&lt; <span class="number">1</span>] += lazy[p], lazy[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[p];</span><br><span class="line">  lazy[p] = <span class="number">0</span>;  <span class="comment">//还原懒标记</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) sum += getsum(l, r, s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) sum += getsum(l, r, m + <span class="number">1</span>, e, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll l, ll r, ll c, ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    带有懒标记的更新操作</span></span><br><span class="line"><span class="comment">    [l,r]当前查询的区间</span></span><br><span class="line"><span class="comment">    [s,e]当前节点的区间</span></span><br><span class="line"><span class="comment">    c维护的信息</span></span><br><span class="line"><span class="comment">    p节点位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; e &lt;= r) &#123;</span><br><span class="line">    d[p] += (e - s + <span class="number">1</span>) * c;</span><br><span class="line">    lazy[p] += c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll m = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//叶子节点不需要下放懒标记</span></span><br><span class="line">  <span class="keyword">if</span> (lazy[p]) &#123;  <span class="comment">//当前的节点懒标记可以向下传递</span></span><br><span class="line">    <span class="comment">//左儿子和右儿子更新节点信息</span></span><br><span class="line">    d[p &lt;&lt; <span class="number">1</span>] += lazy[p] * (m - s + <span class="number">1</span>), d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>] += lazy[p] * (e - m);</span><br><span class="line">    lazy[p &lt;&lt; <span class="number">1</span>] += lazy[p], lazy[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>] += lazy[p];</span><br><span class="line">    lazy[p] = <span class="number">0</span>;  <span class="comment">//消除懒标记</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) update(l, r, c, s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) update(l, r, c, m + <span class="number">1</span>, e, (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">  d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ll n, q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">  ll a, b, c, d;</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; getsum(b, c, <span class="number">1</span>, n, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">      update(b, c, d, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll a[maxn], lazy[<span class="number">300000</span>], d[<span class="number">300000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(ll p)</span> </span>&#123; d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(ll p, ll s, ll m, ll e)</span> </span>&#123;</span><br><span class="line">  d[p &lt;&lt; <span class="number">1</span>] += lazy[p] * (m - s + <span class="number">1</span>);</span><br><span class="line">  d[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[p] * (e - m);</span><br><span class="line">  lazy[p &lt;&lt; <span class="number">1</span>] += lazy[p];</span><br><span class="line">  lazy[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[p];</span><br><span class="line">  lazy[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == e) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll m = s + e &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  build(m + <span class="number">1</span>, e, (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">  pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(ll l, ll r, ll s, ll e, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; r &gt;= e) <span class="keyword">return</span> d[p];</span><br><span class="line">  ll m = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (lazy[p]) &#123;</span><br><span class="line">    pushdown(p, s, m, e);</span><br><span class="line">  &#125;</span><br><span class="line">  ll sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) sum += getsum(l, r, s, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) sum += getsum(l, r, m + <span class="number">1</span>, e, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll l, ll r, ll s, ll e, ll c, ll p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; r &gt;= e) &#123;</span><br><span class="line">    d[p] += (e - s + <span class="number">1</span>) * c;</span><br><span class="line">    lazy[p] += c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll m = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (lazy[p]) &#123;</span><br><span class="line">    pushdown(p, s, m, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) update(l, r, s, m, c, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (m &lt; r) update(l, r, m + <span class="number">1</span>, e, c, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">  pushup(p);</span><br><span class="line">&#125;</span><br><span class="line">ll m, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">  ll a, b, c, d;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">//查询bc</span></span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; getsum(b, c, <span class="number">1</span>, n, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">      update(b, c, <span class="number">1</span>, n, d, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列实现滑动窗口</title>
    <url>/archives/acw154.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h1 id="单调队列实现滑动窗口">单调队列实现滑动窗口</h1><p>单调队列和单调栈都有一个共同的思路，删去一些无用的元素，使得整个数据结构有序。</p><p>关键：单调队列的实现是使用双端队列来实现的，使用<strong>pop_back</strong>让队尾不符合序列序的弹出，并且查询队头的元素。</p><p>其中单调队列是使用<strong>双端队列</strong>实现的</p><a id="more"></a><p><strong>经典应用：求滑动窗口中最大（小）值。</strong></p><p>在这个例子中，因为-3进入了窗口并且比3小，因此，发现如果-3存在于这个队列中，那么3就没有存在的必要，因此pop_back出3，同理-1也被pop_back。</p><p><img src="https://gitee.com/adameta/img/raw/master/1581376764_20200211064055964_12274.png"></p><p><a href="https://www.acwing.com/problem/content/156/" target="_blank" rel="noopener external nofollow noreferrer">滑动窗口</a></p><p>处理细节：</p><ol type="1"><li>单调队列中存储的是原数组a中的下标</li><li>单调队列是<strong>从队尾到队头</strong>是上升的还是下降的？即hh维护的是哪一个最值(上升是维护最大值)</li><li>遇到破坏单调性的a[i]时，应该把单调队列后面的元素pop_back()出来，再加入这个元素。</li></ol><p>上面所描述的第三点具体到图片为：</p><p><img src="https://gitee.com/adameta/img/raw/master/1583858840_20200311004712261_19991.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> q[maxn], a[maxn];</span><br><span class="line"><span class="keyword">int</span> hh, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="comment">/*性质查询：查询头元素（因为是单调的队列）</span></span><br><span class="line"><span class="comment">    滑动窗口最小值，即查找队尾到队头是从大到小的队列队头</span></span><br><span class="line"><span class="comment">    滑动窗口最大值，即查找队尾到队头是从小到大的队列队头</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">//队尾到队头是从大到小的单调队列</span></span><br><span class="line">    <span class="keyword">if</span> (tt &gt;= hh &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">    <span class="keyword">while</span> (tt &gt;= hh &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;</span><br><span class="line">    q[++tt] = i;</span><br><span class="line">    <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">//队尾到队头是从小到大的单调队列</span></span><br><span class="line">    <span class="keyword">if</span> (tt &gt;= hh &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">    <span class="keyword">while</span> (tt &gt;= hh &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;</span><br><span class="line">    q[++tt] = i;</span><br><span class="line">    <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://www.luogu.com.cn/problem/P2251" target="_blank" rel="noopener external nofollow noreferrer">P2251洛谷 滑动窗口求最小值</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P2251</span></span><br><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> hh, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tt &gt;= hh &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">    <span class="keyword">while</span> (tt &gt;= hh &amp;&amp; a[i] &lt;= a[q[tt]]) tt--;</span><br><span class="line">    q[++tt] = i;</span><br><span class="line">    <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; a[q[hh]] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>单调队列</category>
        <category>思维题</category>
        <category>滑动窗口</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组优化LIS问题</title>
    <url>/archives/luogu1020.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h1 id="树状数组优化lis问题">树状数组优化LIS问题</h1><p>LIS即为最长上升子序列问题。学习动态规划问题（DP问题）中，其中有一个知识点叫最长上升子序列（longest increasing subsequence），也可以叫最长非降序子序列。</p><p>总所周知，LIS问题有贪心解法和DP解法。 贪心时间复杂度<span class="math inline">\(O(n)\)</span>，DP时间复杂度<span class="math inline">\(O(n^2)\)</span>。</p><p>本文将不讨论贪心的解法，<del>因为一般是想不到怎么去做贪心的</del>。 实际上，在面试和比赛时候更常见的是使用DP做法（更加直观和具有一般性。</p><a id="more"></a><p>『题目传送门』：<a href="https://www.luogu.com.cn/problem/P1020" target="_blank" rel="noopener external nofollow noreferrer">洛谷P1020</a></p><p>题目简述：给出一个长度不超过100000的数列，其中的数每个是不大于50000的正整数，求这个数列的最长不降子序列（问一）以及将这个数列划分为n个不降子序列时，n的最小值（问二）。 （推导过程见<a href="https://chx2333.blog.luogu.org/p1020-dao-tan-lan-jie-dong-tai-gui-hua-or-shu-zhuang-shuo-zu" target="_blank" rel="noopener external nofollow noreferrer">Dilworth定理：偏序集的最少反链划分数等于最长链的长度</a>）</p><h2 id="dp平方复杂度">DP平方复杂度</h2><p>『题目传送门』：<a href="https://www.luogu.com.cn/problem/P1020" target="_blank" rel="noopener external nofollow noreferrer">洛谷P1020</a></p><p>因为空间是1e5,如果不优化空间开二维数组肯定空间爆炸(<span class="math inline">\(({1e5})^2\)</span>)。</p><p>使用滚动数组思想优化空间后，对于最长上升子序列的状态转移方程是<span class="math inline">\(f[i]=\text{max}(f[j])\)</span>其中 <span class="math inline">\(j&lt; i\)</span>并且<span class="math inline">\(a[j]&lt; a[i]\)</span>，值得注意的是需要把每一次状态的初始值初始化为1（因为一个数的上升子序列就是1）</p><p>相同的，对于最长不上升子序列，只需要将这个过程反过来做即可，即从后面向前面做转移，方程是<span class="math inline">\(f[i]=\max (f[j])\)</span>其中 <span class="math inline">\(i&lt; j\)</span>并且<span class="math inline">\(a[j]&lt;= a[i]\)</span>，值得注意的是i的初始状态是从n开始的（从后往前做转移）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> res1 = -inf, res2 = -inf;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a[++n])</span><br><span class="line">    ;</span><br><span class="line">  n -= <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//最长不上升子序列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt; i; j--) &#123;</span><br><span class="line">      <span class="comment">// i &lt;-j</span></span><br><span class="line">      <span class="keyword">if</span> (a[i] &gt;= a[j]) &#123;</span><br><span class="line">        f[i] = max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res1 = max(res1, f[i]);</span><br><span class="line">  <span class="comment">//最长上升子序列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &lt; a[i]) &#123;  <span class="comment">// j-&gt;i</span></span><br><span class="line">        f[i] = max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res2 = max(res2, f[i]);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; res2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组维护查询nlgn复杂度">树状数组维护查询nlgn复杂度</h2><p>『题目传送门』：<a href="https://www.luogu.com.cn/problem/P1020" target="_blank" rel="noopener external nofollow noreferrer">洛谷P1020</a></p><p>不出意外上面的写法只能过10个测试点。题目给出提示：nlgn的写法能够给出200分</p><p>那么如何达到nlgn呢？我们来分析下：</p><p>我们知道DP的时间复杂度是<strong>转移的次数x各个状态转移成本</strong>，其中转移方程的次数又叫做阶段数。</p><ul><li>首先是转移方程的次数是<span class="math inline">\(n\)</span>，这个没有办法再优化了（至少要完成每一个转移）。</li><li>然后是转移的成本，分析转移方程可知，DP的LIS做法每一次都需要查找前面元素中可转移的最大值即a[j]&lt;=a[i]中a[j]最大。这一部分可以转为<strong>有条件的在区间内搜索最大值</strong>，是一个变种的RMQ问题，即可使用ST表或者线段树或者树状数组来优化。</li></ul><p>更加具体一点，树状数组<span class="math inline">\(f\)</span>(区间范围是从<span class="math inline">\(1-&gt;max(a[i])\)</span>)。</p><p>维护的是：<strong>树状数组f[i]当前以i结尾的LIS长度的最大值。</strong>（关键是理解维护的是什么）</p><p>因此每一次转移时，我们即查询以<span class="math inline">\([1,a[i]-1]\)</span>中的最大值。（区间查询操作<code>query(a[i] - 1)</code>） 然后这个最大值+1即为当前的以<span class="math inline">\(a[i]\)</span>结尾的最大值，并且把这个最大值加入到树状数组中（插入单点操作<code>add(a[i], q + 1);</code>）</p><p><img src="https://gitee.com/adameta/img/raw/master/1583996725_20200312145222788_32144.png"></p><p>手动过一遍样例。 <img src="https://gitee.com/adameta/img/raw/master/1583996729_20200312150508058_32176.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xcfcfcfcf</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> maxn = ninf;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> res1 = -inf, res2 = -inf;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= maxn; i += lowbit(i)) f[i] = max(f[i], c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//求以小于等于x的数为结尾的最长不上升子序列的长度的最大值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= lowbit(i)) res = max(res, f[i]);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*使用树状数组f来维护信息</span></span><br><span class="line"><span class="comment">    维护的是：当前以i结尾的最大的LIS长度</span></span><br><span class="line"><span class="comment">    每次查询的时间复杂度是log(max(a[i])) 即a[i]的值域的对数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a[++n]) maxn = max(a[n], maxn);</span><br><span class="line">  n -= <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//最长不上升子序列</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  求以a[i]结尾的最大的不上升子序列的长度</span></span><br><span class="line"><span class="comment">  等效于从后向前-&gt;求a[i]结尾的最长不上升子序列</span></span><br><span class="line"><span class="comment">              1 3 4 4 5</span></span><br><span class="line"><span class="comment">  最长上升    1 3 4 5</span></span><br><span class="line"><span class="comment">  最长不上升  4 4       (从后向前看，求最长不上升)</span></span><br><span class="line"><span class="comment">  所以对于这个问题只需要维护一个树状数组即可</span></span><br><span class="line"><span class="comment">  一次从后向前做（最长不上升子序列）</span></span><br><span class="line"><span class="comment">  一次从前往后做（最长上升子序列）</span></span><br><span class="line"><span class="comment">  每次查询都是问 $以a[i]结尾目前的最长子序列的长度$</span></span><br><span class="line"><span class="comment">  即树状数组维护的是长度，并且其定义域是a[i]的值域</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> q = query(a[i]);  </span><br><span class="line">    add(a[i], q + <span class="number">1</span>);</span><br><span class="line">    res1 = max(res1, q + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);  <span class="comment">// memset一下</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//最长上升子序列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> q = query(a[i] - <span class="number">1</span>);  <span class="comment">// 找到[1,a[i]-1]中的最大值</span></span><br><span class="line">    add(a[i], q + <span class="number">1</span>);  <span class="comment">//这个最大值即是有效的转移 加入到树状数组中去</span></span><br><span class="line">    res2 = max(res2, q + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; res2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>DP</category>
        <category>树状数组</category>
        <category>线性DP</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>ST表实现RMQ</title>
    <url>/archives/luogu3865.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h1 id="st表实现rmq">ST表实现RMQ</h1><p>什么是RMQ?</p><p>RMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。</p><p>什么是ST表？</p><p>ST 表是用于解决 可重复贡献问题 的数据结构。 除 RMQ 以外，还有其它的“可重复贡献问题”。例如“区间按位和”、“区间按位或”、“区间 GCD”，ST 表都能高效地解决。(都是可以重复贡献问题)</p><a id="more"></a><p><img src="https://gitee.com/adameta/img/raw/master/1584000763_20200312154743498_14987.png"></p><p>对于更好的解释：<a href="https://oi-wiki.org/ds/sparse-table/" target="_blank" rel="noopener external nofollow noreferrer">OI-wiki_ST表</a></p><p>用ST表实现RMQ问题？</p><p>时间复杂度：<span class="math inline">\(O(n\log n)-O(1)\)</span>，空间复杂度：<span class="math inline">\(O(n\log n)\)</span></p><hr><p>题目传送门』：<a href="https://www.luogu.com.cn/problem/P3865" target="_blank" rel="noopener external nofollow noreferrer">洛谷P3865 ST表</a></p><p>题目大意：给定 <span class="math inline">\(n\)</span> 个数，有 <span class="math inline">\(m\)</span> 个询问，对于每个询问，你需要回答区间 <span class="math inline">\([l,r]\)</span> 中的最大值。</p><p>关键思想： 令一个数组<span class="math inline">\(f(i,j)\)</span>表示区间<span class="math inline">\([i,i+2^{j}-1]\)</span>的最大值，那么显然就有<span class="math inline">\(f(i,0) = a_i\)</span>。</p><p><strong>预处理数组</strong>关键递推式： <span class="math display">\[f(i,j) =\max( f(i,j-1),f(i+2^{j-1},j-1))\]</span></p><p><strong>查询</strong>操作： 查询:对于每个询问 <span class="math inline">\([l,r]\)</span> ，把它分成两部分： <span class="math inline">\(f[l,l+2^s-1]\)</span> 与 <span class="math inline">\(f[r-2^s+1,r]\)</span> 。其中 <span class="math display">\[s=\left\lfloor\log_2(r-l+1)\right\rfloor\]</span></p><p><img src="https://gitee.com/adameta/img/raw/master/1584000766_20200312161156938_6071.png"></p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> logn = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//令go(i,j)表示区间[i,i+2^j-1]的最大值。</span></span><br><span class="line"><span class="keyword">int</span> go[maxn][logn], Logn[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Logn[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  Logn[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; maxn; i++) Logn[i] = Logn[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; go[i][<span class="number">0</span>];</span><br><span class="line">  pre();  <span class="comment">//预处理Log</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= logn; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        预处理区间</span></span><br><span class="line"><span class="comment">        把区间分为[i,j]分为[i,i+2^&#123;j-1&#125;-1] [i+2^&#123;j-1&#125;,i+2^&#123;j&#125;-1]</span></span><br><span class="line"><span class="comment">        1.即从i开始，向后跳2^&#123;j-1&#125;个点，右区间到i+2^&#123;j-1&#125;-1</span></span><br><span class="line"><span class="comment">        2.即从i+2^&#123;j-1&#125;开始，向后跳2^&#123;j-1&#125;个点，右区间到i+2^&#123;j&#125;-1</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      go[i][j] = max(go[i][j - <span class="number">1</span>], go[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">int</span> s = Logn[y - x + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      go(i,j)表示区间[i,i+2^j-1]的最大值。</span></span><br><span class="line"><span class="comment">      那么对于一对查询x,y,求[x,y]区间内的最大值</span></span><br><span class="line"><span class="comment">      对于区间长度(y - x + 1)：</span></span><br><span class="line"><span class="comment">      有 [log(y - x + 1)]_&#123;floor&#125; = s</span></span><br><span class="line"><span class="comment">      [x][s]和[y - (1 &lt;&lt; s) + 1][s]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(go[x][s], go[y - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>ST表</category>
        <category>区间题</category>
      </categories>
      <tags>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>糖果传递</title>
    <url>/archives/acw122.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h1 id="糖果传递问题">糖果传递问题</h1><h2 id="题目">题目</h2><p><a href="https://www.acwing.com/problem/content/124/" target="_blank" rel="noopener external nofollow noreferrer">『算法竞赛进阶指南』糖果传递</a> 有n个小朋友坐成一圈，每人有a[i]个糖果。 每人只能给左右两人传递糖果。 每人每次传递一个糖果代价为1。 求使所有人获得均等糖果的最小代价。</p><a id="more"></a><h2 id="思路">思路</h2><p><img src="https://gitee.com/adameta/img/raw/master/1584343110_20200316145159297_13254.png"></p><p>假设<span class="math inline">\(n\)</span>个小朋友分别有<span class="math inline">\(a_1,a_2,...,a_n\)</span>个糖果，第<span class="math inline">\(i\)</span>个小朋友给<span class="math inline">\(i-1\)</span>个小朋友<span class="math inline">\(x_i\)</span>个糖果，（<span class="math inline">\(x_i\)</span>可正可负） 那么目标就为<span class="math inline">\(\min\sum|x_i|\)</span>。 对于上述的问题转化，可以列出方程组: <span class="math inline">\(\begin{cases}a_1-x_1+x_2=\bar{a} \\ a_2-x_2+x_3=\bar{a}\\...\\ a_n-x_n+x_1=\bar{a}\end{cases}\)</span></p><p>进一步的化简为: <span class="math inline">\(\begin{cases}x_1=x_1-(n\bar{a}-a_1-a_2-...-a_n)\\x_2=x_1-((n-1)\bar{a}-a_2-a_3-...-a_n)\\...\\x_{n-1}=x_1-(2\bar{a}-a_{n+1}-a_n)\\x_n=x_1-(\bar{a}-a_n)\end{cases}\)</span></p><p>注意: 化简过程是对于第i个式子，使用第i+1到第n个式子,例如对于第n-1项来说： <span class="math inline">\(\begin{cases} a_{n-1}-x_{n-1}+x_{n}=\bar{a}\\ a_n-x_n+x_1=\bar{a}\end{cases}\)</span> 将最后一个方程的<span class="math inline">\(x_n\)</span>带入到倒数第二个方程中，把<span class="math inline">\(x_n=x_1-(\bar{a}-a_n)\)</span>带入到<span class="math inline">\(a_{n-1}-x_{n-1}+x_{n}=\bar{a}\)</span>中，得到<span class="math inline">\(x_{n-1}=x_1-(2\bar{a}-a_{n+1}-a_n)\)</span>。以此类推</p><p>令右式常数分别为<span class="math inline">\(c_1,c_2,...,c_n\)</span></p><p>可以得到目标<span class="math inline">\(\min\sum|x_i|=(|x_1-c_1|+|x_1-c_2|+...+|x_1-c_n|)\)</span>，又因为<span class="math inline">\((|x_1-c_1|+|x_1-c_2|+...+|x_1-c_n|)\)</span>等价于在数轴上找一个点<span class="math inline">\(x_1\)</span>，该点到<span class="math inline">\(c_1,c_2,...,c_n\)</span>的距离之和最小。即转化为下面问题： 在一个数轴上，有偶数个点<span class="math inline">\(c_1,c_2,...,c_n\)</span>,需要找到一个点<span class="math inline">\(x_1\)</span>使得<span class="math inline">\(x_1\)</span>到其他点的距离最小，不难证明<span class="math inline">\(x_1\)</span>为中位数（可以视作一个结论，证明见最下面）。 <img src="https://gitee.com/adameta/img/raw/master/1584343112_20200316151251991_11809.png"></p><p>最后可以总结出算法 * 求出<span class="math inline">\(a\)</span>平均数<span class="math inline">\(\bar{a}\)</span> * 求出<span class="math inline">\(c_1,c_2,...,c_n\)</span> * 求出其中的中点值<span class="math inline">\(x_1\)</span>（对c数组排序） * 计算<span class="math inline">\(|x_1-c_1|+|x_1-c_2|+...+|x_1-c_n|\)</span></p><p>其中第二个步骤求出c的数组使用了一下递推式：</p><p><span class="math inline">\(\begin{cases}c_i=c_{i+1}+\bar{a}-a_i\\c_n =\bar{a}-a_n \end{cases}\)</span></p><p>递推式<span class="math inline">\(c_i=c_{i+1}+\bar{a}-a_i\)</span>使用第<span class="math inline">\(i+1\)</span>项方程减去第<span class="math inline">\(i\)</span>项方程既可。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll n;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll abar;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i], abar += a[i];</span><br><span class="line">  abar /= n;</span><br><span class="line">  a[n] = abar - a[n];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) a[i] = a[i + <span class="number">1</span>] + abar - a[i];</span><br><span class="line">  sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">  ll p = (a[n / <span class="number">2</span>] + a[n / <span class="number">2</span> + <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    res += <span class="built_in">abs</span>(a[i] - p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他">其他</h2><p>『题目传送门』：<a href="https://www.acwing.com/problem/content/106/" target="_blank" rel="noopener external nofollow noreferrer">acwing104</a> 关于一个数轴上的序列<span class="math inline">\(c_1,c_2,...,c_n\)</span>,需要找到一个点<span class="math inline">\(x_1\)</span>使得<span class="math inline">\(x_1\)</span>到其他点的距离最小。</p><p>思路：首先对<span class="math inline">\(c\)</span>排序,使得<span class="math inline">\(c_1 &lt; c_2 &lt; ... &lt; c_n\)</span>，考虑<span class="math inline">\(c_1,c_n\)</span>，<span class="math inline">\(c_2,c_{n-1}\)</span>...,<span class="math inline">\(c_{k-1},c_k\)</span>两两配对，以<span class="math inline">\(c_1,c_n\)</span>这一对来考虑 <img src="https://gitee.com/adameta/img/raw/master/1584343976_20200316152640321_695.png"></p><p>继续扩展到4个点，（两对） <img src="https://gitee.com/adameta/img/raw/master/1584343976_20200316153020498_14966.png"></p><p>推广到<span class="math inline">\(n=k\)</span>的情况下（<span class="math inline">\(k=n/2\)</span>）同理，因此可知<span class="math inline">\(x\)</span>应该取到<span class="math inline">\(\frac{x_k+x_{k+1}}{2}\)</span>。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>贪心</category>
        <category>思维题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀表达式</title>
    <url>/archives/acw1247.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h1 id="acwing1247后缀表达式">acwing1247后缀表达式</h1><p><a href="https://www.acwing.com/problem/content/description/1249/" target="_blank" rel="noopener external nofollow noreferrer">后缀表达式</a></p><hr><p>题目大意：n+1个+ m个-加入到表达式中使得整个序列最大</p><a id="more"></a><p>分析: <strong>这个题目贪心的关键是考虑到负号的数目不是m个，而是1到m+n个</strong> 考虑系列如下： <span class="math display">\[\text{target}:\max(a_1+a_2+...+a_{i-1})-\min(b_i-b_{i+1}-...-b_n)\]</span> 其中<span class="math inline">\(\min()\)</span>中可以有负号和正号，展开式子之后得到的是其取反，因此考虑极端的状态如果所有的<span class="math inline">\(n-1\)</span>个+放在<span class="math inline">\(\min\)</span>中，<span class="math inline">\(m-1\)</span>个-放在<span class="math inline">\(\max\)</span>中，那么总共就有<span class="math inline">\(n+m\)</span>个负数。同理的，可以在确定了两个数分别作为<span class="math inline">\(a_1\)</span>和<span class="math inline">\(b_{i+1}\)</span>之后，就只需在两个数列中继续加入数字即可。</p><p>即把一个负号提出来剩余负号都在b中那么就只有一个负号 如果把一个负号提出来m-2个负号在b中那么就有2个负号 ... 以此类推从总共可以有m+n到1个负号 至少有一个加号，至少有一个负号</p><p>那么因此序列如下： <span class="math display">\[\text{target}:\max(a_1(-/+)a_2(-/+)...(-/+)a_n)-\min(b_i(-/+)b_{i+1}(-/+)...(-/+)b_n)\]</span></p><p><strong>贪心策略</strong>：为了使得<span class="math inline">\(\text{target}\)</span>最大，我们尽量把<strong>所有的负数加到右边，把正数加到左边</strong>。那么相当于取到其他的数的绝对值。 因此总的答案应该是 <span class="math inline">\(a\)</span> 排序后 <span class="math display">\[\sum_{i=2}^{n-1}\text{abs}(a[i])-a[1]+a[n]\]</span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> judge</span></span><br><span class="line">  freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m + <span class="number">1</span>; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m + <span class="number">1</span>; i++) res += a[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(a + <span class="number">1</span>, a + n + m + <span class="number">2</span>);</span><br><span class="line">  res = -a[<span class="number">1</span>] + a[n + m + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + m + <span class="number">1</span>; i++) res += <span class="built_in">abs</span>(a[i]);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>贪心</category>
        <category>思维题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>约数和</title>
    <url>/archives/acw1296.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h1 id="约数和">约数和</h1><p><a href="https://www.acwing.com/problem/content/description/1298/" target="_blank" rel="noopener external nofollow noreferrer">『聪明的燕姿』</a></p><p>题目大意：给定一个S，求出所有符合质因数分解的和为S的数x</p><p>思路：DFS、约数和公式</p><p>约数和公式</p><p><span class="math display">\[ s=(p_1^0 + p_1^1 + ... + p_1^{\alpha_1})...(p_k^0+p_k^1+...+p_k^{\alpha_k}) \]</span> 其中 <span class="math inline">\(p\)</span> 为质因子，<span class="math inline">\(\alpha\)</span> 为质因子幂次。</p><a id="more"></a><p>之后，考虑到给定当前式子和，未知为质因子和质因子幂，已知约数和<span class="math inline">\(S\)</span>。考虑到式子每一项的大小，项数应该确定在10项以内（根据式子），因此使用<code>DFS</code>搜索位置系数。</p><p>那么该如何搜索？</p><ul><li>枚举p，找到一个可能的p</li><li>枚举alpha，找到一个可能的alpha</li><li>对于枚举的一个项能被整除，则进行下一个枚举</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(u,...)</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(p: <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">11.</span>..)</span></span></span><br><span class="line"><span class="function">        fact </span>= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(alpha <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">if</span> s % fact ==<span class="number">0</span></span><br><span class="line">                    dfs(u+<span class="number">1</span>,...)</span><br></pre></td></tr></table></figure><p>考虑上面式子中枚举质因子p,因为小于S的质数共有 <span class="math inline">\(\frac{S}{logn}\)</span>个（质数基本定理），粗略估计是 1e8 的数量级。 直接枚举p是不可以接受的。</p><p>如果 alpha=1 ,则因子变为 <span class="math inline">\(S=1+p_i\)</span> 的形式，当 <span class="math inline">\(S-1\)</span> 是质数的时候成立。判定质数是 <span class="math inline">\(O(\sqrt{n})\)</span></p><p>否则 当 <span class="math inline">\(S\neq1+p_i\)</span> ：</p><p>即有两种可能：</p><p><span class="math display">\[ S = (1+p_i+p_i^2+...)(...)... \\ S = (1+p_i)(...) \]</span></p><p>对于第一种情况</p><p><span class="math display">\[ S = (1+p_i+p_i^2+...)(...) \]</span></p><p><span class="math inline">\(p_i^2 &lt; S\)</span> ，发现在项中的每一项含有 <span class="math inline">\(p^2\)</span> 的项只用枚举到平方即可。时间复杂度即第一个for只用枚举到平方小于x然后再特判第一个p即可。</p><p>而对于第二种情况 <span class="math inline">\(p_i^2 &lt; S\)</span>也是必然成立的，即枚举时若有<span class="math inline">\(p_i^2 &gt; S\)</span>则直接退出当前的枚举。即对于每一个素数枚举到<span class="math inline">\(\sqrt{S}\)</span>即可，（即当<span class="math inline">\(p_i^2&lt;S\)</span>时可以枚举）这样的话根据上面分析，最多会有10项，每一项需要枚举<span class="math inline">\(\sqrt{S}\)</span>，总共k组数据所以时间复杂度是 <span class="math inline">\(10*k\sqrt{S}\)</span>即为<span class="math inline">\(5e7\)</span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> judge</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>;</span><br><span class="line"><span class="keyword">int</span> primes[maxn], cnt, used[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!used[i]) primes[cnt++] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++) &#123;</span><br><span class="line">      used[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">last 上一个fact项的质数下标是多少</span></span><br><span class="line"><span class="comment">prod 当前代求答案数</span></span><br><span class="line"><span class="comment">s 剩余的S</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_p</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; maxn) <span class="keyword">return</span> !used[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; primes[i] &lt;= x / primes[i]; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % primes[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> prod, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">1</span>) &#123;  <span class="comment">// get a ans</span></span><br><span class="line">    ans[len++] = prod;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s - <span class="number">1</span> &gt; (last &lt; <span class="number">0</span> ? <span class="number">1</span> : primes[last]) &amp;&amp; is_p(s - <span class="number">1</span>)) &#123;  <span class="comment">//上一个质数</span></span><br><span class="line">    <span class="comment">// s-1&gt;1成立 （第一次）</span></span><br><span class="line">    <span class="comment">// s-1&gt;p_last 大于上一个质数 即还可以枚举</span></span><br><span class="line">    ans[len++] = prod * (s - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = last + <span class="number">1</span>; primes[i] &lt;= s / primes[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = primes[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> + p, t = p; j &lt;= s; t *= p, j += t) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s % j == <span class="number">0</span>) &#123;</span><br><span class="line">        dfs(i, prod * t, s / j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> judge</span></span><br><span class="line">  freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  getp(maxn - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  假设自己的号码牌上写着数字 S，</span></span><br><span class="line"><span class="comment">  那么自己等的人手上的号码牌数字的所有正约数之和必定等于 S。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法是使用约数和公式</span></span><br><span class="line"><span class="comment">    一个数的约数的和等于</span></span><br><span class="line"><span class="comment">    $$(p_1^0+p_1^1+...+p_1^\alpha_1)...(p_k^0+p_k^1+...+p_k^\alpha_k)$$</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">    len = <span class="number">0</span>;  <span class="comment">//当前搜索的长度</span></span><br><span class="line">    dfs(<span class="number">-1</span>, <span class="number">1</span>, s);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (len) &#123;</span><br><span class="line">      sort(ans, ans + len);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>因式分解</category>
        <category>搜索</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>因式分解</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>blog 改造计划</title>
    <url>/archives/blog_plan.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><p>因为 kramdown 解析器对 MathJax 有支持问题，在书写某些数学公式时常常发生奇怪的错误。 最为典型的便是 <code>$x_1+x_2$</code> 会先被 markdown 解析为斜体，之后 MathJax 就无法得到正确的公式。 为了获得更好的支持体验，在前辈<a href="https://blog.yuki-nagato.com/" target="_blank" rel="noopener external nofollow noreferrer">長門有希</a>建议下使用了更好的数学公式解析支持 <a href="https://pandoc.org/" target="_blank" rel="noopener external nofollow noreferrer">Pandoc</a>，做了相关调研后，确定使用 hexo 下的 nexT 主题，将默认的解析器更换为 hexo-renderer-pandoc。完美解决了该问题<a href="https://adameta.top/archives/mathjax_plugin.html">测试mathjax插件</a>。之后对博客做些许美化，如下：</p><p>计划将博客从 jeklly 迁移到 hexo, 版本为 7.7.2。</p><a id="more"></a><ul><li>[x] 加入了搜索功能</li><li>[x] 加入 mathjax 插件支持,能够完美解析公式</li><li>[x] 添加 categories, tag, about, links 页面</li><li>[x] 在文章末尾加入了频道订阅</li><li>[x] 加入了头像和联系方式</li><li>[x] 加入了字数统计和阅读时间提醒</li><li>[x] 解决友情链接问题</li><li>[x] 加入文章进度条</li><li>[x] 对文章连接永久化操作</li><li>[x] 修改返回文章顶部按钮</li><li>[x] 文件压缩插件，以及其他加快浏览速度</li><li>[x] 文章顶置功能</li><li>[x] 修改主页文章显示长度</li><li>[x] 加入近期文章</li><li>[x] 加入中文字体</li><li>[x] 对总体样式进行优化（边角的优化）</li><li>[x] 完善联系方式</li><li>[x] 背景图片</li><li>[x] 修改 head 图标</li><li>[x] 文章末尾添加 copyright</li><li>[x] 加入代码框阴影效果,复制功能</li><li>[x] 文章评论功能</li><li>[ ] 国内外访问速度问题（Hexo 博客部署在 GitHub Pages 上并且配置 CDN 进行加速）</li><li>[ ] 提交搜索引擎收录</li><li>[ ] 加入了夜间模式 X | 目前原生支持有bug</li><li>[ ] 阅读排行榜 (热门文章) | 待完善</li></ul><hr><p>参考连接：</p><p><a href="https://tding.top/archives/aad98408.html" target="_blank" rel="noopener external nofollow noreferrer">Hexo 搭建个人博客文章汇总</a></p><p><a href="http://lx34r.coding.me/posts/3018881965/" target="_blank" rel="noopener external nofollow noreferrer">优化个人博客(theme_next)相关</a></p><p><a href="https://tding.top/archives/29bfe8c9.html" target="_blank" rel="noopener external nofollow noreferrer">Hexo-NexT Tag 插件的使用</a></p><p><a href="https://theme-next.org/docs/theme-settings/posts" target="_blank" rel="noopener external nofollow noreferrer">NexT Theme for Hexo-Posts</a></p><p><a href="https://hexo.io/docs/front-matter" target="_blank" rel="noopener external nofollow noreferrer">Front-matter</a></p><p><a href="https://www.jianshu.com/p/78c218f9d1e7" target="_blank" rel="noopener external nofollow noreferrer">Hexo-设置阅读全文</a></p><p><a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener external nofollow noreferrer">Hexo-标签插件（Tag Plugins）</a></p><p><a href="https://tding.top/archives/42c38b10" target="_blank" rel="noopener external nofollow noreferrer">Hexo-NexT (v7.0+) 主题配置</a></p><p><a href="https://theme-next.org/docs" target="_blank" rel="noopener external nofollow noreferrer">Hexo-NexT 官方文档</a></p><p><a href="https://zhangzw.com/posts/20190830.html" target="_blank" rel="noopener external nofollow noreferrer">Hexo 给文章中英文添加空格</a></p><p><a href="https://tding.top/docs/getting-started/data-files.html" target="_blank" rel="noopener external nofollow noreferrer">数据文件</a></p><p><a href="https://memento.net.cn/post/4af0cb81.html" target="_blank" rel="noopener external nofollow noreferrer">相关文章之 hexo-related-popular-posts</a></p><p><a href="http://blog.amdoing.com/the-post-copyright-in-hexo-next/" target="_blank" rel="noopener external nofollow noreferrer">使用Hexo的next主题，配置POST文章文末的版权信息</a></p><p><a href="https://github.com/1v9/hexo-next-nightmode" target="_blank" rel="noopener external nofollow noreferrer">Hexo NexT Night Mode</a></p><p><a href="https://github.com/theme-next/hexo-theme-next/pull/1386" target="_blank" rel="noopener external nofollow noreferrer">Native Dark Mode support #1386</a></p><p><a href="https://valine.js.org/hexo.html#hexo-theme-next" target="_blank" rel="noopener external nofollow noreferrer">valine hexo-theme-next</a></p><p><a href="https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener external nofollow noreferrer">hexo-Next-主题添加评论功能</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>测试mathjax插件</title>
    <url>/archives/mathjax_plugin.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><p>用于测试 Pandoc 解析器。 给出一些测试公式<a id="more"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\frac&#123;\partial u&#125;&#123;\partial t&#125;</span><br><span class="line">&#x3D; h^2 \left( \frac&#123;\partial^2 u&#125;&#123;\partial x^2&#125; +</span><br><span class="line">\frac&#123;\partial^2 u&#125;&#123;\partial y^2&#125; +</span><br><span class="line">\frac&#123;\partial^2 u&#125;&#123;\partial z^2&#125;\right)$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[\frac{\partial u}{\partial t} = h^2 \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}\right)\]</span></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\left[</span><br><span class="line">    \begin&#123;array&#125;&#123;cc|c&#125;</span><br><span class="line">      1&amp;2&amp;3\newline</span><br><span class="line">      4&amp;5&amp;6</span><br><span class="line">    \end&#123;array&#125;</span><br><span class="line">\right] </span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[ \left[ \begin{array}{cc|c} 1&amp;2&amp;3\newline 4&amp;5&amp;6 \end{array} \right] \]</span></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">&#123;\mathcal L&#125;_&#123;cyc&#125;(G,F)&#x3D;&#123;\mathbb E&#125;_&#123;x \sim p_&#123;data&#125;(x)&#125;[&#123;\|F(G(x))-x\|&#125;_&#123;1&#125;]+&#123;\mathbb E&#125;_&#123;y \sim p_&#123;data&#125;(y)&#125;[&#123;\|G(F(y))-y\|&#125;_&#123;1&#125;]</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[ {\mathcal L}_{cyc}(G,F)={\mathbb E}_{x \sim p_{data}(x)}[{\|F(G(x))-x\|}_{1}]+{\mathbb E}_{y \sim p_{data}(y)}[{\|G(F(y))-y\|}_{1}] \]</span></p><p>测试一下功能：</p><p><span class="math display">\[e_r( x^{*} ) = \frac{x-x^*}{x^*}\]</span> <span class="math display">\[\mathop{x} \limits_a^b\]</span> <span class="math display">\[e_r( x^{*} ) = \frac{x-x^*}{x^*}\]</span> <span class="math display">\[a_x+b_x=c_x\]</span> <span class="math display">\[e\left ( x^{*} \right ) = x - x^{*}\]</span> <span class="math display">\[ \left| e \right|=\left | x-x^* \right |\leq \varepsilon \]</span> <span class="math display">\[ \min_{\mathbf{w},b} \frac{1}{2} \Vert \mathbf{w} \Vert^2 \quad s.t. \quad y_i(\mathbf{w}^T\phi(\mathbf{x})+b) \geq 1, \quad i=1,2,...,m\qquad(9) \]</span> <span class="math display">\[ e\left ( x^{*} \right ) = x - x^{*}x = a_0 + \frac{1}{a_1 +\sqrt{a^2+b^2} \frac{1}{a_2 + \frac{1}{a_3 + a_4}}}\sqrt{a^2+b^2} \]</span> <span class="math display">\[ f(n)=\begin{cases} n/2, &amp; \text{如果$ x \leqslant 2 $}\\ 3n+1, &amp; \text{如果$ x&gt;2 $} \end{cases} \]</span> <span class="math display">\[\max \limits_{a&lt;x&lt;b}\{f(x)\}\]</span> <span class="math display">\[ \beta^*(D) = \mathop{argmin} \limits_{\beta} \lambda {||\beta||}^2 + \sum_{i=1}^n max(0, 1 - y_i f_{\beta}(x_i)) \]</span></p><p><span class="math display">\[ \left(\begin{array}{c}s \\ t\end{array}\right)= \left( \begin{array}{cc} cos(b) &amp; -sin(b) \\ sin(b) &amp; cos(b) \end{array} \right) \left( \begin{array}{c} x \\ y \end{array} \right) \]</span></p><p>测试源码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$e_r( x^&#123;*&#125;  ) &#x3D; \frac&#123;x-x^*&#125;&#123;x^*&#125;$$</span><br><span class="line">$$\mathop&#123;x&#125; \limits_a^b$$</span><br><span class="line">$$e_r( x^&#123;*&#125;  ) &#x3D; \frac&#123;x-x^*&#125;&#123;x^*&#125;$$</span><br><span class="line">$$a_x+b_x&#x3D;c_x$$</span><br><span class="line">$$e\left ( x^&#123;*&#125; \right ) &#x3D; x - x^&#123;*&#125;$$</span><br><span class="line">$$</span><br><span class="line">\left| e \right|&#x3D;\left | x-x^* \right |\leq \varepsilon</span><br><span class="line">$$</span><br><span class="line">$$</span><br><span class="line">\min_&#123;\mathbf&#123;w&#125;,b&#125; \frac&#123;1&#125;&#123;2&#125; \Vert \mathbf&#123;w&#125; \Vert^2 \quad s.t. \quad y_i(\mathbf&#123;w&#125;^T\phi(\mathbf&#123;x&#125;)+b) \geq 1, \quad  i&#x3D;1,2,...,m\qquad(9)</span><br><span class="line">$$</span><br><span class="line">$$</span><br><span class="line">e\left ( x^&#123;*&#125; \right ) &#x3D; x - x^&#123;*&#125;x &#x3D; a_0 + \frac&#123;1&#125;&#123;a_1 +\sqrt&#123;a^2+b^2&#125; \frac&#123;1&#125;&#123;a_2 + \frac&#123;1&#125;&#123;a_3 + a_4&#125;&#125;&#125;\sqrt&#123;a^2+b^2&#125;</span><br><span class="line">$$</span><br><span class="line">$$</span><br><span class="line">f(n)&#x3D;\begin&#123;cases&#125;</span><br><span class="line">n&#x2F;2, &amp; \text&#123;如果$ x \leqslant 2 $&#125;\\</span><br><span class="line">3n+1, &amp; \text&#123;如果$ x&gt;2 $&#125;</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br><span class="line">$$\max \limits_&#123;a&lt;x&lt;b&#125;\&#123;f(x)\&#125;$$</span><br><span class="line">$$</span><br><span class="line">\beta^*(D) &#x3D; \mathop&#123;argmin&#125; \limits_&#123;\beta&#125; \lambda &#123;||\beta||&#125;^2 + \sum_&#123;i&#x3D;1&#125;^n max(0, 1 - y_i f_&#123;\beta&#125;(x_i)) </span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\left(\begin&#123;array&#125;&#123;c&#125;s \\</span><br><span class="line">  t\end&#123;array&#125;\right)&#x3D;</span><br><span class="line">\left(</span><br><span class="line">    \begin&#123;array&#125;&#123;cc&#125;</span><br><span class="line">      cos(b) &amp; -sin(b) \\</span><br><span class="line">      sin(b) &amp; cos(b)</span><br><span class="line">    \end&#123;array&#125;</span><br><span class="line">\right)</span><br><span class="line">\left(</span><br><span class="line">    \begin&#123;array&#125;&#123;c&#125;</span><br><span class="line">      x \\</span><br><span class="line">      y</span><br><span class="line">    \end&#123;array&#125;</span><br><span class="line">\right)</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>工具</category>
        <category>MathJax</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>支持区间修改的树状数组</title>
    <url>/archives/variant_BIT.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 12:39:14 GMT+0800 (GMT+08:00) --><h1 id="支持区间修改的树状数组">支持区间修改的树状数组</h1><p>能够在对数时间复杂度内支持区间修改的树状数组变种。 实质是两个树状数组来维护着差分前缀和，其中空间是3倍的区间长度,<span class="math inline">\(O(3*n)\)</span>。</p><a id="more"></a><h2 id="原理">原理</h2><p>对于一个数组<span class="math inline">\(a\)</span>，以及<span class="math inline">\(a\)</span>的差分<span class="math inline">\(c\)</span>，显然有</p><p><span class="math inline">\(c[i]=a[i]-a[i-1]\)</span></p><p>那么对于数组a的前缀和有</p><p><span class="math inline">\(\sum_{i=1}^n{a_i}=c[1]+(c[1]+c[2])+...(c[1]+c[2]+...+c[n])\)</span></p><p>进一步的：</p><p><span class="math inline">\(\sum_{i=1}^n{a_i}=c[1]*n+c[2]*(n-1)+...+c[n]*(n-n+1)\)</span></p><p>展开括号内</p><p><span class="math inline">\(\sum_{i=1}^n{a_i}=c[1]*n+c[2]*n+...+c[n]*n-(c[1]*(1-1)+c[2]*(2-1)+...+c[n]*(n-1))\)</span></p><p>即为</p><p><span class="math inline">\(\sum_{i=1}^n{a_i}=n*\sum_{i=1}^n{c[i]}-\sum_{i=1}^n{c[i]*(i-1)}\)</span></p><p>因此维护一个前缀和数组需要维护两个差分前缀和<span class="math inline">\(c[i]\)</span>和<span class="math inline">\((i-1)*c[i]\)</span>，对应为维护<span class="math inline">\(\sum_{i=1}^n{c[i]}\)</span>，<span class="math inline">\(\sum_{i=1}^n{(i-1)*c[i]}\)</span></p><p>这里使用两个树状数组对上述差分数组前缀和维护，分别命名为<span class="math inline">\(tr\)</span>和<span class="math inline">\(tr1\)</span>。</p><h2 id="实现">实现</h2><p>首先明确基本树状数组的两个基本操作：<strong>区间查询</strong>和<strong>单调查询</strong>。使用树状数组维护前缀和：</p><ol type="1"><li>区间查询 <span class="math inline">\(\text{query}(k)\)</span>，1到k之间的前缀和<span class="math inline">\(\sum_{i=1}^k{a[i]}\)</span>。</li><li>单点修改 <span class="math inline">\(\text{add}(k,x)\)</span>, <span class="math inline">\(a[k]+=x\)</span>。</li></ol><p>那么对于本文中的<strong>支持区间修改</strong>的树状数组有以下操作：</p><p>1.<strong>区间修改</strong> <span class="math inline">\(\text{add}(l,r,k)\)</span>(l和r包含),等效于操作<span class="math inline">\(\text{add1(l,x)}\)</span>,<span class="math inline">\(\text{add1}(r+1,-x)\)</span>和<span class="math inline">\(\text{add2}(l,(l-1)*x)\)</span>,<span class="math inline">\(\text{add2}(r+1,r*(-x))\)</span>(差分性质定义)</p><p>2.区间查询 ,<span class="math inline">\(querysum(k)\)</span>,等效于操作<span class="math inline">\(k*\text{query1}(k)*k-\text{query2}(k)\)</span></p><h2 id="操作">操作</h2><h3 id="基本树状数组">基本树状数组</h3><p>实现了<span class="math inline">\(O(log(n))\)</span>单点修改和区间查询。 支持单点修改，区间查询，单点查询。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll tr[maxn];  <span class="comment">//树状数组1用于维护差分前缀和$\sum_&#123;i=1&#125;^n&#123;c[i]&#125;$</span></span><br><span class="line">ll tr1[maxn]; <span class="comment">//树状数组2用于维护差分前缀和$\sum_&#123;i=1&#125;^n&#123;(i-1)*c[i]&#125;$</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll tr[], <span class="keyword">int</span> l, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= n; i += lowbit(i)) tr[i] = (tr[i] + k) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll tr[], <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i -= lowbit(i)) res = (res + tr[i]) % mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化">初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> nn)</span> </span>&#123;</span><br><span class="line">  n = nn + <span class="number">2</span>;<span class="comment">//防止空间越界</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) tr[i] = tr1[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间修改">区间修改</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//[l,r]区间修改+x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  add(tr, l, x);</span><br><span class="line">  add(tr, r + <span class="number">1</span>, -x);</span><br><span class="line">  add(tr1, l, <span class="number">1l</span>l * (l - <span class="number">1</span>) * x);</span><br><span class="line">  add(tr1, r + <span class="number">1</span>, <span class="number">1l</span>l * r * (-x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间查询">区间查询</h3><p>查询<span class="math inline">\(\sum_{i=1}^ka[i]\)</span>，即查询<span class="math inline">\([1,k]\)</span>内的前缀和</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//区间查询原数组sum(a[1,k])</span></span><br><span class="line"><span class="function">ll <span class="title">querysum</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1l</span>l * query(tr, k) * k)  - query(tr1, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间修改-1">区间修改</h3><p>在<span class="math inline">\(a[l]...a[r]\)</span>区间加上<span class="math inline">\(x\)</span>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//[l,r]区间修改+x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  add(tr, l, x);</span><br><span class="line">  add(tr, r + <span class="number">1</span>, -x);</span><br><span class="line">  add(tr1, l, <span class="number">1l</span>l * (l - <span class="number">1</span>) * x);<span class="comment">//防止暴int</span></span><br><span class="line">  add(tr1, r + <span class="number">1</span>, <span class="number">1l</span>l * r * (-x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="复杂度分析">复杂度分析</h2><p>实质是两个树状数组来维护着差分前缀和，其中空间是3倍的区间长度,<span class="math inline">\(O(3*n)\)</span> 时间复杂度： 在以下操作均为<span class="math inline">\(O(log(n))\)</span>：</p><ul><li>区间同加x</li><li>区间查询</li><li>单点查询</li><li>单调同加x</li></ul><p>相比线段树空间复杂度<span class="math inline">\(O(4*n)\)</span>要小 时间复杂度相同。</p><p>编程复杂度差不多（<del>都好难orz</del>）</p><h2 id="整合模板">整合模板</h2><p><a href="https://acm.uestc.edu.cn/problem/qing-xue-jie-chong-mei-li-de-hua/description" target="_blank" rel="noopener external nofollow noreferrer">题目传送门</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> judge</span></span><br><span class="line"><span class="comment">// Author: oceanlvr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> faster_iostream = []() &#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">772002</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll tr[maxn];  <span class="comment">//树状数组1</span></span><br><span class="line">ll tr1[maxn]; <span class="comment">//树状数组2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll tr[], <span class="keyword">int</span> l, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= n; i += lowbit(i)) tr[i] = (tr[i] + k) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll tr[], <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i -= lowbit(i)) res = (res + tr[i]) % mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[l,r]区间修改+x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  add(tr, l, x);</span><br><span class="line">  add(tr, r + <span class="number">1</span>, -x);</span><br><span class="line">  add(tr1, l, <span class="number">1l</span>l * (l - <span class="number">1</span>) * x);</span><br><span class="line">  add(tr1, r + <span class="number">1</span>, (<span class="number">1l</span>l * r * (-x)%mod+mod)%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询原数组sum(a[1,k])</span></span><br><span class="line"><span class="function">ll <span class="title">querysum</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (((<span class="number">1l</span>l * query(tr, k) * k) % mod - query(tr1, k) % mod) % mod + mod) %</span><br><span class="line">         mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> nn)</span> </span>&#123;</span><br><span class="line">  n = nn + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) tr[i] = tr1[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//按题目要求区间[l,r]修改 [l+1,r]+d,[l,l]+a0,[r+1,r+1]-前面两个的和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addad</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a0, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  add(l, l, a0);                     <span class="comment">//单点l上+a0</span></span><br><span class="line">  <span class="keyword">if</span> (l + <span class="number">1</span> &lt;= r) add(l + <span class="number">1</span>, r, d);  <span class="comment">//区间[l+1,r] +d</span></span><br><span class="line">  add(r + <span class="number">1</span>, r + <span class="number">1</span>,</span><br><span class="line">      (-(a0 + (<span class="number">1l</span>l * (r - l) * d)) % mod + mod) % mod);  <span class="comment">//单点r+1 -前面两个的和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询原数组sum(a[1,k])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryad</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123; <span class="keyword">return</span> querysum(k); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> op;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> judge</span></span><br><span class="line">  freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i],a[i]%=mod;</span><br><span class="line">  init(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> x, y;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      <span class="comment">//(y+1)y/2</span></span><br><span class="line">      <span class="comment">//对[x,x+y-1]加上一个-1</span></span><br><span class="line">      <span class="keyword">int</span> l = x, r = min(x + y - <span class="number">1</span>, n);</span><br><span class="line">      addad(l, r, y, <span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; (a[x] + queryad(x)) % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.cnblogs.com/acmsong/p/7225903.html" target="_blank" rel="noopener external nofollow noreferrer">树状数组区间加等差数列</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
</search>
